<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>perlboot - Beginner's Object-Oriented Tutorial</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>perlboot - Beginner's Object-Oriented Tutorial</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#if_we_could_talk_to_the_animals___">If we could talk to the animals...</a></li>
		<li><a href="#introducing_the_method_invocation_arrow">Introducing the method invocation arrow</a></li>
		<li><a href="#invoking_a_barnyard">Invoking a barnyard</a></li>
		<li><a href="#the_extra_parameter_of_method_invocation">The extra parameter of method invocation</a></li>
		<li><a href="#calling_a_second_method_to_simplify_things">Calling a second method to simplify things</a></li>
		<li><a href="#inheriting_the_windpipes">Inheriting the windpipes</a></li>
		<li><a href="#a_few_notes_about__isa">A few notes about @ISA</a></li>
		<li><a href="#overriding_the_methods">Overriding the methods</a></li>
		<li><a href="#starting_the_search_from_a_different_place">Starting the search from a different place</a></li>
		<li><a href="#the_super_way_of_doing_things">The SUPER way of doing things</a></li>
		<li><a href="#let_s_review___">Let's review...</a></li>
		<li><a href="#a_horse_is_a_horse__of_course_of_course__or_is_it">A horse is a horse, of course of course, or is it?</a></li>
		<li><a href="#invoking_an_instance_method">Invoking an instance method</a></li>
		<li><a href="#accessing_the_instance_data">Accessing the instance data</a></li>
		<li><a href="#how_to_build_a_horse">How to build a horse</a></li>
		<li><a href="#inheriting_the_constructor">Inheriting the constructor</a></li>
		<li><a href="#making_a_method_work_with_either_classes_or_instances">Making a method work with either classes or instances</a></li>
		<li><a href="#adding_parameters_to_a_method">Adding parameters to a method</a></li>
		<li><a href="#more_interesting_instances">More interesting instances</a></li>
		<li><a href="#a_horse_of_a_different_color">A horse of a different color</a></li>
		<li><a href="#summary">Summary</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>perlboot - Beginner's Object-Oriented Tutorial</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>If you're not familiar with objects from other languages, some of the
other Perl object documentation may be a little daunting, such as
<a href="../../lib/pods/perlobj.html">the perlobj manpage</a>, a basic reference in using objects, and <a href="../../lib/pods/perltoot.html">the perltoot manpage</a>, which
introduces readers to the peculiarities of Perl's object system in a
tutorial way.</p>
<p>So, let's take a different approach, presuming no prior object
experience. It helps if you know about subroutines (<a href="../../lib/pods/perlsub.html">the perlsub manpage</a>),
references (<a href="../../lib/pods/perlref.html">the perlref manpage</a> et. seq.), and packages (<a href="../../lib/pods/perlmod.html">the perlmod manpage</a>), so become
familiar with those first if you haven't already.</p>
<p>
</p>
<h2><a name="if_we_could_talk_to_the_animals___">If we could talk to the animals...</a></h2>
<p>Let's let the animals talk for a moment:</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> Cow::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Cow goes moooo!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> Horse::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Horse goes neigh!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> Sheep::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Sheep goes baaaah!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="variable">Cow::speak</span><span class="operator">;</span>
    <span class="variable">Horse::speak</span><span class="operator">;</span>
    <span class="variable">Sheep::speak</span><span class="operator">;</span>
</pre>
<p>This results in:</p>
<pre>
    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!</pre>
<p>Nothing spectacular here.  Simple subroutines, albeit from separate
packages, and called using the full package name.  So let's create
an entire pasture:</p>
<pre>
    <span class="comment"># Cow::speak, Horse::speak, Sheep::speak as before</span>
    <span class="variable">@pasture</span> <span class="operator">=</span> <span class="string">qw(Cow Cow Horse Sheep Sheep)</span><span class="operator">;</span>
    <span class="keyword">foreach</span> <span class="variable">$animal</span> <span class="operator">(</span><span class="variable">@pasture</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="operator">&amp;{</span><span class="variable">$animal</span><span class="operator">.</span><span class="string">"::speak"</span><span class="operator">};</span>
    <span class="operator">}</span>
</pre>
<p>This results in:</p>
<pre>
    a Cow goes moooo!
    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!
    a Sheep goes baaaah!</pre>
<p>Wow.  That symbolic coderef de-referencing there is pretty nasty.
We're counting on <code>no strict refs</code> mode, certainly not recommended
for larger programs.  And why was that necessary?  Because the name of
the package seems to be inseparable from the name of the subroutine we
want to invoke within that package.</p>
<p>Or is it?</p>
<p>
</p>
<h2><a name="introducing_the_method_invocation_arrow">Introducing the method invocation arrow</a></h2>
<p>For now, let's say that <code>Class-&gt;method</code> invokes subroutine
<code>method</code> in package <code>Class</code>.  (Here, &quot;Class&quot; is used in its
&quot;category&quot; meaning, not its &quot;scholastic&quot; meaning.) That's not
completely accurate, but we'll do this one step at a time.  Now let's
use it like so:</p>
<pre>
    <span class="comment"># Cow::speak, Horse::speak, Sheep::speak as before</span>
    <span class="variable">Cow</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
    <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
    <span class="variable">Sheep</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
</pre>
<p>And once again, this results in:</p>
<pre>
    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!</pre>
<p>That's not fun yet.  Same number of characters, all constant, no
variables.  But yet, the parts are separable now.  Watch:</p>
<pre>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="string">"Cow"</span><span class="operator">;</span>
    <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span> <span class="comment"># invokes Cow-&gt;speak</span>
</pre>
<p>Ahh!  Now that the package name has been parted from the subroutine
name, we can use a variable package name.  And this time, we've got
something that works even when <code>use strict refs</code> is enabled.</p>
<p>
</p>
<h2><a name="invoking_a_barnyard">Invoking a barnyard</a></h2>
<p>Let's take that new arrow invocation and put it back in the barnyard
example:</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> Cow::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Cow goes moooo!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> Horse::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Horse goes neigh!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> Sheep::speak </span><span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"a Sheep goes baaaah!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="variable">@pasture</span> <span class="operator">=</span> <span class="string">qw(Cow Cow Horse Sheep Sheep)</span><span class="operator">;</span>
    <span class="keyword">foreach</span> <span class="variable">$animal</span> <span class="operator">(</span><span class="variable">@pasture</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$animal</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>There!  Now we have the animals all talking, and safely at that,
without the use of symbolic coderefs.</p>
<p>But look at all that common code.  Each of the <code>speak</code> routines has a
similar structure: a <a href="../../lib/pods/perlfunc.html#print"><code>print</code></a> operator and a string that contains
common text, except for two of the words.  It'd be nice if we could
factor out the commonality, in case we decide later to change it all
to <code>says</code> instead of <code>goes</code>.</p>
<p>And we actually have a way of doing that without much fuss, but we
have to hear a bit more about what the method invocation arrow is
actually doing for us.</p>
<p>
</p>
<h2><a name="the_extra_parameter_of_method_invocation">The extra parameter of method invocation</a></h2>
<p>The invocation of:</p>
<pre>
    Class-&gt;method(@args)</pre>
<p>attempts to invoke subroutine <code>Class::method</code> as:</p>
<pre>
    <span class="variable">Class::method</span><span class="operator">(</span><span class="string">"Class"</span><span class="operator">,</span> <span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>(If the subroutine can't be found, &quot;inheritance&quot; kicks in, but we'll
get to that later.)  This means that we get the class name as the
first parameter (the only parameter, if no arguments are given).  So
we can rewrite the <code>Sheep</code> speaking subroutine as:</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> Sheep::speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes baaaah!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>And the other two animals come out similarly:</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> Cow::speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes moooo!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> Horse::speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes neigh!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>In each case, <code>$class</code> will get the value appropriate for that
subroutine.  But once again, we have a lot of similar structure.  Can
we factor that out even further?  Yes, by calling another method in
the same class.</p>
<p>
</p>
<h2><a name="calling_a_second_method_to_simplify_things">Calling a second method to simplify things</a></h2>
<p>Let's call out from <code>speak</code> to a helper method called <code>sound</code>.
This method provides the constant text for the sound itself.</p>
<pre>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Cow</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"moooo"</span> <span class="operator">}</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Now, when we call <code>Cow-&gt;speak</code>, we get a <code>$class</code> of <code>Cow</code> in
<code>speak</code>.  This in turn selects the <code>Cow-&gt;sound</code> method, which
returns <code>moooo</code>.  But how different would this be for the <code>Horse</code>?</p>
<pre>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Only the name of the package and the specific sound change.  So can we
somehow share the definition for <code>speak</code> between the Cow and the
Horse?  Yes, with inheritance!</p>
<p>
</p>
<h2><a name="inheriting_the_windpipes">Inheriting the windpipes</a></h2>
<p>We'll define a common subroutine package called <code>Animal</code>, with the
definition for <code>speak</code>:</p>
<pre>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Animal</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Then, for each animal, we say it &quot;inherits&quot; from <code>Animal</code>, along
with the animal-specific sound:</p>
<pre>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Cow</span><span class="operator">;</span>
      <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"moooo"</span> <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Note the added <code>@ISA</code> array (pronounced &quot;is a&quot;).  We'll get to that in a minute.</p>
<p>But what happens when we invoke <code>Cow-&gt;speak</code> now?</p>
<p>First, Perl constructs the argument list.  In this case, it's just
<code>Cow</code>.  Then Perl looks for <code>Cow::speak</code>.  But that's not there, so
Perl checks for the inheritance array <code>@Cow::ISA</code>.  It's there,
and contains the single name <code>Animal</code>.</p>
<p>Perl next checks for <code>speak</code> inside <code>Animal</code> instead, as in
<code>Animal::speak</code>.  And that's found, so Perl invokes that subroutine
with the already frozen argument list.</p>
<p>Inside the <code>Animal::speak</code> subroutine, <code>$class</code> becomes <code>Cow</code> (the
first argument).  So when we get to the step of invoking
<code>$class-&gt;sound</code>, it'll be looking for <code>Cow-&gt;sound</code>, which
gets it on the first try without looking at <code>@ISA</code>.  Success!</p>
<p>
</p>
<h2><a name="a_few_notes_about__isa">A few notes about @ISA</a></h2>
<p>This magical <code>@ISA</code> variable has declared that <code>Cow</code> &quot;is a&quot; <code>Animal</code>.
Note that it's an array, not a simple single value, because on rare
occasions, it makes sense to have more than one parent class searched
for the missing methods.</p>
<p>If <code>Animal</code> also had an <code>@ISA</code>, then we'd check there too.  The
search is recursive, depth-first, left-to-right in each <code>@ISA</code> by
default (see <a href="../../lib/mro.html">the mro manpage</a> for alternatives).  Typically, each <code>@ISA</code> has
only one element (multiple elements means multiple inheritance and
multiple headaches), so we get a nice tree of inheritance.</p>
<p>When we turn on <code>use strict</code>, we'll get complaints on <code>@ISA</code>, since
it's not a variable containing an explicit package name, nor is it a
lexical (&quot;my&quot;) variable.  We can't make it a lexical variable though
(it has to belong to the package to be found by the inheritance mechanism),
so there's a couple of straightforward ways to handle that.</p>
<p>The easiest is to just spell the package name out:</p>
<pre>
    <span class="variable">@Cow::ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
</pre>
<p>Or declare it as a package global variable:</p>
<pre>
    <span class="keyword">package</span> <span class="variable">Cow</span><span class="operator">;</span>
    <span class="keyword">our</span> <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
</pre>
<p>Or allow it as an implicitly named package variable:</p>
<pre>
    <span class="keyword">package</span> <span class="variable">Cow</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">vars</span> <span class="string">qw(@ISA)</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
</pre>
<p>If the <code>Animal</code> class comes from another (object-oriented) module, then
just employ <code>use base</code> to specify that <code>Animal</code> should serve as the basis
for the <code>Cow</code> class:</p>
<pre>
    <span class="keyword">package</span> <span class="variable">Cow</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">base</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
</pre>
<p>Now that's pretty darn simple!</p>
<p>
</p>
<h2><a name="overriding_the_methods">Overriding the methods</a></h2>
<p>Let's add a mouse, which can barely be heard:</p>
<pre>
    <span class="comment"># Animal package from before</span>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Mouse</span><span class="operator">;</span>
      <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"squeak"</span> <span class="operator">}</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"[but you can barely hear it!]\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="variable">Mouse</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
</pre>
<p>which results in:</p>
<pre>
    a Mouse goes squeak!
    [but you can barely hear it!]</pre>
<p>Here, <code>Mouse</code> has its own speaking routine, so <code>Mouse-&gt;speak</code>
doesn't immediately invoke <code>Animal-&gt;speak</code>. This is known as
&quot;overriding&quot;. In fact, we don't even need to say that a <code>Mouse</code> is
an <code>Animal</code> at all, because all of the methods needed for <code>speak</code> are
completely defined for <code>Mouse</code>; this is known as &quot;duck typing&quot;:
&quot;If it walks like a duck and quacks like a duck, I would call it a duck&quot;
(James Whitcomb). However, it would probably be beneficial to allow a
closer examination to conclude that a <code>Mouse</code> is indeed an <code>Animal</code>,
so it is actually better to define <code>Mouse</code> with <code>Animal</code> as its base
(that is, it is better to &quot;derive <code>Mouse</code> from <code>Animal</code>&quot;).</p>
<p>Moreover, this duplication of code could become a maintenance headache
(though code-reuse is not actually a good reason for inheritance; good
design practices dictate that a derived class should be usable wherever
its base class is usable, which might not be the outcome if code-reuse
is the sole criterion for inheritance. Just remember that a <code>Mouse</code>
should always act like an <code>Animal</code>).</p>
<p>So, let's make <code>Mouse</code> an <code>Animal</code>!</p>
<p>The obvious solution is to invoke <code>Animal::speak</code> directly:</p>
<pre>
    <span class="comment"># Animal package from before</span>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Mouse</span><span class="operator">;</span>
      <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
      <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"squeak"</span> <span class="operator">}</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="variable">Animal::speak</span><span class="operator">(</span><span class="variable">$class</span><span class="operator">);</span>
        <span class="keyword">print</span> <span class="string">"[but you can barely hear it!]\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Note that we're using <code>Animal::speak</code>. If we were to invoke
<code>Animal-&gt;speak</code> instead, the first parameter to <code>Animal::speak</code>
would automatically be <code>&quot;Animal&quot;</code> rather than <code>&quot;Mouse&quot;</code>, so that
the call to <code>$class-&gt;sound</code> in <code>Animal::speak</code> would become
<code>Animal-&gt;sound</code> rather than <code>Mouse-&gt;sound</code>.</p>
<p>Also, without the method arrow <code>-&gt;</code>, it becomes necessary to specify
the first parameter to <code>Animal::speak</code> ourselves, which is why <code>$class</code>
is explicitly passed: <code>Animal::speak($class)</code>.</p>
<p>However, invoking <code>Animal::speak</code> directly is a mess: Firstly, it assumes
that the <code>speak</code> method is a member of the <code>Animal</code> class; what if <code>Animal</code>
actually inherits <code>speak</code> from its own base? Because we are no longer using
<code>-&gt;</code> to access <code>speak</code>, the special method look up mechanism wouldn't be
used, so <code>speak</code> wouldn't even be found!</p>
<p>The second problem is more subtle: <code>Animal</code> is now hardwired into the subroutine
selection. Let's assume that <code>Animal::speak</code> does exist. What happens when,
at a later time, someone expands the class hierarchy by having <code>Mouse</code>
inherit from <code>Mus</code> instead of <code>Animal</code>. Unless the invocation of <code>Animal::speak</code>
is also changed to an invocation of <code>Mus::speak</code>, centuries worth of taxonomical
classification could be obliterated!</p>
<p>What we have here is a fragile or leaky abstraction; it is the beginning of a
maintenance nightmare. What we need is the ability to search for the right
method wih as few assumptions as possible.</p>
<p>
</p>
<h2><a name="starting_the_search_from_a_different_place">Starting the search from a different place</a></h2>
<p>A <em>better</em> solution is to tell Perl where in the inheritance chain to begin searching
for <code>speak</code>. This can be achieved with a modified version of the method arrow <code>-&gt;</code>:</p>
<pre>
    ClassName-&gt;FirstPlaceToLook::method</pre>
<p>So, the improved <code>Mouse</code> class is:</p>
<pre>
    <span class="comment"># same Animal as before</span>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Mouse</span><span class="operator">;</span>
      <span class="comment"># same @ISA, &amp;sound as before</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">Animal::speak</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"[but you can barely hear it!]\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>Using this syntax, we start with <code>Animal</code> to find <code>speak</code>, and then
use all of <code>Animal</code>'s inheritance chain if it is not found immediately.
As usual, the first parameter to <code>speak</code> would be <code>$class</code>, so we no
longer need to pass <code>$class</code> explicitly to <code>speak</code>.</p>
<p>But what about the second problem? We're still hardwiring <code>Animal</code> into
the method lookup.</p>
<p>
</p>
<h2><a name="the_super_way_of_doing_things">The SUPER way of doing things</a></h2>
<p>If <code>Animal</code> is replaced with the special placeholder <code>SUPER</code> in that
invocation, then the contents of <code>Mouse</code>'s <code>@ISA</code> are used for the
search, beginning with <code>$ISA[0]</code>. So, all of the problems can be fixed
as follows:</p>
<pre>
    <span class="comment"># same Animal as before</span>
    <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Mouse</span><span class="operator">;</span>
      <span class="comment"># same @ISA, &amp;sound as before</span>
      <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">SUPER::speak</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"[but you can barely hear it!]\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>In general, <code>SUPER::speak</code> means look in the current package's <code>@ISA</code>
for a class that implements <code>speak</code>, and invoke the first one found.
The placeholder is called <code>SUPER</code>, because many other languages refer
to base classes as &quot;<em>super</em>classes&quot;, and Perl likes to be eclectic.</p>
<p>Note that a call such as</p>
<pre>
    <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">SUPER::method</span><span class="operator">;</span>
</pre>
<p>does <em>not</em> look in the <code>@ISA</code> of <code>$class</code> unless <code>$class</code> happens to
be the current package.</p>
<p>
</p>
<h2><a name="let_s_review___">Let's review...</a></h2>
<p>So far, we've seen the method arrow syntax:</p>
<pre>
  <span class="variable">Class</span><span class="operator">-&gt;</span><span class="variable">method</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>or the equivalent:</p>
<pre>
  <span class="variable">$a</span> <span class="operator">=</span> <span class="string">"Class"</span><span class="operator">;</span>
  <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">method</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>which constructs an argument list of:</p>
<pre>
  (&quot;Class&quot;, @args)</pre>
<p>and attempts to invoke:</p>
<pre>
  <span class="variable">Class::method</span><span class="operator">(</span><span class="string">"Class"</span><span class="operator">,</span> <span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>However, if <code>Class::method</code> is not found, then <code>@Class::ISA</code> is examined
(recursively) to locate a class (a package) that does indeed contain <code>method</code>,
and that subroutine is invoked instead.</p>
<p>Using this simple syntax, we have class methods, (multiple) inheritance,
overriding, and extending. Using just what we've seen so far, we've
been able to factor out common code (though that's never a good reason
for inheritance!), and provide a nice way to reuse implementations with
variations.</p>
<p>Now, what about data?</p>
<p>
</p>
<h2><a name="a_horse_is_a_horse__of_course_of_course__or_is_it">A horse is a horse, of course of course, or is it?</a></h2>
<p>Let's start with the code for the <code>Animal</code> class
and the <code>Horse</code> class:</p>
<pre>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Animal</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>This lets us invoke <code>Horse-&gt;speak</code> to ripple upward to
<code>Animal::speak</code>, calling back to <code>Horse::sound</code> to get the specific
sound, and the output of:</p>
<pre>
  a Horse goes neigh!</pre>
<p>But all of our Horse objects would have to be absolutely identical.
If we add a subroutine, all horses automatically share it. That's
great for making horses the same, but how do we capture the
distinctions of an individual horse?  For example, suppose we want
to give our first horse a name. There's got to be a way to keep its
name separate from the other horses.</p>
<p>That is to say, we want particular instances of <code>Horse</code> to have
different names.</p>
<p>In Perl, any reference can be an &quot;instance&quot;, so let's start with the
simplest reference that can hold a horse's name: a scalar reference.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="string">"Mr. Ed"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="operator">\</span><span class="variable">$name</span><span class="operator">;</span>
</pre>
<p>So, now <code>$horse</code> is a reference to what will be the instance-specific
data (the name). The final step is to turn this reference into a real
instance of a <code>Horse</code> by using the special operator <a href="../../lib/pods/perlfunc.html#bless"><code>bless</code></a>:</p>
<pre>
  <span class="keyword">bless</span> <span class="variable">$horse</span><span class="operator">,</span> <span class="variable">Horse</span><span class="operator">;</span>
</pre>
<p>This operator stores information about the package named <code>Horse</code> into
the thing pointed at by the reference.  At this point, we say
<code>$horse</code> is an instance of <code>Horse</code>.  That is, it's a specific
horse.  The reference is otherwise unchanged, and can still be used
with traditional dereferencing operators.</p>
<p>
</p>
<h2><a name="invoking_an_instance_method">Invoking an instance method</a></h2>
<p>The method arrow can be used on instances, as well as classes (the names
of packages). So, let's get the sound that <code>$horse</code> makes:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$noise</span> <span class="operator">=</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">(</span><span class="string">"some"</span><span class="operator">,</span> <span class="string">"unnecessary"</span><span class="operator">,</span> <span class="string">"args"</span><span class="operator">);</span>
</pre>
<p>To invoke <code>sound</code>, Perl first notes that <code>$horse</code> is a blessed
reference (and thus an instance).  It then constructs an argument
list, as per usual.</p>
<p>Now for the fun part: Perl takes the class in which the instance was
blessed, in this case <code>Horse</code>, and uses that class to locate the
subroutine. In this case, <code>Horse::sound</code> is found directly (without
using inheritance). In the end, it is as though our initial line were
written as follows:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$noise</span> <span class="operator">=</span> <span class="variable">Horse::sound</span><span class="operator">(</span><span class="variable">$horse</span><span class="operator">,</span> <span class="string">"some"</span><span class="operator">,</span> <span class="string">"unnecessary"</span><span class="operator">,</span> <span class="string">"args"</span><span class="operator">);</span>
</pre>
<p>Note that the first parameter here is still the instance, not the name
of the class as before.  We'll get <code>neigh</code> as the return value, and
that'll end up as the <code>$noise</code> variable above.</p>
<p>If Horse::sound had not been found, we'd be wandering up the <code>@Horse::ISA</code>
array, trying to find the method in one of the superclasses. The only
difference between a class method and an instance method is whether the
first parameter is an instance (a blessed reference) or a class name (a
string).</p>
<p>
</p>
<h2><a name="accessing_the_instance_data">Accessing the instance data</a></h2>
<p>Because we get the instance as the first parameter, we can now access
the instance-specific data.  In this case, let's add a way to get at
the name:</p>
<pre>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">$$self</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>Inside <code>Horse::name</code>, the <a href="../../lib/pods/perlvar.html#__"><code>@_</code></a> array contains:</p>
<pre>
    ($horse, &quot;some&quot;, &quot;unnecessary&quot;, &quot;args&quot;)</pre>
<p>so the <a href="../../lib/pods/perlfunc.html#shift"><code>shift</code></a> stores <code>$horse</code> into <code>$self</code>. Then, <code>$self</code> gets
de-referenced with <code>$$self</code> as normal, yielding <code>&quot;Mr. Ed&quot;</code>.</p>
<p>It's traditional to <a href="../../lib/pods/perlfunc.html#shift"><code>shift</code></a> the first parameter into a variable named
<code>$self</code> for instance methods and into a variable named <code>$class</code> for
class methods.</p>
<p>Then, the following line:</p>
<pre>
  <span class="keyword">print</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" says "</span><span class="operator">,</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>outputs:</p>
<pre>
  Mr. Ed says neigh.</pre>
<p>
</p>
<h2><a name="how_to_build_a_horse">How to build a horse</a></h2>
<p>Of course, if we constructed all of our horses by hand, we'd most
likely make mistakes from time to time.  We're also violating one of
the properties of object-oriented programming, in that the &quot;inside
guts&quot; of a Horse are visible.  That's good if you're a veterinarian,
but not if you just like to own horses.  So, let's have the Horse
class handle the details inside a class method:</p>
<pre>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>     <span class="comment"># instance method, so use $self</span>
      <span class="variable">$$self</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>    <span class="comment"># class method, so use $class</span>
      <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">bless</span> <span class="operator">\</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>Now with the new <code>named</code> method, we can build a horse as follows:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Mr. Ed"</span><span class="operator">);</span>
</pre>
<p>Notice we're back to a class method, so the two arguments to
<code>Horse::named</code> are <code>Horse</code> and <code>Mr. Ed</code>.  The <a href="../../lib/pods/perlfunc.html#bless"><code>bless</code></a> operator
not only blesses <code>\$name</code>, it also returns that reference.</p>
<p>This <code>Horse::named</code> method is called a &quot;constructor&quot;.</p>
<p>We've called the constructor <code>named</code> here, so that it quickly denotes
the constructor's argument as the name for this particular <code>Horse</code>.
You can use different constructors with different names for different
ways of &quot;giving birth&quot; to the object (like maybe recording its
pedigree or date of birth).  However, you'll find that most people
coming to Perl from more limited languages use a single constructor
named <code>new</code>, with various ways of interpreting the arguments to
<code>new</code>.  Either style is fine, as long as you document your particular
way of giving birth to an object.  (And you <em>were</em> going to do that,
right?)</p>
<p>
</p>
<h2><a name="inheriting_the_constructor">Inheriting the constructor</a></h2>
<p>But was there anything specific to <code>Horse</code> in that method?  No.  Therefore,
it's also the same recipe for building anything else that inherited from
<code>Animal</code>, so let's put <code>name</code> and <code>named</code> there:</p>
<pre>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Animal</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">"a </span><span class="variable">$class</span><span class="string"> goes "</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"!\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">$$self</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">bless</span> <span class="operator">\</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>Ahh, but what happens if we invoke <code>speak</code> on an instance?</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Mr. Ed"</span><span class="operator">);</span>
  <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">speak</span><span class="operator">;</span>
</pre>
<p>We get a debugging value:</p>
<pre>
  a Horse=SCALAR(0xaca42ac) goes neigh!</pre>
<p>Why?  Because the <code>Animal::speak</code> routine is expecting a classname as
its first parameter, not an instance.  When the instance is passed in,
we'll end up using a blessed scalar reference as a string, and that
shows up as we saw it just now.</p>
<p>
</p>
<h2><a name="making_a_method_work_with_either_classes_or_instances">Making a method work with either classes or instances</a></h2>
<p>All we need is for a method to detect if it is being called on a class
or called on an instance.  The most straightforward way is with the
<a href="../../lib/pods/perlfunc.html#ref"><code>ref</code></a> operator.  This returns a string (the classname) when used on a
blessed reference, and an empty string when used on a string (like a
classname).  Let's modify the <code>name</code> method first to notice the change:</p>
<pre>
  <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">ref</span> <span class="variable">$either</span> <span class="operator">?</span> <span class="variable">$$either</span> <span class="operator">:</span> <span class="string">"Any </span><span class="variable">$either</span><span class="string">"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Here, the <code>?:</code> operator comes in handy to select either the
dereference or a derived string.  Now we can use this with either an
instance or a class.  Note that I've changed the first parameter
holder to <code>$either</code> to show that this is intended:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Mr. Ed"</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span> <span class="comment"># prints "Any Horse\n"</span>
  <span class="keyword">print</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span> <span class="comment"># prints "Mr Ed.\n"</span>
</pre>
<p>and now we'll fix <code>speak</code> to use this:</p>
<pre>
  <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" goes "</span><span class="operator">,</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>And since <code>sound</code> already worked with either a class or an instance,
we're done!</p>
<p>
</p>
<h2><a name="adding_parameters_to_a_method">Adding parameters to a method</a></h2>
<p>Let's train our animals to eat:</p>
<pre>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Animal</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">bless</span> <span class="operator">\</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">ref</span> <span class="variable">$either</span> <span class="operator">?</span> <span class="variable">$$either</span> <span class="operator">:</span> <span class="string">"Any </span><span class="variable">$either</span><span class="string">"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> speak </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" goes "</span><span class="operator">,</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="variable">sound</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> eat </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$food</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" eats </span><span class="variable">$food</span><span class="string">.\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Horse</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"neigh"</span> <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="operator">{</span> <span class="keyword">package</span> <span class="variable">Sheep</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Animal)</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> sound </span><span class="operator">{</span> <span class="string">"baaaah"</span> <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>And now try it out:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Mr. Ed"</span><span class="operator">);</span>
  <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">eat</span><span class="operator">(</span><span class="string">"hay"</span><span class="operator">);</span>
  <span class="variable">Sheep</span><span class="operator">-&gt;</span><span class="variable">eat</span><span class="operator">(</span><span class="string">"grass"</span><span class="operator">);</span>
</pre>
<p>which prints:</p>
<pre>
  Mr. Ed eats hay.
  Any Sheep eats grass.</pre>
<p>An instance method with parameters gets invoked with the instance,
and then the list of parameters.  So that first invocation is like:</p>
<pre>
  <span class="variable">Animal::eat</span><span class="operator">(</span><span class="variable">$horse</span><span class="operator">,</span> <span class="string">"hay"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="more_interesting_instances">More interesting instances</a></h2>
<p>What if an instance needs more data?  Most interesting instances are
made of many items, each of which can in turn be a reference or even
another object.  The easiest way to store these is often in a hash.
The keys of the hash serve as the names of parts of the object (often
called &quot;instance variables&quot; or &quot;member variables&quot;), and the
corresponding values are, well, the values.</p>
<p>But how do we turn the horse into a hash?  Recall that an object was
any blessed reference.  We can just as easily make it a blessed hash
reference as a blessed scalar reference, as long as everything that
looks at the reference is changed accordingly.</p>
<p>Let's make a sheep that has a name and a color:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$bad</span> <span class="operator">=</span> <span class="keyword">bless</span> <span class="operator">{</span> <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">"Evil"</span><span class="operator">,</span> <span class="string">Color</span> <span class="operator">=&gt;</span> <span class="string">"black"</span> <span class="operator">}</span><span class="operator">,</span> <span class="variable">Sheep</span><span class="operator">;</span>
</pre>
<p>so <code>$bad-&gt;{Name}</code> has <code>Evil</code>, and <code>$bad-&gt;{Color}</code> has
<code>black</code>.  But we want to make <code>$bad-&gt;name</code> access the name, and
that's now messed up because it's expecting a scalar reference.  Not
to worry, because that's pretty easy to fix up.</p>
<p>One solution is to override <code>Animal::name</code> and <code>Animal::named</code> by
defining them anew in <code>Sheep</code>, but then any methods added later to
<code>Animal</code> might still mess up, and we'd have to override all of those
too. Therefore, it's never a good idea to define the data layout in a
way that's different from the data layout of the base classes. In fact,
it's a good idea to use blessed hash references in all cases. Also, this
is why it's important to have constructors do the low-level work. So,
let's redefine <code>Animal</code>:</p>
<pre>
  <span class="comment">## in Animal</span>
  <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$either</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">ref</span> <span class="variable">$either</span> <span class="operator">?</span> <span class="variable">$either</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span> <span class="operator">:</span> <span class="string">"Any </span><span class="variable">$either</span><span class="string">"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name</span> <span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Of course, we still need to override <code>named</code> in order to handle
constructing a <code>Sheep</code> with a certain color:</p>
<pre>
  <span class="comment">## in Sheep</span>
  <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$class</span><span class="operator">,</span> <span class="variable">$name</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">SUPER::named</span><span class="operator">(</span><span class="variable">@_</span><span class="operator">);</span>
    <span class="variable">$$self</span><span class="operator">{</span><span class="string">Color</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">default_color</span><span class="operator">;</span>
    <span class="variable">$self</span>
  <span class="operator">}</span>
</pre>
<p>(Note that <a href="../../lib/pods/perlvar.html#__"><code>@_</code></a> contains the parameters to <code>named</code>.)</p>
<p>What's this <code>default_color</code>?  Well, if <code>named</code> has only the name,
we still need to set a color, so we'll have a class-specific default color.
For a sheep, we might define it as white:</p>
<pre>
  <span class="comment">## in Sheep</span>
  <span class="keyword">sub</span><span class="variable"> default_color </span><span class="operator">{</span> <span class="string">"white"</span> <span class="operator">}</span>
</pre>
<p>Now:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$sheep</span> <span class="operator">=</span> <span class="variable">Sheep</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Bad"</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$sheep</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Color</span><span class="operator">}</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>outputs:</p>
<pre>
  white</pre>
<p>Now, there's nothing particularly specific to <code>Sheep</code> when it comes
to color, so let's remove <code>Sheep::named</code> and implement <code>Animal::named</code>
to handle color instead:</p>
<pre>
  <span class="comment">## in Animal</span>
  <span class="keyword">sub</span><span class="variable"> named </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$class</span><span class="operator">,</span> <span class="variable">$name</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name</span><span class="operator">,</span> <span class="string">Color</span> <span class="operator">=&gt;</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">default_color</span> <span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>And then to keep from having to define <code>default_color</code> for each additional
class, we'll define a method that serves as the &quot;default default&quot; directly
in <code>Animal</code>:</p>
<pre>
  <span class="comment">## in Animal</span>
  <span class="keyword">sub</span><span class="variable"> default_color </span><span class="operator">{</span> <span class="string">"brown"</span> <span class="operator">}</span>
</pre>
<p>Of course, because <code>name</code> and <code>named</code> were the only methods that
referenced the &quot;structure&quot; of the object, the rest of the methods can
remain the same, so <code>speak</code> still works as before.</p>
<p>
</p>
<h2><a name="a_horse_of_a_different_color">A horse of a different color</a></h2>
<p>But having all our horses be brown would be boring.  So let's add a
method or two to get and set the color.</p>
<pre>
  <span class="comment">## in Animal</span>
  <span class="keyword">sub</span><span class="variable"> color </span><span class="operator">{</span>
    <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Color</span><span class="operator">}</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> set_color </span><span class="operator">{</span>
    <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Color</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Note the alternate way of accessing the arguments: <code>$_[0]</code> is used
in-place, rather than with a <a href="../../lib/pods/perlfunc.html#shift"><code>shift</code></a>.  (This saves us a bit of time
for something that may be invoked frequently.)  And now we can fix
that color for Mr. Ed:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$horse</span> <span class="operator">=</span> <span class="variable">Horse</span><span class="operator">-&gt;</span><span class="variable">named</span><span class="operator">(</span><span class="string">"Mr. Ed"</span><span class="operator">);</span>
  <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">set_color</span><span class="operator">(</span><span class="string">"black-and-white"</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" is colored "</span><span class="operator">,</span> <span class="variable">$horse</span><span class="operator">-&gt;</span><span class="variable">color</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>which results in:</p>
<pre>
  Mr. Ed is colored black-and-white</pre>
<p>
</p>
<h2><a name="summary">Summary</a></h2>
<p>So, now we have class methods, constructors, instance methods, instance
data, and even accessors. But that's still just the beginning of what
Perl has to offer. We haven't even begun to talk about accessors that
double as getters and setters, destructors, indirect object notation,
overloading, &quot;isa&quot; and &quot;can&quot; tests, the <code>UNIVERSAL</code> class, and so on.
That's for the rest of the Perl documentation to cover. Hopefully, this
gets you started, though.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>For more information, see <a href="../../lib/pods/perlobj.html">the perlobj manpage</a> (for all the gritty details about
Perl objects, now that you've seen the basics), <a href="../../lib/pods/perltoot.html">the perltoot manpage</a> (the
tutorial for those who already know objects), <a href="../../lib/pods/perltooc.html">the perltooc manpage</a> (dealing
with class data), <a href="../../lib/pods/perlbot.html">the perlbot manpage</a> (for some more tricks), and books such as
Damian Conway's excellent <em>Object Oriented Perl</em>.</p>
<p>Some modules which might prove interesting are Class::Accessor,
Class::Class, Class::Contract, Class::Data::Inheritable,
Class::MethodMaker and Tie::SecureHash</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright (c) 1999, 2000 by Randal L. Schwartz and Stonehenge
Consulting Services, Inc.</p>
<p>Copyright (c) 2009 by Michael F. Witten.</p>
<p>Permission is hereby granted to distribute this document intact with
the Perl distribution, and in accordance with the licenses of the Perl
distribution; derived documents must include this copyright notice
intact.</p>
<p>Portions of this text have been derived from Perl Training materials
originally appearing in the <em>Packages, References, Objects, and
Modules</em> course taught by instructors for Stonehenge Consulting
Services, Inc. and used with permission.</p>
<p>Portions of this text have been derived from materials originally
appearing in <em>Linux Magazine</em> and used with permission.</p>

</body>

</html>
