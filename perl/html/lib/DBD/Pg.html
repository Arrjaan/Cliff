<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>DBD::Pg - PostgreSQL database driver for the DBI module</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>DBD::Pg - PostgreSQL database driver for the DBI module</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#module_documentation">MODULE DOCUMENTATION</a></li>
	<li><a href="#the_dbi_class">THE DBI CLASS</a></li>
	<ul>

		<li><a href="#dbi_class_methods">DBI Class Methods</a></li>
		<ul>

			<li><a href="#connect"><strong>connect</strong></a></li>
			<li><a href="#connect_cached"><strong>connect_cached</strong></a></li>
			<li><a href="#data_sources"><strong>data_sources</strong></a></li>
		</ul>

		<li><a href="#methods_common_to_all_handles">Methods Common To All Handles</a></li>
		<ul>

			<li><a href="#err"><strong>err</strong></a></li>
			<li><a href="#errstr"><strong>errstr</strong></a></li>
			<li><a href="#state"><strong>state</strong></a></li>
			<li><a href="#trace"><strong>trace</strong></a></li>
			<li><a href="#trace_msg"><strong>trace_msg</strong></a></li>
			<li><a href="#parse_trace_flag_and_parse_trace_flags"><strong>parse_trace_flag</strong> and <strong>parse_trace_flags</strong></a></li>
			<li><a href="#func"><strong>func</strong></a></li>
			<li><a href="#private_attribute_info"><strong>private_attribute_info</strong></a></li>
		</ul>

	</ul>

	<li><a href="#attributes_common_to_all_handles">ATTRIBUTES COMMON TO ALL HANDLES</a></li>
	<ul>

		<ul>

			<li><a href="#inactivedestroy__boolean_"><strong>InactiveDestroy</strong> (boolean)</a></li>
			<li><a href="#raiseerror__boolean__inherited_"><strong>RaiseError</strong> (boolean, inherited)</a></li>
			<li><a href="#printerror__boolean__inherited_"><strong>PrintError</strong> (boolean, inherited)</a></li>
			<li><a href="#showerrorstatement__boolean__inherited_"><strong>ShowErrorStatement</strong> (boolean, inherited)</a></li>
			<li><a href="#warn__boolean__inherited_"><strong>Warn</strong> (boolean, inherited)</a></li>
			<li><a href="#executed__boolean__read_only_"><strong>Executed</strong> (boolean, read-only)</a></li>
			<li><a href="#tracelevel__integer__inherited_"><strong>TraceLevel</strong> (integer, inherited)</a></li>
			<li><a href="#active__boolean__read_only_"><strong>Active</strong> (boolean, read-only)</a></li>
			<li><a href="#kids__integer__read_only_"><strong>Kids</strong> (integer, read-only)</a></li>
			<li><a href="#activekids__integer__read_only_"><strong>ActiveKids</strong> (integer, read-only)</a></li>
			<li><a href="#cachedkids__hash_ref_"><strong>CachedKids</strong> (hash ref)</a></li>
			<li><a href="#childhandles__array_ref_"><strong>ChildHandles</strong> (array ref)</a></li>
			<li><a href="#printwarn__boolean__inherited_"><strong>PrintWarn</strong> (boolean, inherited)</a></li>
			<li><a href="#handleerror__boolean__inherited_"><strong>HandleError</strong> (boolean, inherited)</a></li>
			<li><a href="#handleseterr__code_ref__inherited_"><strong>HandleSetErr</strong> (code ref, inherited)</a></li>
			<li><a href="#errcount__unsigned_integer_"><strong>ErrCount</strong> (unsigned integer)</a></li>
			<li><a href="#fetchhashkeyname__string__inherited_"><strong>FetchHashKeyName</strong> (string, inherited)</a></li>
			<li><a href="#chopblanks__boolean__inherited_"><strong>ChopBlanks</strong> (boolean, inherited)</a></li>
			<li><a href="#taint__boolean__inherited_"><strong>Taint</strong> (boolean, inherited)</a></li>
			<li><a href="#taintin__boolean__inherited_"><strong>TaintIn</strong> (boolean, inherited)</a></li>
			<li><a href="#taintout__boolean__inherited_"><strong>TaintOut</strong> (boolean, inherited)</a></li>
			<li><a href="#profile__inherited_"><strong>Profile</strong> (inherited)</a></li>
			<li><a href="#type__scalar_"><strong>Type</strong> (scalar)</a></li>
			<li><a href="#longreadlen"><strong>LongReadLen</strong></a></li>
			<li><a href="#longtruncok"><strong>LongTruncOk</strong></a></li>
			<li><a href="#compatmode"><strong>CompatMode</strong></a></li>
		</ul>

	</ul>

	<li><a href="#dbi_database_handle_objects">DBI DATABASE HANDLE OBJECTS</a></li>
	<ul>

		<li><a href="#database_handle_methods">Database Handle Methods</a></li>
		<ul>

			<li><a href="#selectall_arrayref"><strong>selectall_arrayref</strong></a></li>
			<li><a href="#selectall_hashref"><strong>selectall_hashref</strong></a></li>
			<li><a href="#selectcol_arrayref"><strong>selectcol_arrayref</strong></a></li>
			<li><a href="#prepare"><strong>prepare</strong></a></li>
			<ul>

				<li><a href="#placeholders"><strong>Placeholders</strong></a></li>
			</ul>

			<li><a href="#prepare_cached"><strong>prepare_cached</strong></a></li>
			<li><a href="#do"><strong>do</strong></a></li>
			<li><a href="#last_insert_id"><strong>last_insert_id</strong></a></li>
			<li><a href="#commit"><strong>commit</strong></a></li>
			<li><a href="#rollback"><strong>rollback</strong></a></li>
			<li><a href="#begin_work"><strong>begin_work</strong></a></li>
			<li><a href="#disconnect"><strong>disconnect</strong></a></li>
			<li><a href="#quote"><strong>quote</strong></a></li>
			<li><a href="#quote_identifier"><strong>quote_identifier</strong></a></li>
			<li><a href="#pg_notifies"><strong>pg_notifies</strong></a></li>
			<li><a href="#ping"><strong>ping</strong></a></li>
			<li><a href="#pg_ping"><strong>pg_ping</strong></a></li>
			<li><a href="#get_info"><strong>get_info</strong></a></li>
			<li><a href="#table_info"><strong>table_info</strong></a></li>
			<li><a href="#column_info"><strong>column_info</strong></a></li>
			<li><a href="#primary_key_info"><strong>primary_key_info</strong></a></li>
			<li><a href="#primary_key"><strong>primary_key</strong></a></li>
			<li><a href="#foreign_key_info"><strong>foreign_key_info</strong></a></li>
			<li><a href="#statistics_info"><strong>statistics_info</strong></a></li>
			<li><a href="#tables"><strong>tables</strong></a></li>
			<li><a href="#type_info_all"><strong>type_info_all</strong></a></li>
			<li><a href="#type_info"><strong>type_info</strong></a></li>
			<li><a href="#pg_server_trace"><strong>pg_server_trace</strong></a></li>
			<li><a href="#pg_server_untrace"><strong>pg_server_untrace</strong></a></li>
			<li><a href="#selectrow_array"><strong>selectrow_array</strong></a></li>
			<li><a href="#selectrow_arrayref"><strong>selectrow_arrayref</strong></a></li>
			<li><a href="#selectrow_hashref"><strong>selectrow_hashref</strong></a></li>
			<li><a href="#clone"><strong>clone</strong></a></li>
		</ul>

		<li><a href="#database_handle_attributes">Database Handle Attributes</a></li>
		<ul>

			<li><a href="#autocommit__boolean_"><strong>AutoCommit</strong> (boolean)</a></li>
			<li><a href="#pg_bool_tf__boolean_"><strong>pg_bool_tf</strong> (boolean)</a></li>
			<li><a href="#readonly__boolean_"><strong>ReadOnly</strong> (boolean)</a></li>
			<li><a href="#pg_server_prepare__integer_"><strong>pg_server_prepare</strong> (integer)</a></li>
			<li><a href="#pg_placeholder_dollaronly__boolean_"><strong>pg_placeholder_dollaronly</strong> (boolean)</a></li>
			<li><a href="#pg_enable_utf8__boolean_"><strong>pg_enable_utf8</strong> (boolean)</a></li>
			<li><a href="#pg_errorlevel__integer_"><strong>pg_errorlevel</strong> (integer)</a></li>
			<li><a href="#pg_lib_version__integer__read_only_"><strong>pg_lib_version</strong> (integer, read-only)</a></li>
			<li><a href="#pg_server_version__integer__read_only_"><strong>pg_server_version</strong> (integer, read-only)</a></li>
			<li><a href="#name__string__read_only_"><strong>Name</strong> (string, read-only)</a></li>
			<li><a href="#username__string__read_only_"><strong>Username</strong> (string, read-only)</a></li>
			<li><a href="#pg_db__string__read_only_"><strong>pg_db</strong> (string, read-only)</a></li>
			<li><a href="#pg_user__string__read_only_"><strong>pg_user</strong> (string, read-only)</a></li>
			<li><a href="#pg_host__string__read_only_"><strong>pg_host</strong> (string, read-only)</a></li>
			<li><a href="#pg_port__integer__read_only_"><strong>pg_port</strong> (integer, read-only)</a></li>
			<li><a href="#pg_socket__integer__read_only_"><strong>pg_socket</strong> (integer, read-only)</a></li>
			<li><a href="#pg_pass__string__read_only_"><strong>pg_pass</strong> (string, read-only)</a></li>
			<li><a href="#pg_options__string__read_only_"><strong>pg_options</strong> (string, read-only)</a></li>
			<li><a href="#pg_default_port__integer__read_only_"><strong>pg_default_port</strong> (integer, read-only)</a></li>
			<li><a href="#pg_pid__integer__read_only_"><strong>pg_pid</strong> (integer, read-only)</a></li>
			<li><a href="#pg_prepare_now__boolean_"><strong>pg_prepare_now</strong> (boolean)</a></li>
			<li><a href="#pg_expand_array__boolean_"><strong>pg_expand_array</strong> (boolean)</a></li>
			<li><a href="#pg_async_status__integer__read_only_"><strong>pg_async_status</strong> (integer, read-only)</a></li>
			<li><a href="#pg_standard_conforming_strings__boolean__read_only_"><strong>pg_standard_conforming_strings</strong> (boolean, read-only)</a></li>
			<li><a href="#pg_inv_read__integer__read_only_"><strong>pg_INV_READ</strong> (integer, read-only)</a></li>
			<li><a href="#pg_inv_write__integer__read_only_"><strong>pg_INV_WRITE</strong> (integer, read-only)</a></li>
			<li><a href="#driver__handle__read_only_"><strong>Driver</strong> (handle, read-only)</a></li>
			<li><a href="#pg_protocol__integer__read_only_"><strong>pg_protocol</strong> (integer, read-only)</a></li>
			<li><a href="#rowcachesize"><strong>RowCacheSize</strong></a></li>
		</ul>

	</ul>

	<li><a href="#dbi_statement_handle_objects">DBI STATEMENT HANDLE OBJECTS</a></li>
	<ul>

		<li><a href="#statement_handle_methods">Statement Handle Methods</a></li>
		<ul>

			<li><a href="#bind_param"><strong>bind_param</strong></a></li>
			<li><a href="#bind_param_inout"><strong>bind_param_inout</strong></a></li>
			<li><a href="#bind_param_array"><strong>bind_param_array</strong></a></li>
			<li><a href="#execute"><strong>execute</strong></a></li>
			<li><a href="#execute_array"><strong>execute_array</strong></a></li>
			<li><a href="#execute_for_fetch"><strong>execute_for_fetch</strong></a></li>
			<li><a href="#fetchrow_arrayref"><strong>fetchrow_arrayref</strong></a></li>
			<li><a href="#fetchrow_array"><strong>fetchrow_array</strong></a></li>
			<li><a href="#fetchrow_hashref"><strong>fetchrow_hashref</strong></a></li>
			<li><a href="#fetchall_arrayref"><strong>fetchall_arrayref</strong></a></li>
			<li><a href="#fetchall_hashref"><strong>fetchall_hashref</strong></a></li>
			<li><a href="#finish"><strong>finish</strong></a></li>
			<li><a href="#rows"><strong>rows</strong></a></li>
			<li><a href="#bind_col"><strong>bind_col</strong></a></li>
			<li><a href="#bind_columns"><strong>bind_columns</strong></a></li>
			<li><a href="#dump_results"><strong>dump_results</strong></a></li>
			<li><a href="#blob_read"><strong>blob_read</strong></a></li>
		</ul>

		<li><a href="#statement_handle_attributes">Statement Handle Attributes</a></li>
		<ul>

			<li><a href="#num_of_fields__integer__read_only_"><strong>NUM_OF_FIELDS</strong> (integer, read-only)</a></li>
			<li><a href="#num_of_params__integer__read_only_"><strong>NUM_OF_PARAMS</strong> (integer, read-only)</a></li>
			<li><a href="#name__arrayref__read_only_"><strong>NAME</strong> (arrayref, read-only)</a></li>
			<li><a href="#name_lc__arrayref__read_only_"><strong>NAME_lc</strong> (arrayref, read-only)</a></li>
			<li><a href="#name_uc__arrayref__read_only_"><strong>NAME_uc</strong>  (arrayref, read-only)</a></li>
			<li><a href="#name_hash__hashref__read_only_"><strong>NAME_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#name_lc_hash__hashref__read_only_"><strong>NAME_lc_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#name_uc_hash__hashref__read_only_"><strong>NAME_uc_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#type__arrayref__read_only_"><strong>TYPE</strong> (arrayref, read-only)</a></li>
			<li><a href="#precision__arrayref__read_only_"><strong>PRECISION</strong> (arrayref, read-only)</a></li>
			<li><a href="#scale__arrayref__read_only_"><strong>SCALE</strong> (arrayref, read-only)</a></li>
			<li><a href="#nullable__arrayref__read_only_"><strong>NULLABLE</strong> (arrayref, read-only)</a></li>
			<li><a href="#database__dbh__read_only_"><strong>Database</strong> (dbh, read-only)</a></li>
			<li><a href="#paramvalues__hash_ref__read_only_"><strong>ParamValues</strong> (hash ref, read-only)</a></li>
			<li><a href="#paramtypes__hash_ref__read_only_"><strong>ParamTypes</strong> (hash ref, read-only)</a></li>
			<li><a href="#statement__string__read_only_"><strong>Statement</strong> (string, read-only)</a></li>
			<li><a href="#pg_current_row__integer__read_only_"><strong>pg_current_row</strong> (integer, read-only)</a></li>
			<li><a href="#pg_numbound__integer__read_only_"><strong>pg_numbound</strong> (integer, read-only)</a></li>
			<li><a href="#pg_bound__hashref__read_only_"><strong>pg_bound</strong> (hashref, read-only)</a></li>
			<li><a href="#pg_size__arrayref__read_only_"><strong>pg_size</strong> (arrayref, read-only)</a></li>
			<li><a href="#pg_type__arrayref__read_only_"><strong>pg_type</strong> (arrayref, read-only)</a></li>
			<li><a href="#pg_segments__arrayref__read_only_"><strong>pg_segments</strong> (arrayref, read-only)</a></li>
			<li><a href="#pg_oid_status__integer__read_only_"><strong>pg_oid_status</strong> (integer, read-only)</a></li>
			<li><a href="#pg_cmd_status__integer__read_only_"><strong>pg_cmd_status</strong> (integer, read-only)</a></li>
			<li><a href="#pg_direct__boolean_"><strong>pg_direct</strong> (boolean)</a></li>
			<li><a href="#pg_prepare_now__boolean_"><strong>pg_prepare_now</strong> (boolean)</a></li>
			<li><a href="#pg_prepare_name__string_"><strong>pg_prepare_name</strong> (string)</a></li>
			<li><a href="#pg_server_prepare__integer_"><strong>pg_server_prepare</strong> (integer)</a></li>
			<li><a href="#pg_placeholder_dollaronly__boolean_"><strong>pg_placeholder_dollaronly</strong> (boolean)</a></li>
			<li><a href="#pg_async__integer_"><strong>pg_async</strong> (integer)</a></li>
			<li><a href="#rowsincache"><strong>RowsInCache</strong></a></li>
			<li><a href="#rowcache"><strong>RowCache</strong></a></li>
			<li><a href="#cursorname"><strong>CursorName</strong></a></li>
		</ul>

	</ul>

	<li><a href="#further_information">FURTHER INFORMATION</a></li>
	<ul>

		<li><a href="#transactions">Transactions</a></li>
		<li><a href="#savepoints">Savepoints</a></li>
		<ul>

			<li><a href="#pg_savepoint"><code>pg_savepoint</code></a></li>
			<li><a href="#pg_rollback_to"><code>pg_rollback_to</code></a></li>
			<li><a href="#pg_release"><code>pg_release</code></a></li>
		</ul>

		<li><a href="#asynchronous_queries">Asynchronous Queries</a></li>
		<ul>

			<li><a href="#asynchronous_constants">Asynchronous Constants</a></li>
			<li><a href="#asynchronous_methods">Asynchronous Methods</a></li>
			<li><a href="#asynchronous_examples">Asynchronous Examples</a></li>
		</ul>

		<li><a href="#array_support">Array support</a></li>
		<li><a href="#copy_support">COPY support</a></li>
		<ul>

			<li><a href="#pg_getcopydata"><strong>pg_getcopydata</strong></a></li>
			<li><a href="#pg_putcopydata"><strong>pg_putcopydata</strong></a></li>
			<li><a href="#pg_putcopyend"><strong>pg_putcopyend</strong></a></li>
		</ul>

		<li><a href="#large_objects">Large Objects</a></li>
		<li><a href="#cursors">Cursors</a></li>
		<li><a href="#datatype_bool">Datatype bool</a></li>
		<li><a href="#schema_support">Schema support</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#authors">AUTHORS</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>DBD::Pg - PostgreSQL database driver for the DBI module</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
  <span class="comment"># The AutoCommit attribute should always be explicitly set</span>
</pre>
<pre>
  <span class="comment"># For some advanced uses you may need PostgreSQL type values:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># For asynchronous calls, import the async constants:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:async)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'INSERT INTO mytable(a) VALUES (1)'</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'INSERT INTO mytable(a) VALUES (?)'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>This documents version 2.18.1 of the DBD::Pg module</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>DBD::Pg is a Perl module that works with the DBI module to provide access to
PostgreSQL databases.</p>
<p>
</p>
<hr />
<h1><a name="module_documentation">MODULE DOCUMENTATION</a></h1>
<p>This documentation describes driver specific behavior and restrictions. It is
not supposed to be used as the only reference for the user. In any case
consult the <strong>DBI</strong> documentation first!</p>
<a href="http://search.cpan.org/~timb/DBI/DBI.pm">Latest DBI docmentation.</a><p>
</p>
<hr />
<h1><a name="the_dbi_class">THE DBI CLASS</a></h1>
<p>
</p>
<h2><a name="dbi_class_methods">DBI Class Methods</a></h2>
<p>
</p>
<h3><a name="connect"><strong>connect</strong></a></h3>
<p>This method creates a database handle by connecting to a database, and is the DBI 
equivalent of the &quot;new&quot; method. To connect to a Postgres database with a minimum of parameters, 
use the following syntax:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>This connects to the database named in the <code>$dbname</code> variable on the default port (usually 5432) 
without any user authentication.</p>
<p>The following connect statement shows almost all possible parameters:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">;host=</span><span class="variable">$host</span><span class="string">;port=</span><span class="variable">$port</span><span class="string">;options=</span><span class="variable">$options</span><span class="string">"</span><span class="operator">,</span>
                      <span class="variable">$username</span><span class="operator">,</span>
                      <span class="variable">$password</span><span class="operator">,</span>
                      <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">PrintError</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span>
                     <span class="operator">);</span>
</pre>
<p>If a parameter is not given, the <a href="../../lib/pods/perlfunc.html#connect"><code>connect()</code></a> method will first look for 
specific environment variables, and then fall back to hard-coded defaults:</p>
<pre>
  parameter    environment variable    hard coded default
  ------------------------------------------------------
  host         PGHOST                  local domain socket
  hostaddr     PGHOSTADDR              local domain socket
  port         PGPORT                  5432
  dbname*      PGDATABASE              current userid
  username     PGUSER                  current userid
  password     PGPASSWORD              (none)
  options      PGOPTIONS               (none)
  service      PGSERVICE               (none)
  sslmode      PGSSLMODE               (none)</pre>
<p>* May also use the aliases <code>db</code> or <code>database</code></p>
<p>If the username and password values passed via <a href="../../lib/pods/perlfunc.html#connect"><code>connect()</code></a> are undefined (as opposed 
to merely being empty strings), DBI will use the environment variables <em>DBI_USER</em> 
and <em>DBI_PASS</em> if they exist.</p>
<p>You can also connect by using a service connection file, which is named 
<em class="file">pg_service.conf</em>. The location of this file can be controlled by 
setting the <em>PGSYSCONFDIR</em> environment variable. To use one of the named 
services within the file, set the name by using either the <em>service</em> parameter 
or the environment variable <em>PGSERVICE</em>. Note that when connecting this way, 
only the minimum parameters should be used. For example, to connect to a 
service named &quot;zephyr&quot;, you could use:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:service=zephyr"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
</pre>
<p>You could also set <code>$ENV{PGSERVICE}</code> to &quot;zephyr&quot; and connect like this:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
</pre>
<p>The format of the <em class="file">pg_service.conf</em> file is simply a bracketed service 
name, followed by one parameter per line in the format name=value.
For example:</p>
<pre>
  [zephyr]
  dbname=winds
  user=wisp
  password=W$2Hc00YSgP
  port=6543</pre>
<p>There are four valid arguments to the <em>sslmode</em> parameter, which controls 
whether to use SSL to connect to the database:</p>
<ul>
<li><strong><a name="disable_ssl_connections_are_never_used" class="item">disable: SSL connections are never used</a></strong>

</li>
<li><strong><a name="allow_try_non_ssl_then_ssl" class="item">allow: try non-SSL, then SSL</a></strong>

</li>
<li><strong><a name="prefer_try_ssl_then_non_ssl" class="item">prefer: try SSL, then non-SSL</a></strong>

</li>
<li><strong><a name="require_connect_only_with_ssl" class="item">require: connect only with SSL</a></strong>

</li>
</ul>
<p>You can also connect using sockets in a specific directory. This 
may be needed if the server you are connecting to has a different 
default socket directory from the one used to compile DBD::Pg. 
Use the complete path to the socket directory as the name of the 
host, like this:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=foo;host=/var/tmp/socket'</span><span class="operator">,</span>
    <span class="variable">$username</span><span class="operator">,</span>
    <span class="variable">$password</span><span class="operator">,</span>
    <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>The attribute hash can also contain a key named <code>dbd_verbose</code>, which 
simply calls <code>$dbh-&gt;trace('DBD')</code> after the handle is created. This attribute 
is not recommended, as it is clearer to simply explicitly call <code>trace</code> explicitly 
in your script.</p>
<p>
</p>
<h3><a name="connect_cached"><strong>connect_cached</strong></a></h3>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect_cached</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$username</span><span class="operator">,</span> <span class="variable">$password</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%options</span><span class="operator">);</span>
</pre>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="data_sources"><strong>data_sources</strong></a></h3>
<pre>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'Pg'</span><span class="operator">);</span>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">();</span>
</pre>
<p>Returns a list of available databases. Unless the environment variable <code>DBI_DSN</code> is set, 
a connection will be attempted to the database <code>template1</code>. The normal connection 
environment variables also apply, such as <code>PGHOST</code>, <code>PGPORT</code>, <code>DBI_USER</code>, 
<code>DBI_PASS</code>, and <code>PGSERVICE</code>.</p>
<p>You can also pass in options to add to the connection string For example, to specify 
an alternate port and host:</p>
<pre>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'Pg'</span><span class="operator">,</span> <span class="string">'port=5824;host=example.com'</span><span class="operator">);</span>
</pre>
<pre>
  or:</pre>
<pre>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'port=5824;host=example.com'</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="methods_common_to_all_handles">Methods Common To All Handles</a></h2>
<p>For all of the methods below, <strong>$h</strong> can be either a database handle (<strong>$dbh</strong>) 
or a statement handle (<strong>$sth</strong>). Note that <em>$dbh</em> and <em>$sth</em> can be replaced with 
any variable name you choose: these are just the names most often used. Another 
common variable used in this documentation is $<em>rv</em>, which stands for &quot;return value&quot;.</p>
<p>
</p>
<h3><a name="err"><strong>err</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">err</span><span class="operator">;</span>
</pre>
<p>Returns the error code from the last method called. For the connect method it returns
<code>PQstatus</code>, which is a number used by <em>libpq</em> (the Postgres connection library). A value of 0 
indicates no error (CONNECTION_OK), while any other number indicates a failed connection. The 
only other number commonly seen is 1 (CONNECTION_BAD). See the libpq documentation for the 
complete list of return codes.</p>
<p>In all other non-connect methods <code>$h-&gt;err</code> returns the <code>PQresultStatus</code> of the current
handle. This is a number used by libpq and is one of:</p>
<pre>
  0  Empty query string
  1  A command that returns no data successfully completed.
  2  A command that returns data sucessfully completed.
  3  A COPY OUT command is still in progress.
  4  A COPY IN command is still in progress.
  5  A bad response was received from the backend.
  6  A nonfatal error occurred (a notice or warning message)
  7  A fatal error was returned: the last query failed.</pre>
<p>
</p>
<h3><a name="errstr"><strong>errstr</strong></a></h3>
<pre>
  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<p>Returns the last error that was reported by Postgres. This message is affected 
by the <a href="#pg_errorlevel">pg_errorlevel</a> setting.</p>
<p>
</p>
<h3><a name="state"><strong>state</strong></a></h3>
<pre>
  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">state</span><span class="operator">;</span>
</pre>
<p>Returns a five-character &quot;SQLSTATE&quot; code. Success is indicated by a <code>00000</code> code, which 
gets mapped to an empty string by DBI. A code of <code>S8006</code> indicates a connection failure, 
usually because the connection to the Postgres server has been lost.</p>
<p>While this method can be called as either <a href="../../lib/pods/perlfunc.html#state"><code>$sth-&gt;state</code></a> or <a href="../../lib/pods/perlfunc.html#state"><code>$dbh-&gt;state</code></a>, it 
is usually clearer to always use <a href="../../lib/pods/perlfunc.html#state"><code>$dbh-&gt;state</code></a>.</p>
<p>The list of codes used by PostgreSQL can be found at:
<a href="http://www.postgresql.org/docs/current/static/errcodes-appendix.html">http://www.postgresql.org/docs/current/static/errcodes-appendix.html</a></p>
<p>Note that these codes are part of the SQL standard and only a small number 
of them will be used by PostgreSQL.</p>
<p>Common codes:</p>
<pre>
  00000 Successful completion
  25P01 No active SQL transaction
  25P02 In failed SQL transaction
  S8006 Connection failure</pre>
<p>
</p>
<h3><a name="trace"><strong>trace</strong></a></h3>
<pre>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$trace_settings</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$trace_settings</span><span class="operator">,</span> <span class="variable">$trace_filename</span><span class="operator">);</span>
  <span class="variable">$trace_settings</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">;</span>
</pre>
<p>Changes the trace settings on a database or statement handle. 
The optional second argument specifies a file to write the 
trace information to. If no filename is given, the information 
is written to <em class="file">STDERR</em>. Note that tracing can be set globally as 
well by setting <code>DBI-&gt;trace</code>, or by using the environment 
variable <em>DBI_TRACE</em>.</p>
<p>The value is either a numeric level or a named flag. For the 
flags that DBD::Pg uses, see <a href="#parse_trace_flag_and_parse_trace_flags">parse_trace_flag</a>.</p>
<p>
</p>
<h3><a name="trace_msg"><strong>trace_msg</strong></a></h3>
<pre>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace_msg</span><span class="operator">(</span><span class="variable">$message_text</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace_msg</span><span class="operator">(</span><span class="variable">$message_text</span><span class="operator">,</span> <span class="variable">$min_level</span><span class="operator">);</span>
</pre>
<p>Writes a message to the current trace output (as set by the <a href="#trace">trace</a> method). If a second argument 
is given, the message is only written if the current tracing level is equal to or greater than 
the <code>$min_level</code>.</p>
<p>
</p>
<h3><a name="parse_trace_flag_and_parse_trace_flags"><strong>parse_trace_flag</strong> and <strong>parse_trace_flags</strong></a></h3>
<pre>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'SQL|pglibpq'</span><span class="operator">));</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'1|pgstart'</span><span class="operator">));</span>
</pre>
<pre>
  <span class="comment">## Simpler:</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="string">'SQL|pglibpq'</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="string">'1|pgstart'</span><span class="operator">);</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">DBD::Pg</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flag</span><span class="operator">(</span><span class="string">'pglibpq'</span><span class="operator">);</span>
  <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">);</span>
</pre>
<p>The parse_trace_flags method is used to convert one or more named 
flags to a number which can passed to the <a href="#trace">trace</a> method.
DBD::Pg currently supports the DBI-specific flag, <a href="#sql"><code>SQL</code></a>, 
as well as the ones listed below.</p>
<p>Flags can be combined by using the parse_trace_flags method, 
which simply calls <code>parse_trace_flag</code> on each item and 
combines them.</p>
<p>Sometimes you may wish to turn the tracing on before you connect 
to the database. The second example above shows a way of doing this: 
the call to <code>DBD::Pg-&gt;parse_trace_flags</code> provides a number than can 
be fed to <code>DBI-&gt;trace</code> before you create a database handle.</p>
<p>DBD::Pg supports the following trace flags:</p>
<dl>
<dt><strong><a name="sql2" class="item">SQL</a></strong></dt>

<dd>
<p>Outputs all SQL statements. Note that the output provided will not 
necessarily be in a form suitable to passing directly to Postgres, 
as server-side prepared statements are used extensively by DBD::Pg.
For maximum portability of output (but with a potential performance 
hit), use with <code>$dbh-&gt;{pg_server_prepare} = 0</code>.</p>
</dd>
<dt><strong><a name="dbd" class="item">DBD</a></strong></dt>

<dd>
<p>Turns on all non-DBI flags, in other words, only the ones that are specific 
to DBD::Pg (all those below which start with the letters 'pg').</p>
</dd>
<dt><strong><a name="pglibpq" class="item">pglibpq</a></strong></dt>

<dd>
<p>Outputs the name of each libpq function (without arguments) immediately 
before running it. This is a good way to trace the flow of your program 
at a low level. This information is also output if the trace level 
is set to 4 or greater.</p>
</dd>
<dt><strong><a name="pgstart" class="item">pgstart</a></strong></dt>

<dd>
<p>Outputs the name of each internal DBD::Pg function, and other information such as 
the function arguments or important global variables, as each function starts. This 
information is also output if the trace level is set to 4 or greater.</p>
</dd>
<dt><strong><a name="pgend" class="item">pgend</a></strong></dt>

<dd>
<p>Outputs a simple message at the very end of each internal DBD::Pg function. This is also 
output if the trace level is set to 4 or greater.</p>
</dd>
<dt><strong><a name="pgprefix" class="item">pgprefix</a></strong></dt>

<dd>
<p>Forces each line of trace output to begin with the string <strong><code>dbdpg: </code></strong>. This helps to 
differentiate it from the normal DBI trace output.</p>
</dd>
<dt><strong><a name="pglogin" class="item">pglogin</a></strong></dt>

<dd>
<p>Outputs a message showing the connection string right before a new database connection 
is attempted, a message when the connection was successful, and a message right after 
the database has been disconnected. Also output if trace level is 5 or greater.</p>
</dd>
</dl>
See the <a href="http://search.cpan.org/~timb/DBI/DBI.pm#TRACING">DBI section on TRACING</a> for more information.<br /><p>
</p>
<h3><a name="func"><strong>func</strong></a></h3>
<p>DBD::Pg uses the <code>func</code> method to support a variety of functions. 
Note that the name of the function comes <em>last</em>, after the arguments.</p>
<dl>
<dt><strong><a name="table_attributes" class="item">table_attributes</a></strong></dt>

<dd>
<pre>
  <span class="variable">$attrs</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$table</span><span class="operator">,</span> <span class="string">'table_attributes'</span><span class="operator">);</span>
</pre>
<p>Use of the tables_attributes function is no longer recommended. Instead,
you can use the more portable <code>column_info</code> and <code>primary_key</code> methods
to access the same information.</p>
<p>The table_attributes method returns, for the given table argument, a
reference to an array of hashes, each of which contains the following keys:</p>
<pre>
  NAME        attribute name
  TYPE        attribute type
  SIZE        attribute size (-1 for variable size)
  NULLABLE    flag nullable
  DEFAULT     default value
  CONSTRAINT  constraint
  PRIMARY_KEY flag is_primary_key
  REMARKS     attribute description</pre>
</dd>
<dt><strong><a name="pg_lo_creat" class="item">pg_lo_creat</a></strong></dt>

<dd>
<pre>
  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_creat</span><span class="operator">(</span><span class="variable">$mode</span><span class="operator">);</span>
</pre>
<p>Creates a new large object and returns the object-id. <code>$mode</code> is a bitmask
describing read and write access to the new object. This setting is ignored
since Postgres version 8.1. For backwards compatibility, however, you should 
set a valid mode anyway (see <a href="#pg_lo_open">pg_lo_open</a> for a list of valid modes).</p>
<p>Upon failure it returns <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a>. This function cannot be used if AutoCommit is enabled.</p>
<p>The old way of calling large objects functions is deprecated: $dbh-&gt;func(.., 'lo_);</p>
</dd>
<dt><strong><a name="lo_open" class="item">lo_open</a></strong></dt>

<dd>
<pre>
  <span class="variable">$lobj_fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_open</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">,</span> <span class="variable">$mode</span><span class="operator">);</span>
</pre>
<p>Opens an existing large object and returns an object-descriptor for use in
subsequent <code>lo_*</code> calls. <code>$mode</code> is a bitmask describing read and write
access to the opened object. It may be one of:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_READ</span><span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_WRITE</span><span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_READ</span><span class="operator">}</span> <span class="operator">|</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_WRITE</span><span class="operator">}</span>
</pre>
<p><code>pg_INV_WRITE</code> and <code>pg_INV_WRITE | pg_INV_READ</code> modes are identical; in
both modes, the large object can be read from or written to.
Reading from the object will provide the object as written in other committed
transactions, along with any writes performed by the current transaction.
Objects opened with <code>pg_INV_READ</code> cannot be written to. Reading from this
object will provide the stored data at the time of the transaction snapshot
which was active when <a href="#lo_write"><code>lo_write</code></a> was called.</p>
<p>Returns <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure. Note that 0 is a perfectly correct (and common)
object descriptor! This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_write" class="item">lo_write</a></strong></dt>

<dd>
<pre>
  <span class="variable">$nbytes</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_write</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</pre>
<p>Writes <code>$len</code> bytes of c&lt;$buffer&gt; into the large object <code>$lobj_fd</code>. Returns the number
of bytes written and <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure. This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_read" class="item">lo_read</a></strong></dt>

<dd>
<pre>
  <span class="variable">$nbytes</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_read</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</pre>
<p>Reads <code>$len</code> bytes into c&lt;$buffer&gt; from large object <code>$lobj_fd</code>. Returns the number of
bytes read and <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure. This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_lseek" class="item">lo_lseek</a></strong></dt>

<dd>
<pre>
  <span class="variable">$loc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_lseek</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$whence</span><span class="operator">);</span>
</pre>
<p>Changes the current read or write location on the large object
<code>$obj_id</code>. Currently <code>$whence</code> can only be 0 (which is L_SET). Returns the current
location and <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure. This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_tell" class="item">lo_tell</a></strong></dt>

<dd>
<pre>
  <span class="variable">$loc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_tell</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">);</span>
</pre>
<p>Returns the current read or write location on the large object <code>$lobj_fd</code> and <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure.
This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_close" class="item">lo_close</a></strong></dt>

<dd>
<pre>
  <span class="variable">$lobj_fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_close</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">);</span>
</pre>
<p>Closes an existing large object. Returns true upon success and false upon failure.
This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_unlink" class="item">lo_unlink</a></strong></dt>

<dd>
<pre>
  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_unlink</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">);</span>
</pre>
<p>Deletes an existing large object. Returns true upon success and false upon failure.
This function cannot be used if AutoCommit is enabled.</p>
</dd>
<dt><strong><a name="lo_import" class="item">lo_import</a></strong></dt>

<dd>
<pre>
  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_import</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span>
</pre>
<p>Imports a Unix file as a large object and returns the object id of the new
object or <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> upon failure.</p>
</dd>
<dt><strong><a name="lo_import_with_oid" class="item">lo_import_with_oid</a></strong></dt>

<dd>
<pre>
  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_import</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">,</span> <span class="variable">$OID</span><span class="operator">);</span>
</pre>
<p>Same as lo_import, but attempts to use the supplied OID as the 
large object number. If this number is 0, it falls back to the 
behavior of lo_import (which assigns the next available OID).</p>
<p>This is only available when DBD::Pg is compiled against a Postgres 
server version 8.4 or later.</p>
</dd>
<dt><strong><a name="lo_export" class="item">lo_export</a></strong></dt>

<dd>
<pre>
  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_export</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">,</span> <span class="variable">$filename</span><span class="operator">);</span>
</pre>
<p>Exports a large object into a Unix file. Returns false upon failure, true otherwise.</p>
</dd>
<dt><strong><a name="getfd" class="item">getfd</a></strong></dt>

<dd>
<pre>
  <span class="variable">$fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="string">'getfd'</span><span class="operator">);</span>
</pre>
<p>Deprecated, use <a href="#pg_socket">$dbh-</a>{pg_socket}&gt; instead.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="private_attribute_info"><strong>private_attribute_info</strong></a></h3>
<pre>
  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
</pre>
<p>Returns a hash of all private attributes used by DBD::Pg, for either 
a database or a statement handle. Currently, all the hash values are undef.</p>
<p>
</p>
<hr />
<h1><a name="attributes_common_to_all_handles">ATTRIBUTES COMMON TO ALL HANDLES</a></h1>
<p>
</p>
<h3><a name="inactivedestroy__boolean_"><strong>InactiveDestroy</strong> (boolean)</a></h3>
<p>If set to true, then the <a href="#disconnect">disconnect</a> method will not be automatically called when 
the database handle goes out of scope. This is required if you are forking, and even 
then you must tread carefully and ensure that either the parent or the child (but not 
both!) handles all database calls from that point forwards, so that messages from the 
Postgres backend are only handled by one of the processes. If you don't set things up 
properly, you will see messages such as &quot;<em>server closed the connection unexpectedly</em>&quot;, 
and &quot;<em>message type 0x32 arrived from server while idle</em>&quot;. The best solution is to either 
have the child process reconnect to the database with a fresh database handle, or to 
rewrite your application not to use use forking. See the section on <a href="#asynchronous_queries">Asynchronous Queries</a> 
for a way to have your script continue to work while the database is processing a request.</p>
<p>
</p>
<h3><a name="raiseerror__boolean__inherited_"><strong>RaiseError</strong> (boolean, inherited)</a></h3>
<p>Forces errors to always raise an exception. Although it defaults to off, it is recommended that this 
be turned on, as the alternative is to check the return value of every method (prepare, execute, fetch, etc.) 
manually, which is easy to forget to do.</p>
<p>
</p>
<h3><a name="printerror__boolean__inherited_"><strong>PrintError</strong> (boolean, inherited)</a></h3>
<p>Forces database errors to also generate warnings, which can then be filtered with methods such as 
locally redefining <em>$SIG{__WARN__}</em> or using modules such as <code>CGI::Carp</code>. This attribute is on 
by default.</p>
<p>
</p>
<h3><a name="showerrorstatement__boolean__inherited_"><strong>ShowErrorStatement</strong> (boolean, inherited)</a></h3>
<p>Appends information about the current statement to error messages. If placeholder information 
is available, adds that as well. Defaults to false.</p>
<p>
</p>
<h3><a name="warn__boolean__inherited_"><strong>Warn</strong> (boolean, inherited)</a></h3>
<p>Enables warnings. This is on by default, and should only be turned off in a local block 
for a short a time only when absolutely needed.</p>
<p>
</p>
<h3><a name="executed__boolean__read_only_"><strong>Executed</strong> (boolean, read-only)</a></h3>
<p>Indicates if a handle has been executed. For database handles, this value is true after the <a href="../../lib/pods/perlfunc.html#do">do</a> method has been called, or 
when one of the child statement handles has issued an <a href="#execute">execute</a>. Issuing a <a href="#commit">commit</a> or <a href="#rollback">rollback</a> always resets the 
attribute to false for database handles. For statement handles, any call to <a href="#execute">execute</a> or its variants will flip the value to 
true for the lifetime of the statement handle.</p>
<p>
</p>
<h3><a name="tracelevel__integer__inherited_"><strong>TraceLevel</strong> (integer, inherited)</a></h3>
<p>Sets the trace level, similar to the <a href="#trace">trace</a> method. See the sections on 
<a href="#trace">trace</a> and <a href="#parse_trace_flag">parse_trace_flag</a> for more details.</p>
<p>
</p>
<h3><a name="active__boolean__read_only_"><strong>Active</strong> (boolean, read-only)</a></h3>
<p>Indicates if a handle is active or not. For database handles, this indicates if the database has 
been disconnected or not. For statement handles, it indicates if all the data has been fetched yet 
or not. Use of this attribute is not encouraged.</p>
<p>
</p>
<h3><a name="kids__integer__read_only_"><strong>Kids</strong> (integer, read-only)</a></h3>
<p>Returns the number of child processes created for each handle type. For a driver handle, indicates the number 
of database handles created. For a database handle, indicates the number of statement handles created. For 
statement handles, it always returns zero, because statement handles do not create kids.</p>
<p>
</p>
<h3><a name="activekids__integer__read_only_"><strong>ActiveKids</strong> (integer, read-only)</a></h3>
<p>Same as <code>Kids</code>, but only returns those that are active.</p>
<p>
</p>
<h3><a name="cachedkids__hash_ref_"><strong>CachedKids</strong> (hash ref)</a></h3>
<p>Returns a hashref of handles. If called on a database handle, returns all statement handles created by use of the 
<code>prepare_cached</code> method. If called on a driver handle, returns all database handles created by the <a href="#connect_cached">connect_cached</a> 
method.</p>
<p>
</p>
<h3><a name="childhandles__array_ref_"><strong>ChildHandles</strong> (array ref)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="printwarn__boolean__inherited_"><strong>PrintWarn</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="handleerror__boolean__inherited_"><strong>HandleError</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="handleseterr__code_ref__inherited_"><strong>HandleSetErr</strong> (code ref, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="errcount__unsigned_integer_"><strong>ErrCount</strong> (unsigned integer)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="fetchhashkeyname__string__inherited_"><strong>FetchHashKeyName</strong> (string, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="chopblanks__boolean__inherited_"><strong>ChopBlanks</strong> (boolean, inherited)</a></h3>
<p>Supported by DBD::Pg as proposed by DBI. This method is similar to the
SQL function <code>RTRIM</code>.</p>
<p>
</p>
<h3><a name="taint__boolean__inherited_"><strong>Taint</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="taintin__boolean__inherited_"><strong>TaintIn</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="taintout__boolean__inherited_"><strong>TaintOut</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="profile__inherited_"><strong>Profile</strong> (inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="type__scalar_"><strong>Type</strong> (scalar)</a></h3>
<p>Returns <code>dr</code> for a driver handle, <code>db</code> for a database handle, and <code>st</code> for a statement handle. 
Should be rarely needed.</p>
<p>
</p>
<h3><a name="longreadlen"><strong>LongReadLen</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<h3><a name="longtruncok"><strong>LongTruncOk</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<h3><a name="compatmode"><strong>CompatMode</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<hr />
<h1><a name="dbi_database_handle_objects">DBI DATABASE HANDLE OBJECTS</a></h1>
<p>
</p>
<h2><a name="database_handle_methods">Database Handle Methods</a></h2>
<p>
</p>
<h3><a name="selectall_arrayref"><strong>selectall_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns a reference to an array containing the rows returned by preparing and executing the SQL string.
See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="selectall_hashref"><strong>selectall_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="variable">$key_field</span><span class="operator">);</span>
</pre>
<p>Returns a reference to a hash containing the rows returned by preparing and executing the SQL string.
See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="selectcol_arrayref"><strong>selectcol_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectcol_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns a reference to an array containing the first column 
from each rows returned by preparing and executing the SQL string. It is possible to specify exactly 
which columns to return. See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="prepare"><strong>prepare</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>WARNING: DBD::Pg now (as of version 1.40) uses true prepared statements by sending them 
to the backend to be prepared by the Postgres server. Statements 
that were legal before may no longer work. See below for details.</p>
<p>The prepare method prepares a statement for later execution. PostgreSQL supports 
prepared statements, which enables DBD::Pg to only send the query once, and
simply send the arguments for every subsequent call to <a href="#execute">execute</a>.
DBD::Pg can use these server-side prepared statements, or it can
just send the entire query to the server each time. The best way
is automatically chosen for each query. This will be sufficient for
most users: keep reading for a more detailed explanation and some
optional flags.</p>
<p>Queries that do not begin with the word &quot;SELECT&quot;, &quot;INSERT&quot;, 
&quot;UPDATE&quot;, or &quot;DELETE&quot; are never sent as server-side prepared statements.</p>
<p>Deciding whether or not to use prepared statements depends on many factors, 
but you can force them to be used or not used by using the 
<a href="#pg_server_prepare">pg_server_prepare</a> attribute when calling <a href="#prepare">prepare</a>. Setting this to &quot;0&quot; means to never use 
prepared statements. Setting <a href="#pg_server_prepare">pg_server_prepare</a> to &quot;1&quot; means that prepared 
statements should be used whenever possible. This is the default when connected 
to Postgres servers version 8.0 or higher. Servers that are version 7.4 get a special 
default value of &quot;2&quot;, because server-side statements were only partially supported 
in that version. In this case, it only uses server-side prepares if all 
parameters are specifically bound.</p>
<p>The <a href="#pg_server_prepare">pg_server_prepare</a> attribute can also be set at connection time like so:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$DBNAME</span><span class="operator">,</span> <span class="variable">$DBUSER</span><span class="operator">,</span> <span class="variable">$DBPASS</span><span class="operator">,</span>
                      <span class="operator">{</span> <span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span>
                        <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
                        <span class="string">pg_server_prepare</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span>
                      <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>or you may set it after your database handle is created:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>To enable it for just one particular statement:</p>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT id FROM mytable WHERE val = ?"</span><span class="operator">,</span>
                       <span class="operator">{</span> <span class="string">pg_server_prepare</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>You can even toggle between the two as you go:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">22</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">44</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">66</span><span class="operator">);</span>
</pre>
<p>In the above example, the first execute will use the previously prepared statement.
The second execute will not, but will build the query into a single string and send
it to the server. The third one will act like the first and only send the arguments.
Even if you toggle back and forth, a statement is only prepared once.</p>
<p>Using prepared statements is in theory quite a bit faster: not only does the
PostgreSQL backend only have to prepare the query only once, but DBD::Pg no
longer has to worry about quoting each value before sending it to the server.</p>
<p>However, there are some drawbacks. The server cannot always choose the ideal
parse plan because it will not know the arguments before hand. But for most
situations in which you will be executing similar data many times, the default
plan will probably work out well. Programs such as PgBouncer which cache connections 
at a low level should not use prepared statements via DBD::Pg, or must take 
extra care in the application to account for the fact that prepared statements 
are not shared across database connections. Further discussion on this subject is beyond
the scope of this documentation: please consult the pgsql-performance mailing
list, <a href="http://archives.postgresql.org/pgsql-performance/">http://archives.postgresql.org/pgsql-performance/</a></p>
<p>Only certain commands will be sent to a server-side prepare: currently these
include <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>. DBD::Pg uses a simple
naming scheme for the prepared statements themselves: <strong>dbdpg_XY_Z</strong>, where <strong>Y</strong> is the current 
PID, <strong>X</strong> is either 'p' or 'n' (depending on if the PID is a positive or negative 
number), and <strong>Z</strong> is a number that starts at 1 and increases each time a new statement 
is prepared. This number is tracked at the database handle level, so multiple
statement handles will not collide.</p>
<p>You cannot send more than one command at a time in the same prepare command 
(by separating them with semi-colons) when using server-side prepares.</p>
<p>The actual <code>PREPARE</code> is usually not performed until the first execute is called, due
to the fact that information on the data types (provided by <a href="#bind_param">bind_param</a>) may
be provided after the prepare but before the execute.</p>
<p>A server-side prepare may happen before the first <a href="#execute">execute</a>, but only if the server can
handle the server-side prepare, and the statement contains no placeholders. It will 
also be prepared if the <a href="#pg_prepare_now">pg_prepare_now</a> attribute is passed in and set to a true 
value. Similarly, the <a href="#pg_prepare_now">pg_prepare_now</a> attribute can be set to 0 to ensure that
the statement is <strong>not</strong> prepared immediately, although the cases in which you would
want this are very rare. Finally, you can set the default behavior of all prepare
statements by setting the <a href="#pg_prepare_now">pg_prepare_now</a> attribute on the database handle:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_prepare_now</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>The following two examples will be prepared right away:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123"</span><span class="operator">);</span> <span class="comment">## no placeholders</span>
</pre>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123, ?"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_prepare_now</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>The following two examples will NOT be prepared right away:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123, ?"</span><span class="operator">);</span> <span class="comment">## has a placeholder</span>
</pre>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_prepare_now</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>There are times when you may want to prepare a statement yourself. To do this,
simply send the <code>PREPARE</code> statement directly to the server (e.g. with
the <a href="../../lib/pods/perlfunc.html#do">do</a> method). Create a statement handle and set the prepared name via
the <a href="#pg_prepare_name">pg_prepare_name</a> attribute. The statement handle can be created with a dummy
statement, as it will not be executed. However, it should have the same
number of placeholders as your prepared statement. Example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'PREPARE mystat AS SELECT COUNT(*) FROM pg_class WHERE reltuples &lt; ?'</span><span class="operator">);</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'SELECT ?'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">SQL_INTEGER</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_prepare_name</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'mystat'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">);</span>
</pre>
<p>The above will run the equivalent of this query on the backend:</p>
<pre>
  <span class="variable">EXECUTE</span> <span class="variable">mystat</span><span class="operator">(</span><span class="number">123</span><span class="operator">);</span>
</pre>
<p>which is the equivalent of:</p>
<pre>
  <span class="variable">SELECT</span> <span class="variable">COUNT</span><span class="operator">(*)</span> <span class="variable">FROM</span> <span class="variable">pg_class</span> <span class="variable">WHERE</span> <span class="variable">reltuples</span> <span class="operator">&lt;</span> <span class="number">123</span><span class="operator">;</span>
</pre>
<p>You can force DBD::Pg to send your query directly to the server by adding
the <a href="#pg_direct">pg_direct</a> attribute to your prepare call. This is not recommended,
but is added just in case you need it.</p>
<p>
</p>
<h4><a name="placeholders"><strong>Placeholders</strong></a></h4>
<p>There are three types of placeholders that can be used in DBD::Pg. The first is
the &quot;question mark&quot; type, in which each placeholder is represented by a single
question mark character. This is the method recommended by the DBI specs and is the most
portable. Each question mark is internally replaced by a &quot;dollar sign number&quot; in the order
in which they appear in the query (important when using <a href="#bind_param">bind_param</a>).</p>
<p>The method second type of placeholder is &quot;dollar sign numbers&quot;. This is the method
that Postgres uses internally and is overall probably the best method to use
if you do not need compatibility with other database systems. DBD::Pg, like
PostgreSQL, allows the same number to be used more than once in the query.
Numbers must start with &quot;1&quot; and increment by one value (but can appear in any order 
within the query). If the same number appears more than once in a query, it is treated as a 
single parameter and all instances are replaced at once. Examples:</p>
<p>Not legal:</p>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $2'</span><span class="operator">;</span> <span class="comment"># Does not start with 1</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $3'</span><span class="operator">;</span> <span class="comment"># Missing 2</span>
</pre>
<p>Legal:</p>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $1'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $2 AND $1'</span><span class="operator">;</span> <span class="comment"># legal but confusing</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2 AND reltuples &gt; $1'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $1 AND reltuples &gt; $1'</span><span class="operator">;</span>
</pre>
<p>In the final statement above, DBI thinks there is only one placeholder, so this
statement will replace both placeholders:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2045</span><span class="operator">);</span>
</pre>
<p>While a simple execute with no bind_param calls requires only a single argument as well:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">2045</span><span class="operator">);</span>
</pre>
<p>The final placeholder type is &quot;named parameters&quot; in the format &quot;:foo&quot;. While this
syntax is supported by DBD::Pg, its use is discouraged in favor of 
dollar-sign numbers.</p>
<p>The different types of placeholders cannot be mixed within a statement, but you may
use different ones for each statement handle you have. This is confusing at best, so 
stick to one style within your program.</p>
<p>If your queries use operators that contain question marks (e.g. some of the native 
Postgres geometric operators) or array slices (e.g. <code>data[100:300]</code>), you can tell 
DBD::Pg to ignore any non-dollar sign placeholders by setting the 
<a href="#pg_placeholder_dollaronly">pg_placeholder_dollaronly</a> attribute at either the database handle or the statement 
handle level. Examples:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_placeholder_dollaronly</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT * FROM mytable WHERE lseg1 ?# lseg2 AND name = $1}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'segname'</span><span class="operator">);</span>
</pre>
<p>Alternatively, you can set it at prepare time:</p>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT * FROM mytable WHERE lseg1 ?-| lseg2 AND name = $1}</span><span class="operator">,</span>
    <span class="operator">{</span><span class="variable">pg_placeholder_dollaronly</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'segname'</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="prepare_cached"><strong>prepare_cached</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare_cached</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Implemented by DBI, no driver-specific impact. This method is most useful
when using a server that supports server-side prepares, and you have asked
the prepare to happen immediately via the <a href="#pg_prepare_now">pg_prepare_now</a> attribute.</p>
<p>
</p>
<h3><a name="do"><strong>do</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Prepare and execute a single statement. Returns the number of rows affected if the 
query was successful, returns undef if an error occurred, and returns -1 if the 
number of rows is unknown or not available. Note that this method will return <strong>0E0</strong> instead
of 0 for 'no rows were affected', in order to always return a true value if no error occurred.</p>
<p>If neither <code>\%attr</code> nor <code>@bind_values</code> is given, the query will be sent directly
to the server without the overhead of internally creating a statement handle and
running prepare and execute, for a measurable speed increase.</p>
<p>Note that an empty statement (a string with no length) will not be passed to
the server; if you want a simple test, use &quot;SELECT 123&quot; or the <a href="#ping">ping</a> method.</p>
<p>
</p>
<h3><a name="last_insert_id"><strong>last_insert_id</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="operator">{</span><span class="string">sequence</span> <span class="operator">=&gt;</span> <span class="variable">$seqname</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>Attempts to return the id of the last value to be inserted into a table.
You can either provide a sequence name (preferred) or provide a table
name with optional schema, and DBD::Pg will attempt to find the sequence itself. 
The current value of the sequence is returned by a call to the <code>CURRVAL()</code> 
PostgreSQL function. This will fail if the sequence has not yet been used in the 
current database connection.</p>
<p>If you do not know the name of the sequence, you can provide a table name and
DBD::Pg will attempt to return the correct value. To do this, there must be at
least one column in the table with a <code>NOT NULL</code> constraint, that has a unique
constraint, and which uses a sequence as a default value. If more than one column
meets these conditions, the primary key will be used. This involves some
looking up of things in the system table, so DBD::Pg will cache the sequence
name for subsequent calls. If you need to disable this caching for some reason,
(such as the sequence name changing), you can control it by adding <code>pg_cache =&gt; 0</code>
to the final (hashref) argument for last_insert_id.</p>
<p>Please keep in mind that this method is far from foolproof, so make your
script use it properly. Specifically, make sure that it is called
immediately after the insert, and that the insert does not add a value
to the column that is using the sequence as a default value. However, because 
we are using sequences, you can be sure that the value you got back has not 
been used by any other process.</p>
<p>Some examples:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'CREATE SEQUENCE lii_seq START 1'</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{CREATE TABLE lii (
    foobar INTEGER NOT NULL UNIQUE DEFAULT nextval('lii_seq'),
    baz VARCHAR)}</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'INSERT INTO lii(baz) VALUES (?)'</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="string">qw(uno dos tres cuatro)</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$newid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="operator">{</span><span class="string">sequence</span><span class="operator">=&gt;</span><span class="string">'lii_seq'</span><span class="operator">}</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"Last insert id was </span><span class="variable">$newid</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>If you did not want to worry about the sequence name:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'CREATE TABLE lii2 (
    foobar SERIAL UNIQUE,
    baz VARCHAR)'</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'INSERT INTO lii2(baz) VALUES (?)'</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="string">qw(uno dos tres cuatro)</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$newid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="string">"lii2"</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"Last insert id was </span><span class="variable">$newid</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="commit"><strong>commit</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">;</span>
</pre>
<p>Issues a COMMIT to the server, indicating that the current transaction is finished and that 
all changes made will be visible to other processes. If AutoCommit is enabled, then 
a warning is given and no COMMIT is issued. Returns true on success, false on error.
See also the the section on <a href="#transactions">Transactions</a>.</p>
<p>
</p>
<h3><a name="rollback"><strong>rollback</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">rollback</span><span class="operator">;</span>
</pre>
<p>Issues a ROLLBACK to the server, which discards any changes made in the current transaction. If AutoCommit 
is enabled, then a warning is given and no ROLLBACK is issued. Returns true on success, and 
false on error. See also the the section on <a href="#transactions">Transactions</a>.</p>
<p>
</p>
<h3><a name="begin_work"><strong>begin_work</strong></a></h3>
<p>This method turns on transactions until the next call to <a href="#commit">commit</a> or <a href="#rollback">rollback</a>, if <a href="#autocommit">AutoCommit</a> is 
currently enabled. If it is not enabled, calling begin_work will issue an error. Note that the 
transaction will not actually begin until the first statement after begin_work is called.
Example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'INSERT INTO foo VALUES (123)'</span><span class="operator">);</span> <span class="comment">## Changes committed immediately</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">begin_work</span><span class="operator">();</span>
  <span class="comment">## Not in a transaction yet, but AutoCommit is set to 0</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"INSERT INTO foo VALUES (345)"</span><span class="operator">);</span>
  <span class="comment">## DBD::PG actually issues two statements here:</span>
  <span class="comment">## BEGIN;</span>
  <span class="comment">## INSERT INTO foo VALUES (345)</span>
  <span class="comment">## We are now in a transaction</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">();</span>
  <span class="comment">## AutoCommit is now set to 1 again</span>
</pre>
<p>
</p>
<h3><a name="disconnect"><strong>disconnect</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">disconnect</span><span class="operator">;</span>
</pre>
<p>Disconnects from the Postgres database. Any uncommitted changes will be rolled back upon disconnection. It's 
good policy to always explicitly call commit or rollback at some point before disconnecting, rather than 
relying on the default rollback behavior.</p>
<p>This method may give warnings about &quot;disconnect invalidates X active statement handle(s)&quot;. This means that 
you called <code>$sth-&gt;execute()</code> but did not finish fetching all the rows from them. To avoid seeing this 
warning, either fetch all the rows or call <code>$sth-&gt;finish()</code> for each executed statement handle.</p>
<p>If the script exits before disconnect is called (or, more precisely, if the database handle is no longer 
referenced by anything), then the database handle's DESTROY method will call the <code>rollback()</code> and <code>disconnect()</code> 
methods automatically. It is best to explicitly disconnect rather than rely on this behavior.</p>
<p>
</p>
<h3><a name="quote"><strong>quote</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">,</span> <span class="variable">$data_type</span><span class="operator">);</span>
</pre>
<p>This module implements its own <code>quote</code> method. For simple string types, both backslashes 
and single quotes are doubled. You may also quote arrayrefs and receive a string 
suitable for passing into Postgres array columns.</p>
<p>If the value contains backslashes, and the server is version 8.1 or higher, 
then the escaped string syntax will be used (which places a capital E before 
the first single quote). This syntax is always used when quoting bytea values 
on servers 8.1 and higher.</p>
<p>The <code>data_type</code> argument is optional and should be one of the type constants 
exported by DBD::Pg (such as PG_BYTEA). In addition to string, bytea, char, bool, 
and other standard types, the following geometric types are supported: point, line, 
lseg, box, path, polygon, and circle (PG_POINT, PG_LINE, PG_LSEG, PG_BOX, 
PG_PATH, PG_POLYGON, and PG_CIRCLE respectively). To quote a Postgres-specific 
data type, you must use a 'hashref' argument like so:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$quotedval</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_VARCHAR</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p><strong>NOTE:</strong> The undocumented (and invalid) support for the <code>SQL_BINARY</code> data
type is officially deprecated. Use <code>PG_BYTEA</code> with <code>bind_param()</code> instead:</p>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span>
                         <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_BYTEA</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="quote_identifier"><strong>quote_identifier</strong></a></h3>
<pre>
  <span class="variable">$string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span> <span class="variable">$name</span> <span class="operator">);</span>
  <span class="variable">$string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">);</span>
</pre>
<p>Returns a quoted version of the supplied string, which is commonly a schema, 
table, or column name. The three argument form will return the schema and 
the table together, separated by a dot. Examples:</p>
<pre>
  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="string">'grapefruit'</span><span class="operator">);</span> <span class="comment">## Prints: "grapefruit"</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="string">'juicy fruit'</span><span class="operator">);</span> <span class="comment">## Prints: "juicy fruit"</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="string">'public'</span><span class="operator">,</span> <span class="string">'pg_proc'</span><span class="operator">);</span>
  <span class="comment">## Prints: "public"."pg_proc"</span>
</pre>
<p>
</p>
<h3><a name="pg_notifies"><strong>pg_notifies</strong></a></h3>
<pre>
  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_notifies</span><span class="operator">;</span>
</pre>
<p>Looks for any asynchronous notifications received and returns either <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> 
or a reference to a three-element array consisting of an event name, the PID 
of the backend that sent the NOTIFY command, and the optional payload string. 
Note that this does not check if the connection to the database is still valid first - 
for that, use the c&lt;ping&gt; method. You may need to commit if not in autocommit mode - 
new notices will not be picked up while in the middle of a transaction. An example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"LISTEN abc"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"LISTEN def"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Hang around until we get the message we want</span>
  <span class="variable">LISTENLOOP</span><span class="operator">:</span> <span class="operator">{</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$notify</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_notifies</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$pid</span><span class="operator">,</span> <span class="variable">$payload</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@$notify</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">qq{I received notice "</span><span class="variable">$name</span><span class="string">" from PID </span><span class="variable">$pid</span><span class="string">, payload was "</span><span class="variable">$payload</span><span class="string">"\n}</span><span class="operator">;</span>
      <span class="comment">## Do something based on the notice received</span>
    <span class="operator">}</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ping</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">qq{Ping failed!}</span><span class="operator">;</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">();</span>
    <span class="keyword">sleep</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span>
    <span class="keyword">redo</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Payloads will always be an empty string unless you are connecting to a Postgres 
server version 9.0 or higher.</p>
<p>
</p>
<h3><a name="ping"><strong>ping</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ping</span><span class="operator">;</span>
</pre>
<p>This <code>ping</code> method is used to check the validity of a database handle. The value returned is 
either 0, indicating that the connection is no longer valid, or a positive integer, indicating 
the following:</p>
<pre>
  Value    Meaning
  --------------------------------------------------
    1      Database is idle (not in a transaction)
    2      Database is active, there is a command in progress (usually seen after a COPY command)
    3      Database is idle within a transaction
    4      Database is idle, within a failed transaction</pre>
<p>Additional information on why a handle is not valid can be obtained by using the 
<a href="#pg_ping">pg_ping</a> method.</p>
<p>
</p>
<h3><a name="pg_ping"><strong>pg_ping</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ping</span><span class="operator">;</span>
</pre>
<p>This is a DBD::Pg-specific extension to the <a href="#ping">ping</a> method. This will check the 
validity of a database handle in exactly the same way as <code>ping</code>, but instead of 
returning a 0 for an invalid connection, it will return a negative number. So in 
addition to returning the positive numbers documented for <code>ping</code>, it may also 
return the following:</p>
<pre>
  Value    Meaning
  --------------------------------------------------
   -1      There is no connection to the database at all (e.g. after C&lt;disconnect&gt;)
   -2      An unknown transaction status was returned (e.g. after forking)
   -3      The handle exists, but no data was returned from a test query.</pre>
<p>In practice, you should only ever see -1 and -2.</p>
<p>
</p>
<h3><a name="get_info"><strong>get_info</strong></a></h3>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">get_info</span><span class="operator">(</span><span class="variable">$info_type</span><span class="operator">);</span>
</pre>
<p>Supports a very large set (&gt; 250) of the information types, including the minimum 
recommended by DBI.</p>
<p>
</p>
<h3><a name="table_info"><strong>table_info</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">);</span>
</pre>
<p>Returns all tables and views visible to the current user. 
The schema and table arguments will do a <code>LIKE</code> search if a percent sign (<code>%</code>) or an 
underscore (<code>_</code>) is detected in the argument. The <code>$type</code> argument accepts a value of either 
&quot;TABLE&quot; or &quot;VIEW&quot; (using both is the default action). Note that a statement handle is returned, 
and not a direct list of tables. See the examples below for ways to handle this.</p>
<p>The following fields are returned:</p>
<p><strong>TABLE_CAT</strong>: Always NULL, as Postgres does not have the concept of catalogs.</p>
<p><strong>TABLE_SCHEM</strong>: The name of the schema that the table or view is in.</p>
<p><strong>TABLE_NAME</strong>: The name of the table or view.</p>
<p><strong>TABLE_TYPE</strong>: The type of object returned. Will be one of &quot;TABLE&quot;, &quot;VIEW&quot;, 
or &quot;SYSTEM TABLE&quot;.</p>
<p>The TABLE_SCHEM and TABLE_NAME will be quoted via <code>quote_ident()</code>.</p>
<p>Two additional fields specific to DBD::Pg are returned:</p>
<p><strong>pg_schema</strong>: the unquoted name of the schema</p>
<p><strong>pg_table</strong>: the unquoted name of the table</p>
<p>If your database supports tablespaces (version 8.0 or greater), two additional
DBD::Pg specific fields are returned:</p>
<p><strong>pg_tablespace_name</strong>: the name of the tablespace the table is in</p>
<p><strong>pg_tablespace_location</strong>: the location of the tablespace the table is in</p>
<p>Tables that have not been assigned to a particular tablespace (or views) 
will return NULL (<a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a>) for both of the above field.</p>
<p>Rows are returned alphabetically, with all tables first, and then all views.</p>
<p>Examples of use:</p>
<pre>
  <span class="comment">## Display all tables and views in the public schema:</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="string">'public'</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$rel</span> <span class="operator">(</span><span class="variable">@</span><span class="operator">{</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span><span class="operator">{}</span><span class="operator">)</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_TYPE} name is </span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_NAME}\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="comment"># Display the schema of all tables named 'foo':</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="string">'foo'</span><span class="operator">,</span> <span class="string">'TABLE'</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$rel</span> <span class="operator">(</span><span class="variable">@</span><span class="operator">{</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span><span class="operator">{}</span><span class="operator">)</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Table name is </span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_SCHEM}.</span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_NAME}\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="column_info"><strong>column_info</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">column_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$column</span> <span class="operator">);</span>
</pre>
<p>Supported by this driver as proposed by DBI with the follow exceptions.
These fields are currently always returned with NULL (<a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a>) values:</p>
<pre>
   TABLE_CAT
   BUFFER_LENGTH
   DECIMAL_DIGITS
   NUM_PREC_RADIX
   SQL_DATA_TYPE
   SQL_DATETIME_SUB
   CHAR_OCTET_LENGTH</pre>
<p>Also, six additional non-standard fields are returned:</p>
<p><strong>pg_type</strong>: data type with additional info i.e. &quot;character varying(20)&quot;</p>
<p><strong>pg_constraint</strong>: holds column constraint definition</p>
<p><strong>pg_schema</strong>: the unquoted name of the schema</p>
<p><strong>pg_table</strong>: the unquoted name of the table</p>
<p><strong>pg_column</strong>: the unquoted name of the column</p>
<p><strong>pg_enum_values</strong>: an array reference of allowed values for an enum column</p>
<p>Note that the TABLE_SCHEM, TABLE_NAME, and COLUMN_NAME fields all return 
output wrapped in <code>quote_ident()</code>. If you need the unquoted version, use 
the pg_ fields above.</p>
<p>
</p>
<h3><a name="primary_key_info"><strong>primary_key_info</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
</pre>
<p>Supported by this driver as proposed by DBI. There are no search patterns allowed, but leaving the 
$schema argument blank will cause the first table found in the schema 
search path to be used. An additional field, &quot;DATA_TYPE&quot;, is returned and 
shows the data type for each of the arguments in the &quot;COLUMN_NAME&quot; field.</p>
<p>This method will also return tablespace information for servers that support
tablespaces. See the <a href="#table_info">table_info</a> entry for more information.</p>
<p>The five additional custom fields returned are:</p>
<p><strong>pg_tablespace_name</strong>: name of the tablespace, if any</p>
<p><strong>pg_tablespace_location</strong>: location of the tablespace</p>
<p><strong>pg_schema</strong>: the unquoted name of the schema</p>
<p><strong>pg_table</strong>: the unquoted name of the table</p>
<p><strong>pg_column</strong>: the unquoted name of the column</p>
<p>In addition to the standard format of returning one row for each column
found for the primary key, you can pass the <code>pg_onerow</code> attribute to force
a single row to be used. If the primary key has multiple columns, the
&quot;KEY_SEQ&quot;, &quot;COLUMN_NAME&quot;, and &quot;DATA_TYPE&quot; fields will return a comma-delimited
string. If the <code>pg_onerow</code> attribute is set to &quot;2&quot;, the fields will be
returned as an arrayref, which can be useful when multiple columns are
involved:</p>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">'dbd_pg_test'</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_onerow</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$sth</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$pk</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Table </span><span class="variable">$pk</span><span class="string">-&gt;[2] has a primary key on these columns:\n"</span><span class="operator">;</span>
    <span class="keyword">for</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$x</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span> <span class="keyword">defined</span> <span class="variable">$pk</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">3</span><span class="operator">][</span><span class="variable">$x</span><span class="operator">]</span><span class="operator">;</span> <span class="variable">$x</span><span class="operator">++)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"Column: </span><span class="variable">$pk</span><span class="string">-&gt;[3][</span><span class="variable">$x</span><span class="string">]  (data type: </span><span class="variable">$pk</span><span class="string">-&gt;[6][</span><span class="variable">$x</span><span class="string">])\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="primary_key"><strong>primary_key</strong></a></h3>
<pre>
  <span class="variable">@key_column_names</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">);</span>
</pre>
<p>Simple interface to the <a href="#primary_key_info">primary_key_info</a> method. Returns a list of the column names that 
comprise the primary key of the specified table. The list is in primary key column sequence 
order. If there is no primary key then an empty list is returned.</p>
<p>
</p>
<h3><a name="foreign_key_info"><strong>foreign_key_info</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">foreign_key_info</span><span class="operator">(</span> <span class="variable">$pk_catalog</span><span class="operator">,</span> <span class="variable">$pk_schema</span><span class="operator">,</span> <span class="variable">$pk_table</span><span class="operator">,</span>
                                 <span class="variable">$fk_catalog</span><span class="operator">,</span> <span class="variable">$fk_schema</span><span class="operator">,</span> <span class="variable">$fk_table</span> <span class="operator">);</span>
</pre>
<p>Supported by this driver as proposed by DBI, using the SQL/CLI variant.
There are no search patterns allowed, but leaving the <code>$schema</code> argument
blank will cause the first table found in the schema search path to be
used. Two additional fields, &quot;UK_DATA_TYPE&quot; and &quot;FK_DATA_TYPE&quot;, are returned
to show the data type for the unique and foreign key columns. Foreign
keys that have no named constraint (where the referenced column only has
an unique index) will return <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> for the &quot;UK_NAME&quot; field.</p>
<p>
</p>
<h3><a name="statistics_info"><strong>statistics_info</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">statistics_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$unique_only</span><span class="operator">,</span> <span class="variable">$quick</span> <span class="operator">);</span>
</pre>
<p>Returns a statement handle that can be fetched from to give statistics information 
on a specific table and its indexes. The <code>$table</code> argument is mandatory. The 
<code>$schema</code> argument is optional but recommended. The <code>$unique_only</code> argument, if true, 
causes only information about unique indexes to be returned. The <code>$quick</code> argument is 
not used by DBD::Pg. For information on the format of the rows returned, please see the DBI 
documentation.</p>
<a href="http://search.cpan.org/~timb/DBI/DBI.pm#statistics_info">DBI section on statistics_info</a><p>
</p>
<h3><a name="tables"><strong>tables</strong></a></h3>
<pre>
  <span class="variable">@names</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
</pre>
<p>Supported by this driver as proposed by DBI. This method returns all tables
and/or views which are visible to the current user: see <a href="#table_info">table_info</a>
for more information about the arguments. The name of the schema appears 
before the table or view name. This can be turned off by adding in the 
<code>pg_noprefix</code> attribute:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">@tables</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">(</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">'dbd_pg_test'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_noprefix</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span> <span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="type_info_all"><strong>type_info_all</strong></a></h3>
<pre>
  <span class="variable">$type_info_all</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">type_info_all</span><span class="operator">;</span>
</pre>
<p>Supported by this driver as proposed by DBI. Information is only provided for
SQL datatypes and for frequently used datatypes. The mapping between the
PostgreSQL typename and the SQL92 datatype (if possible) has been done
according to the following table:</p>
<pre>
  +---------------+------------------------------------+
  | typname       | SQL92                              |
  |---------------+------------------------------------|
  | bool          | BOOL                               |
  | text          | /                                  |
  | bpchar        | CHAR(n)                            |
  | varchar       | VARCHAR(n)                         |
  | int2          | SMALLINT                           |
  | int4          | INT                                |
  | int8          | /                                  |
  | money         | /                                  |
  | float4        | FLOAT(p)   p&lt;7=float4, p&lt;16=float8 |
  | float8        | REAL                               |
  | abstime       | /                                  |
  | reltime       | /                                  |
  | tinterval     | /                                  |
  | date          | /                                  |
  | time          | /                                  |
  | datetime      | /                                  |
  | timespan      | TINTERVAL                          |
  | timestamp     | TIMESTAMP                          |
  +---------------+------------------------------------+</pre>
<p>
</p>
<h3><a name="type_info"><strong>type_info</strong></a></h3>
<pre>
  <span class="variable">@type_info</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">type_info</span><span class="operator">(</span><span class="variable">$data_type</span><span class="operator">);</span>
</pre>
<p>Returns a list of hash references holding information about one or more variants of $data_type. 
See the DBI documentation for more details.</p>
<p>
</p>
<h3><a name="pg_server_trace"><strong>pg_server_trace</strong></a></h3>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_trace</span><span class="operator">(</span><span class="variable">$filehandle</span><span class="operator">);</span>
</pre>
<p>Writes debugging information from the PostgreSQL backend to a file. This is
not related to the DBI <a href="#trace">trace</a> method and you should not use this method unless
you know what you are doing. If you do enable this, be aware that the file
will grow very large, very quick. To stop logging to the file, use the
<a href="#pg_server_untrace">pg_server_untrace</a> method. The first argument must be a file handle, not
a filename. Example:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$pid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_pid</span><span class="operator">}</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$file</span> <span class="operator">=</span> <span class="string">"pgbackend.</span><span class="variable">$pid</span><span class="string">.debug.log"</span><span class="operator">;</span>
  <span class="keyword">open</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"&gt;</span><span class="variable">$file</span><span class="string">"</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">qq{Could not open "</span><span class="variable">$file</span><span class="string">": $!\n}</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_trace</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">);</span>
  <span class="comment">## Run code you want to trace here</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_untrace</span><span class="operator">;</span>
  <span class="keyword">close</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="pg_server_untrace"><strong>pg_server_untrace</strong></a></h3>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_untrace</span><span class="operator">;</span>
</pre>
<p>Stop server logging to a previously opened file.</p>
<p>
</p>
<h3><a name="selectrow_array"><strong>selectrow_array</strong></a></h3>
<pre>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns an array of row information after preparing and executing the provided SQL string. The rows are returned 
by calling <a href="#fetchrow_array">fetchrow_array</a>. The string can also be a statement handle generated by a previous prepare. Note that 
only the first row of data is returned. If called in a scalar context, only the first column of the first row is 
returned. Because this is not portable, it is not recommended that you use this method in that way.</p>
<p>
</p>
<h3><a name="selectrow_arrayref"><strong>selectrow_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Exactly the same as <a href="#selectrow_array">selectrow_array</a>, except that it returns a reference to an array, by internal use of 
the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method.</p>
<p>
</p>
<h3><a name="selectrow_hashref"><strong>selectrow_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Exactly the same as <a href="#selectrow_array">selectrow_array</a>, except that it returns a reference to an hash, by internal use of 
the <a href="#fetchrow_hashref">fetchrow_hashref</a> method.</p>
<p>
</p>
<h3><a name="clone"><strong>clone</strong></a></h3>
<pre>
  <span class="variable">$other_dbh</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">();</span>
</pre>
<p>Creates a copy of the database handle by connecting with the same parameters as the original 
handle, then trying to merge the attributes. See the DBI documentation for complete usage.</p>
<p>
</p>
<h2><a name="database_handle_attributes">Database Handle Attributes</a></h2>
<p>
</p>
<h3><a name="autocommit__boolean_"><strong>AutoCommit</strong> (boolean)</a></h3>
<p>Supported by DBD::Pg as proposed by DBI. According to the classification of
DBI, PostgreSQL is a database in which a transaction must be explicitly
started. Without starting a transaction, every change to the database becomes
immediately permanent. The default of AutoCommit is on, but this may change
in the future, so it is highly recommended that you explicitly set it when
calling <a href="../../lib/pods/perlfunc.html#connect">connect</a>. For details see the notes about <a href="#transactions">Transactions</a>
elsewhere in this document.</p>
<p>
</p>
<h3><a name="pg_bool_tf__boolean_"><strong>pg_bool_tf</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. If true, boolean values will be returned
as the characters 't' and 'f' instead of '1' and '0'.</p>
<p>
</p>
<h3><a name="readonly__boolean_"><strong>ReadOnly</strong> (boolean)</a></h3>
<p>$dbh-&gt;{ReadOnly} = 1;</p>
<p>Specifies if the current database connection should be in read-only mode or not. 
In this mode, changes that change the database are not allowed and will throw 
an error. Note: this method will <strong>not</strong> work if <a href="#autocommit">AutoCommit</a> is true. The 
read-only effect is accomplished by sending a SET&nbsp;TRANSACTION&nbsp;READ&nbsp;ONLY after 
every begin. For more details, please see:</p>
<p><a href="http://www.postgresql.org/docs/current/interactive/sql-set-transaction.html">http://www.postgresql.org/docs/current/interactive/sql-set-transaction.html</a></p>
<p>Please not that this method is not foolproof: there are still ways to update the 
database. Consider this a safety net to catch applications that should not be 
issuing commands such as INSERT, UPDATE, or DELETE.</p>
<p>This method method requires DBI version 1.55 or better.</p>
<p>
</p>
<h3><a name="pg_server_prepare__integer_"><strong>pg_server_prepare</strong> (integer)</a></h3>
<p>DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side 
prepared statements. The default value, 1, indicates that prepared statements should 
be used whenever possible. See the section on the <a href="#prepare">prepare</a> method for more information.</p>
<p>
</p>
<h3><a name="pg_placeholder_dollaronly__boolean_"><strong>pg_placeholder_dollaronly</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Defaults to false. When true, question marks inside of statements 
are not treated as <a href="#placeholders">placeholders</a>. Useful for statements that contain unquoted question 
marks, such as geometric operators.</p>
<p>
</p>
<h3><a name="pg_enable_utf8__boolean_"><strong>pg_enable_utf8</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. If true, then the <a href="../../lib/pods/perlrun.html#utf8"><code>utf8</code></a> flag will be turned on
for returned character data (if the data is valid UTF-8). For details about
the <a href="../../lib/pods/perlrun.html#utf8"><code>utf8</code></a> flag, see the <code>Encode</code> module. This attribute is only relevant under
perl 5.8 and later.</p>
<p>
</p>
<h3><a name="pg_errorlevel__integer_"><strong>pg_errorlevel</strong> (integer)</a></h3>
<p>DBD::Pg specific attribute. Sets the amount of information returned by the server's 
error messages. Valid entries are 0, 1, and 2. Any other number will be forced to the 
default value of 1.</p>
<p>A value of 0 (&quot;TERSE&quot;) will show severity, primary text, and position only
and will usually fit on a single line. A value of 1 (&quot;DEFAULT&quot;) will also
show any detail, hint, or context fields. A value of 2 (&quot;VERBOSE&quot;) will
show all available information.</p>
<p>
</p>
<h3><a name="pg_lib_version__integer__read_only_"><strong>pg_lib_version</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Indicates which version of PostgreSQL that 
DBD::Pg was compiled against. In other words, which libraries were used. 
Returns a number with major, minor, and revision together; version 8.1.4 
would be returned as <code>80104</code>.</p>
<p>
</p>
<h3><a name="pg_server_version__integer__read_only_"><strong>pg_server_version</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Indicates which version of PostgreSQL that 
the current database handle is connected to. Returns a number with major, 
minor, and revision together; version 8.0.1 would be <code>80001</code>.</p>
<p>
</p>
<h3><a name="name__string__read_only_"><strong>Name</strong> (string, read-only)</a></h3>
<p>Returns the name of the current database. This is the same as the DSN, without the 
&quot;dbi:Pg:&quot; part. Before version 2.0.0, this only returned the bare database name 
(e.g. 'foo'). From version 2.0.0 onwards, it returns the more correct 
output (e.g. 'dbname=foo')</p>
<p>
</p>
<h3><a name="username__string__read_only_"><strong>Username</strong> (string, read-only)</a></h3>
<p>Returns the name of the user connected to the database.</p>
<p>
</p>
<h3><a name="pg_db__string__read_only_"><strong>pg_db</strong> (string, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the name of the current database.</p>
<p>
</p>
<h3><a name="pg_user__string__read_only_"><strong>pg_user</strong> (string, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the name of the user that
connected to the server.</p>
<p>
</p>
<h3><a name="pg_host__string__read_only_"><strong>pg_host</strong> (string, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the host of the current
server connection. Locally connected hosts will return an empty
string.</p>
<p>
</p>
<h3><a name="pg_port__integer__read_only_"><strong>pg_port</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the port of the connection to
the server.</p>
<p>
</p>
<h3><a name="pg_socket__integer__read_only_"><strong>pg_socket</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the file description number of
the connection socket to the server.</p>
<p>
</p>
<h3><a name="pg_pass__string__read_only_"><strong>pg_pass</strong> (string, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the password used to connect
to the server.</p>
<p>
</p>
<h3><a name="pg_options__string__read_only_"><strong>pg_options</strong> (string, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the command-line options passed
to the server. May be an empty string.</p>
<p>
</p>
<h3><a name="pg_default_port__integer__read_only_"><strong>pg_default_port</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the default port used if none is
specifically given.</p>
<p>
</p>
<h3><a name="pg_pid__integer__read_only_"><strong>pg_pid</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the process id (PID) of the
backend server process handling the connection.</p>
<p>
</p>
<h3><a name="pg_prepare_now__boolean_"><strong>pg_prepare_now</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Default is off. If true, then the <a href="#prepare">prepare</a> method will 
immediately prepare commands, rather than waiting until the first execute.</p>
<p>
</p>
<h3><a name="pg_expand_array__boolean_"><strong>pg_expand_array</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Defaults to true. If false, arrays returned from the server will 
not be changed into a Perl arrayref, but remain as a string.</p>
<p>
</p>
<h3><a name="pg_async_status__integer__read_only_"><strong>pg_async_status</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the current status of an <a href="#asynchronous_queries">asynchronous</a>
command. 0 indicates no asynchronous command is in progress, 1 indicates that 
an asynchronous command has started and -1 indicated that an asynchronous command 
has been cancelled.</p>
<p>
</p>
<h3><a name="pg_standard_conforming_strings__boolean__read_only_"><strong>pg_standard_conforming_strings</strong> (boolean, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns true if the server is currently using 
standard conforming strings. Only available if the target 
server is version 8.2 or better.</p>
<p>
</p>
<h3><a name="pg_inv_read__integer__read_only_"><strong>pg_INV_READ</strong> (integer, read-only)</a></h3>
<p>Constant to be used for the mode in <a href="#lo_creat">lo_creat</a> and <a href="#lo_open">lo_open</a>.</p>
<p>
</p>
<h3><a name="pg_inv_write__integer__read_only_"><strong>pg_INV_WRITE</strong> (integer, read-only)</a></h3>
<p>Constant to be used for the mode in <a href="#lo_creat">lo_creat</a> and <a href="#lo_open">lo_open</a>.</p>
<p>
</p>
<h3><a name="driver__handle__read_only_"><strong>Driver</strong> (handle, read-only)</a></h3>
<p>Holds the handle of the parent driver. The only recommended use for this is to find the name 
of the driver using:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Driver</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="pg_protocol__integer__read_only_"><strong>pg_protocol</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the version of the PostgreSQL server.
If DBD::Pg is unable to figure out the version, it will return a &quot;0&quot;. Otherwise,
a &quot;3&quot; is returned.</p>
<p>
</p>
<h3><a name="rowcachesize"><strong>RowCacheSize</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<hr />
<h1><a name="dbi_statement_handle_objects">DBI STATEMENT HANDLE OBJECTS</a></h1>
<p>
</p>
<h2><a name="statement_handle_methods">Statement Handle Methods</a></h2>
<p>
</p>
<h3><a name="bind_param"><strong>bind_param</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="variable">$bind_type</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Allows the user to bind a value and/or a data type to a placeholder. This is
especially important when using server-side prepares. See the 
<a href="#prepare">prepare</a> method for more information.</p>
<p>The value of <code>$param_num</code> is a number if using the '?' or '$1' style
placeholders. If using &quot;:foo&quot; style placeholders, the complete name
(e.g. &quot;:foo&quot;) must be given. For numeric values, you can either use a
number or use a literal '$1'. See the examples below.</p>
<p>The <code>$bind_value</code> argument is fairly self-explanatory. A value of <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> will
bind a <code>NULL</code> to the placeholder. Using <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> is useful when you want
to change just the type and will be overwriting the value later.
(Any value is actually usable, but <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> is easy and efficient).</p>
<p>The <code>\%attr</code> hash is used to indicate the data type of the placeholder.
The default value is &quot;varchar&quot;. If you need something else, you must
use one of the values provided by DBI or by DBD::Pg. To use a SQL value,
modify your &quot;use DBI&quot; statement at the top of your script as follows:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
</pre>
<p>This will import some constants into your script. You can plug those
directly into the <a href="#bind_param">bind_param</a> call. Some common ones that you will
encounter are:</p>
<pre>
  SQL_INTEGER</pre>
<p>To use PostgreSQL data types, import the list of values like this:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
</pre>
<p>You can then set the data types by setting the value of the <code>pg_type</code>
key in the hash passed to <a href="#bind_param">bind_param</a>.
The current list of Postgres data types exported is:</p>
<pre>
 PG_ABSTIME PG_ABSTIMEARRAY PG_ACLITEM PG_ACLITEMARRAY PG_ANY PG_ANYARRAY
 PG_ANYELEMENT PG_ANYENUM PG_ANYNONARRAY PG_BIT PG_BITARRAY PG_BOOL
 PG_BOOLARRAY PG_BOX PG_BOXARRAY PG_BPCHAR PG_BPCHARARRAY PG_BYTEA
 PG_BYTEAARRAY PG_CHAR PG_CHARARRAY PG_CID PG_CIDARRAY PG_CIDR
 PG_CIDRARRAY PG_CIRCLE PG_CIRCLEARRAY PG_CSTRING PG_CSTRINGARRAY PG_DATE
 PG_DATEARRAY PG_FDW_HANDLER PG_FLOAT4 PG_FLOAT4ARRAY PG_FLOAT8 PG_FLOAT8ARRAY
 PG_GTSVECTOR PG_GTSVECTORARRAY PG_INET PG_INETARRAY PG_INT2 PG_INT2ARRAY
 PG_INT2VECTOR PG_INT2VECTORARRAY PG_INT4 PG_INT4ARRAY PG_INT8 PG_INT8ARRAY
 PG_INTERNAL PG_INTERVAL PG_INTERVALARRAY PG_LANGUAGE_HANDLER PG_LINE PG_LINEARRAY
 PG_LSEG PG_LSEGARRAY PG_MACADDR PG_MACADDRARRAY PG_MONEY PG_MONEYARRAY
 PG_NAME PG_NAMEARRAY PG_NUMERIC PG_NUMERICARRAY PG_OID PG_OIDARRAY
 PG_OIDVECTOR PG_OIDVECTORARRAY PG_OPAQUE PG_PATH PG_PATHARRAY PG_PG_ATTRIBUTE
 PG_PG_CLASS PG_PG_NODE_TREE PG_PG_PROC PG_PG_TYPE PG_POINT PG_POINTARRAY
 PG_POLYGON PG_POLYGONARRAY PG_RECORD PG_RECORDARRAY PG_REFCURSOR PG_REFCURSORARRAY
 PG_REGCLASS PG_REGCLASSARRAY PG_REGCONFIG PG_REGCONFIGARRAY PG_REGDICTIONARY PG_REGDICTIONARYARRAY
 PG_REGOPER PG_REGOPERARRAY PG_REGOPERATOR PG_REGOPERATORARRAY PG_REGPROC PG_REGPROCARRAY
 PG_REGPROCEDURE PG_REGPROCEDUREARRAY PG_REGTYPE PG_REGTYPEARRAY PG_RELTIME PG_RELTIMEARRAY
 PG_SMGR PG_TEXT PG_TEXTARRAY PG_TID PG_TIDARRAY PG_TIME
 PG_TIMEARRAY PG_TIMESTAMP PG_TIMESTAMPARRAY PG_TIMESTAMPTZ PG_TIMESTAMPTZARRAY PG_TIMETZ
 PG_TIMETZARRAY PG_TINTERVAL PG_TINTERVALARRAY PG_TRIGGER PG_TSQUERY PG_TSQUERYARRAY
 PG_TSVECTOR PG_TSVECTORARRAY PG_TXID_SNAPSHOT PG_TXID_SNAPSHOTARRAY PG_UNKNOWN PG_UUID
 PG_UUIDARRAY PG_VARBIT PG_VARBITARRAY PG_VARCHAR PG_VARCHARARRAY PG_VOID
 PG_XID PG_XIDARRAY PG_XML PG_XMLARRAY</pre>
<p>Data types are &quot;sticky,&quot; in that once a data type is set to a certain placeholder,
it will remain for that placeholder, unless it is explicitly set to something
else afterwards. If the statement has already been prepared, and you switch the
data type to something else, DBD::Pg will re-prepare the statement for you before
doing the next execute.</p>
<p>Examples:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"SELECT id FROM ptable WHERE size &gt; ? AND title = ?"</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Both arguments below are bound to placeholders as "varchar"</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Reset the datatype for the first placeholder to an integer</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">SQL_INTEGER</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## The "undef" bound above is not used, since we supply params to execute</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Set the first placeholder's value and data type</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_TIMESTAMP</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Set the second placeholder's value and data type.</span>
  <span class="comment">## We don't send a third argument, so the default "varchar" is used</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$2'</span><span class="operator">,</span> <span class="string">"Zool"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## We realize that the wrong data type was set above, so we change it:</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$1'</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">SQL_INTEGER</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## We also got the wrong value, so we change that as well.</span>
  <span class="comment">## Because the data type is sticky, we don't need to change it</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">567</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## This executes the statement with 567 (integer) and "Zool" (varchar)</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<p>
</p>
<h3><a name="bind_param_inout"><strong>bind_param_inout</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$scalar</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</pre>
<p>Experimental support for this feature is provided. The first argument to 
bind_param_inout should be a placeholder number. The second argument 
should be a reference to a scalar variable in your script. The third argument 
is not used and should simply be set to 0. Note that what this really does is 
assign a returned column to the variable, in the order in which the column 
appears. For example:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">123</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 1+?::int"</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$foo</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
  <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">222</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">444</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">;</span>
</pre>
<p>The above will cause $foo to have a new value of &quot;223&quot; after the final fetch.
Note that the variables bound in this manner are very sticky, and will trump any 
values passed in to execute. This is because the binding is done as late as possible, 
at the <code>execute()</code> stage, allowing the value to be changed between the time it was bound 
and the time the query is executed. Thus, the above execute is the same as:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<p>
</p>
<h3><a name="bind_param_array"><strong>bind_param_array</strong></a></h3>
<pre>
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, $bind_type)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, \%attr)</pre>
<p>Binds an array of values to a placeholder, so that each is used in turn by a call 
to the <a href="#execute_array">execute_array</a> method.</p>
<p>
</p>
<h3><a name="execute"><strong>execute</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Executes a previously prepared statement. In addition to <code>UPDATE</code>, <code>DELETE</code>,
<code>INSERT</code> statements, for which it returns always the number of affected rows,
the <code>execute</code> method can also be used for <code>SELECT ... INTO table</code> statements.</p>
<p>The &quot;prepare/bind/execute&quot; process has changed significantly for PostgreSQL
servers 7.4 and later: please see the <code>prepare()</code> and <code>bind_param()</code> entries for
much more information.</p>
<p>Setting one of the bind_values to &quot;undef&quot; is the equivalent of setting the value 
to NULL in the database. Setting the bind_value to $DBDPG_DEFAULT is equivalent 
to sending the literal string 'DEFAULT' to the backend. Note that using this 
option will force server-side prepares off until such time as PostgreSQL 
supports using DEFAULT in prepared statements.</p>
<p>DBD::Pg also supports passing in arrays to execute: simply pass in an arrayref, 
and DBD::Pg will flatten it into a string suitable for input on the backend.</p>
<p>If you are using Postgres version 8.2 or greater, you can also use any of the 
fetch methods to retrieve the values of a <code>RETURNING</code> clause after you execute 
an <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code>. For example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{CREATE TABLE abc (id SERIAL, country TEXT)}</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">q{INSERT INTO abc (country) VALUES (?) RETURNING id}</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'France'</span><span class="operator">);</span>
  <span class="variable">$countryid</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'New Zealand'</span><span class="operator">);</span>
  <span class="variable">$countryid</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
</pre>
<p>
</p>
<h3><a name="execute_array"><strong>execute_array</strong></a></h3>
<pre>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<pre>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<p>Execute a prepared statement once for each item in a passed-in hashref, or items that 
were previously bound via the <a href="#bind_param_array">bind_param_array</a> method. See the DBI documentation 
for more details.</p>
<p>
</p>
<h3><a name="execute_for_fetch"><strong>execute_for_fetch</strong></a></h3>
<pre>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
</pre>
<pre>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
</pre>
<p>Used internally by the <a href="#execute_array">execute_array</a> method, and rarely used directly. See the 
DBI documentation for more details.</p>
<p>
</p>
<h3><a name="fetchrow_arrayref"><strong>fetchrow_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_arrayref</span><span class="operator">;</span>
</pre>
<p>Fetches the next row of data from the statement handle, and returns a reference to an array 
holding the column values. Any columns that are NULL are returned as undef within the array.</p>
<p>If there are no more rows or if an error occurs, the this method return undef. You should 
check <code>$sth-&gt;err</code> afterwards (or use the <a href="#raiseerror">RaiseError</a> attribute) to discover if the undef returned 
was due to an error.</p>
<p>Note that the same array reference is returned for each fetch, so don't store the reference and 
then use it after a later fetch. Also, the elements of the array are also reused for each row, 
so take care if you want to take a reference to an element. See also <a href="#bind_columns">bind_columns</a>.</p>
<p>
</p>
<h3><a name="fetchrow_array"><strong>fetchrow_array</strong></a></h3>
<pre>
  <span class="variable">@ary</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">;</span>
</pre>
<p>Similar to the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method, but returns a list of column information rather than 
a reference to a list. Do not use this in a scalar context.</p>
<p>
</p>
<h3><a name="fetchrow_hashref"><strong>fetchrow_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">;</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">);</span>
</pre>
<p>Fetches the next row of data and returns a hashref containing the name of the columns as the keys 
and the data itself as the values. Any NULL value is returned as as undef value.</p>
<p>If there are no more rows or if an error occurs, the this method return undef. You should 
check <code>$sth-&gt;err</code> afterwards (or use the <a href="#raiseerror">RaiseError</a> attribute) to discover if the undef returned 
was due to an error.</p>
<p>The optional <code>$name</code> argument should be either <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a>, <code>NAME_lc</code> or <code>NAME_uc</code>, and indicates 
what sort of transformation to make to the keys in the hash.</p>
<p>
</p>
<h3><a name="fetchall_arrayref"><strong>fetchall_arrayref</strong></a></h3>
<pre>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">();</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span> <span class="operator">);</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span><span class="operator">,</span> <span class="variable">$max_rows</span> <span class="operator">);</span>
</pre>
<p>Returns a reference to an array of arrays that contains all the remaining rows to be fetched from the 
statement handle. If there are no more rows, an empty arrayref will be returned. If an error occurs, 
the data read in so far will be returned. Because of this, you should always check <code>$sth-&gt;err</code> after 
calling this method, unless <a href="#raiseerror">RaiseError</a> has been enabled.</p>
<p>If <code>$slice</code> is an array reference, fetchall_arrayref uses the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method to fetch each 
row as an array ref. If the <code>$slice</code> array is not empty then it is used as a slice to select individual 
columns by perl array index number (starting at 0, unlike column and parameter numbers which start at 1).</p>
<p>With no parameters, or if $slice is undefined, fetchall_arrayref acts as if passed an empty array ref.</p>
<p>If <code>$slice</code> is a hash reference, fetchall_arrayref uses <a href="#fetchrow_hashref">fetchrow_hashref</a> to fetch each row as a hash reference.</p>
<p>See the DBI documentation for a complete discussion.</p>
<p>
</p>
<h3><a name="fetchall_hashref"><strong>fetchall_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_hashref</span><span class="operator">(</span> <span class="variable">$key_field</span> <span class="operator">);</span>
</pre>
<p>Returns a hashref containing all rows to be fetched from the statement handle. See the DBI documentation for 
a full discussion.</p>
<p>
</p>
<h3><a name="finish"><strong>finish</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">;</span>
</pre>
<p>Indicates to DBI that you are finished with the statement handle and are not going to use it again. Only needed 
when you have not fetched all the possible rows.</p>
<p>
</p>
<h3><a name="rows"><strong>rows</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">;</span>
</pre>
<p>Returns the number of rows returned by the last query. In contrast to many other DBD modules, 
the number of rows is available immediately after calling <code>$sth-&gt;execute</code>. Note that 
the <a href="#execute">execute</a> method itself returns the number of rows itself, which means that this 
method is rarely needed.</p>
<p>
</p>
<h3><a name="bind_col"><strong>bind_col</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="variable">$bind_type</span> <span class="operator">);</span>
</pre>
<p>Binds a Perl variable and/or some attributes to an output column of a SELECT statement. 
Column numbers count up from 1. You do not need to bind output columns in order to fetch data.</p>
<p>See the DBI documentation for a discussion of the optional parameters <code>\%attr</code> and <code>$bind_type</code></p>
<p>
</p>
<h3><a name="bind_columns"><strong>bind_columns</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_columns</span><span class="operator">(</span><span class="variable">@list_of_refs_to_vars_to_bind</span><span class="operator">);</span>
</pre>
<p>Calls the <a href="#bind_col">bind_col</a> method for each column in the SELECT statement, using the supplied list.</p>
<p>
</p>
<h3><a name="dump_results"><strong>dump_results</strong></a></h3>
<pre>
  <span class="variable">$rows</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">dump_results</span><span class="operator">(</span><span class="variable">$maxlen</span><span class="operator">,</span> <span class="variable">$lsep</span><span class="operator">,</span> <span class="variable">$fsep</span><span class="operator">,</span> <span class="variable">$fh</span><span class="operator">);</span>
</pre>
<p>Fetches all the rows from the statement handle, calls <code>DBI::neat_list</code> for each row, and 
prints the results to <code>$fh</code> (which defaults to <em class="file">STDOUT</em>). Rows are separated by <code>$lsep</code> (which defaults 
to a newline). Columns are separated by <code>$fsep</code> (which defaults to a comma). The <code>$maxlen</code> controls 
how wide the output can be, and defaults to 35.</p>
<p>This method is designed as a handy utility for prototyping and testing queries. Since it uses 
&quot;neat_list&quot; to format and edit the string for reading by humans, it is not recommended 
for data transfer applications.</p>
<p>
</p>
<h3><a name="blob_read"><strong>blob_read</strong></a></h3>
<pre>
  <span class="variable">$blob</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">blob_read</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</pre>
<p>Supported by DBD::Pg. This method is implemented by DBI but not
currently documented by DBI, so this method might change.</p>
<p>This method seems to be heavily influenced by the current implementation of
blobs in Oracle. Nevertheless we try to be as compatible as possible. Whereas
Oracle suffers from the limitation that blobs are related to tables and every
table can have only one blob (datatype LONG), PostgreSQL handles its blobs
independent of any table by using so-called object identifiers. This explains
why the <code>blob_read</code> method is blessed into the STATEMENT package and not part of
the DATABASE package. Here the field parameter has been used to handle this
object identifier. The offset and len parameters may be set to zero, in which
case the whole blob is fetched at once.</p>
<p>See also the PostgreSQL-specific functions concerning blobs, which are
available via the <code>func</code> interface.</p>
<p>For further information and examples about blobs, please read the chapter
about Large Objects in the PostgreSQL Programmer's Guide at
<a href="http://www.postgresql.org/docs/current/static/largeobjects.html">http://www.postgresql.org/docs/current/static/largeobjects.html</a>.</p>
<p>
</p>
<h2><a name="statement_handle_attributes">Statement Handle Attributes</a></h2>
<p>
</p>
<h3><a name="num_of_fields__integer__read_only_"><strong>NUM_OF_FIELDS</strong> (integer, read-only)</a></h3>
<p>Returns the number of columns returned by the current statement. A number will only be returned for 
SELECT statements, for SHOW statements (which always return <code>1</code>), and for INSERT, 
UPDATE, and DELETE statements which contain a RETURNING clause.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="num_of_params__integer__read_only_"><strong>NUM_OF_PARAMS</strong> (integer, read-only)</a></h3>
<p>Returns the number of placeholders in the current statement.</p>
<p>
</p>
<h3><a name="name__arrayref__read_only_"><strong>NAME</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of column names for the current statement. This 
method will only work for SELECT statements, for SHOW statements, and for 
INSERT, UPDATE, and DELETE statements which contain a RETURNING clause.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="name_lc__arrayref__read_only_"><strong>NAME_lc</strong> (arrayref, read-only)</a></h3>
<p>The same as the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="name_uc__arrayref__read_only_"><strong>NAME_uc</strong>  (arrayref, read-only)</a></h3>
<p>The same as the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, except that all column names are forced to upper case.</p>
<p>
</p>
<h3><a name="name_hash__hashref__read_only_"><strong>NAME_hash</strong> (hashref, read-only)</a></h3>
<p>Similar to the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, but returns a hashref of column names instead of an arrayref. The names of the columns 
are the keys of the hash, and the values represent the order in which the columns are returned, starting at 0.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="name_lc_hash__hashref__read_only_"><strong>NAME_lc_hash</strong> (hashref, read-only)</a></h3>
<p>The same as the <code>NAME_hash</code> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="name_uc_hash__hashref__read_only_"><strong>NAME_uc_hash</strong> (hashref, read-only)</a></h3>
<p>The same as the <code>NAME_hash</code> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="type__arrayref__read_only_"><strong>TYPE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref indicating the data type for each column in the statement. 
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="precision__arrayref__read_only_"><strong>PRECISION</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement. 
The number indicates the precision for <code>NUMERIC</code> columns, the size in number of 
characters for <code>CHAR</code> and <code>VARCHAR</code> columns, and for all other types of columns 
it returns the number of <em>bytes</em>.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="scale__arrayref__read_only_"><strong>SCALE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement. The number 
indicates the scale of the that column. The only type that will return a value is <code>NUMERIC</code>.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="nullable__arrayref__read_only_"><strong>NULLABLE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement. The number 
indicates if the column is nullable or not. 0 = not nullable, 1 = nullable, 2 = unknown. 
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="database__dbh__read_only_"><strong>Database</strong> (dbh, read-only)</a></h3>
<p>Returns the database handle this statement handle was created from.</p>
<p>
</p>
<h3><a name="paramvalues__hash_ref__read_only_"><strong>ParamValues</strong> (hash ref, read-only)</a></h3>
<p>Returns a reference to a hash containing the values currently bound to placeholders. If the &quot;named parameters&quot; 
type of placeholders are being used (such as &quot;:foo&quot;), then the keys of the hash will be the names of the 
placeholders (without the colon). If the &quot;dollar sign numbers&quot; type of placeholders are being used, the keys of the hash will 
be the numbers, without the dollar signs. If the &quot;question mark&quot; type is used, integer numbers will be returned, 
starting at one and increasing for every placeholder.</p>
<p>If this method is called before <a href="#execute">execute</a>, the literal values passed in are returned. If called after 
<a href="#execute">execute</a>, then the quoted versions of the values are returned.</p>
<p>
</p>
<h3><a name="paramtypes__hash_ref__read_only_"><strong>ParamTypes</strong> (hash ref, read-only)</a></h3>
<p>Returns a reference to a hash containing the type names currently bound to placeholders. The keys 
are the same as returned by the ParamValues method. The values are hashrefs containing a single key value 
pair, in which the key is either 'TYPE' if the type has a generic SQL equivalent, and 'pg_type' if the type can 
only be expressed by a Postgres type. The value is the internal number corresponding to the type originally 
passed in. (Placeholders that have not yet been bound will return undef as the value). This allows the output of 
ParamTypes to be passed back to the <a href="#bind_param">bind_param</a> method.</p>
<p>
</p>
<h3><a name="statement__string__read_only_"><strong>Statement</strong> (string, read-only)</a></h3>
<p>Returns the statement string passed to the most recent &quot;prepare&quot; method called in this database handle, even if that method
failed. This is especially useful where &quot;RaiseError&quot; is enabled and the exception handler checks $@ and sees that a <code>prepare</code>
method call failed.</p>
<p>
</p>
<h3><a name="pg_current_row__integer__read_only_"><strong>pg_current_row</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the number of the tuple (row) that was
most recently fetched. Returns zero before and after fetching is performed.</p>
<p>
</p>
<h3><a name="pg_numbound__integer__read_only_"><strong>pg_numbound</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns the number of placeholders
that are currently bound (via bind_param).</p>
<p>
</p>
<h3><a name="pg_bound__hashref__read_only_"><strong>pg_bound</strong> (hashref, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns a hash of all named placeholders. The
key is the name of the placeholder, and the value is a 0 or a 1, indicating if
the placeholder has been bound yet (e.g. via bind_param)</p>
<p>
</p>
<h3><a name="pg_size__arrayref__read_only_"><strong>pg_size</strong> (arrayref, read-only)</a></h3>
<p>DBD::Pg specific attribute. It returns a reference to an array of integer
values for each column. The integer shows the size of the column in
bytes. Variable length columns are indicated by -1.</p>
<p>
</p>
<h3><a name="pg_type__arrayref__read_only_"><strong>pg_type</strong> (arrayref, read-only)</a></h3>
<p>DBD::Pg specific attribute. It returns a reference to an array of strings
for each column. The string shows the name of the data_type.</p>
<p>
</p>
<h3><a name="pg_segments__arrayref__read_only_"><strong>pg_segments</strong> (arrayref, read-only)</a></h3>
<p>DBD::Pg specific attribute. Returns an arrayref of the query split on the 
placeholders.</p>
<p>
</p>
<h3><a name="pg_oid_status__integer__read_only_"><strong>pg_oid_status</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. It returns the OID of the last INSERT command.</p>
<p>
</p>
<h3><a name="pg_cmd_status__integer__read_only_"><strong>pg_cmd_status</strong> (integer, read-only)</a></h3>
<p>DBD::Pg specific attribute. It returns the type of the last
command. Possible types are: &quot;INSERT&quot;, &quot;DELETE&quot;, &quot;UPDATE&quot;, &quot;SELECT&quot;.</p>
<p>
</p>
<h3><a name="pg_direct__boolean_"><strong>pg_direct</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Default is false. If true, the query is passed 
directly to the backend without parsing for placeholders.</p>
<p>
</p>
<h3><a name="pg_prepare_now__boolean_"><strong>pg_prepare_now</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Default is off. If true, the query will be immediately 
prepared, rather than waiting for the <a href="#execute">execute</a> call.</p>
<p>
</p>
<h3><a name="pg_prepare_name__string_"><strong>pg_prepare_name</strong> (string)</a></h3>
<p>DBD::Pg specific attribute. Specifies the name of the prepared statement to use for this 
statement handle. Not normally needed, see the section on the <a href="#prepare">prepare</a> method for 
more information.</p>
<p>
</p>
<h3><a name="pg_server_prepare__integer_"><strong>pg_server_prepare</strong> (integer)</a></h3>
<p>DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side 
prepared statements for this statement handle. The default value, 1, indicates that prepared 
statements should be used whenever possible. See the section on the <a href="#prepare">prepare</a> method for 
more information.</p>
<p>
</p>
<h3><a name="pg_placeholder_dollaronly__boolean_"><strong>pg_placeholder_dollaronly</strong> (boolean)</a></h3>
<p>DBD::Pg specific attribute. Defaults to off. When true, question marks inside of the query 
being prepared are not treated as placeholders. Useful for statements that contain unquoted question 
marks, such as geometric operators.</p>
<p>
</p>
<h3><a name="pg_async__integer_"><strong>pg_async</strong> (integer)</a></h3>
<p>DBD::Pg specific attribute. Indicates the current behavior for asynchronous queries. See the section 
on <a href="#asynchronous_constants">Asynchronous Constants</a> for more information.</p>
<p>
</p>
<h3><a name="rowsincache"><strong>RowsInCache</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<h3><a name="rowcache"><strong>RowCache</strong></a></h3>
<p>Not used by DBD::Pg</p>
<p>
</p>
<h3><a name="cursorname"><strong>CursorName</strong></a></h3>
<p>Not used by DBD::Pg. See the note about <a href="#cursors">Cursors</a> elsewhere in this document.</p>
<p>
</p>
<hr />
<h1><a name="further_information">FURTHER INFORMATION</a></h1>
<p>
</p>
<h2><a name="transactions">Transactions</a></h2>
<p>Transaction behavior is controlled via the <a href="#autocommit">AutoCommit</a> attribute. For a
complete definition of <code>AutoCommit</code> please refer to the DBI documentation.</p>
<p>According to the DBI specification the default for <code>AutoCommit</code> is a true
value. In this mode, any change to the database becomes valid immediately. Any
<code>BEGIN</code>, <code>COMMIT</code> or <code>ROLLBACK</code> statements will be rejected. DBD::Pg
implements <code>AutoCommit</code> by issuing a <code>BEGIN</code> statement immediately before
executing a statement, and a <code>COMMIT</code> afterwards. Note that preparing a 
statement is not always enough to trigger the first <code>BEGIN</code>, as the actual 
<code>PREPARE</code> is usually postponed until the first call to <a href="#execute">execute</a>.</p>
<p>
</p>
<h2><a name="savepoints">Savepoints</a></h2>
<p>PostgreSQL version 8.0 introduced the concept of savepoints, which allows 
transactions to be rolled back to a certain point without affecting the 
rest of the transaction. DBD::Pg encourages using the following methods to 
control savepoints:</p>
<p>
</p>
<h3><a name="pg_savepoint"><code>pg_savepoint</code></a></h3>
<p>Creates a savepoint. This will fail unless you are inside of a transaction. The 
only argument is the name of the savepoint. Note that PostgreSQL DOES allow 
multiple savepoints with the same name to exist.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_savepoint</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="pg_rollback_to"><code>pg_rollback_to</code></a></h3>
<p>Rolls the database back to a named savepoint, discarding any work performed after 
that point. If more than one savepoint with that name exists, rolls back to the 
most recently created one.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_rollback_to</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="pg_release"><code>pg_release</code></a></h3>
<p>Releases (or removes) a named savepoint. If more than one savepoint with that name 
exists, it will only destroy the most recently created one. Note that all savepoints 
created after the one being released are also destroyed.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_release</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="asynchronous_queries">Asynchronous Queries</a></h2>
<p>It is possible to send a query to the backend and have your script do other work while the query is 
running on the backend. Both queries sent by the <a href="../../lib/pods/perlfunc.html#do">do</a> method, and by the <a href="#execute">execute</a> method can be 
sent asynchronously. (NOTE: This will only work if DBD::Pg has been compiled against Postgres libraries 
of version 8.0 or greater) The basic usage is as follows:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="string">"Async do() example:\n"</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"SELECT long_running_query()"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">do_something_else</span><span class="operator">();</span>
  <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">())</span> <span class="operator">{</span>
      <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">pg_result</span><span class="operator">();</span>
      <span class="keyword">print</span> <span class="string">"Result of do(): </span><span class="variable">$res</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">print</span> <span class="string">"Query is still running...\n"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">cancel_request_received</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="operator">}</span>
    <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">redo</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="string">"Async prepare/execute example:\n"</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT long_running_query(1)"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<pre>
  <span class="comment">## Changed our mind, cancel and run again:</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 678"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span> <span class="operator">+</span> <span class="variable">PG_OLDQUERY_CANCEL</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<pre>
  <span class="variable">do_something_else</span><span class="operator">();</span>
</pre>
<pre>
  <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">do_another_thing</span><span class="operator">();</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="comment">## We wait until it is done, and get the result:</span>
  <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
</pre>
<p>
</p>
<h3><a name="asynchronous_constants">Asynchronous Constants</a></h3>
<p>There are currently three asynchronous constants exported by DBD::Pg. You can import all of them by putting 
either of these at the top of your script:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
</pre>
<p>You may also use the numbers instead of the constants, but using the constants is recommended as it 
makes your script more readable.</p>
<dl>
<dt><strong><a name="pg_async" class="item">PG_ASYNC</a></strong></dt>

<dd>
<p>This is a constant for the number 1. It is passed to either the <a href="../../lib/pods/perlfunc.html#do">do</a> or the <a href="#prepare">prepare</a> method as a value 
to the pg_async key and indicates that the query should be sent asynchronously.</p>
</dd>
<dt><strong><a name="pg_oldquery_cancel" class="item">PG_OLDQUERY_CANCEL</a></strong></dt>

<dd>
<p>This is a constant for the number 2. When passed to either the <a href="../../lib/pods/perlfunc.html#do">do</a> or the <a href="#prepare">prepare</a> method, it causes any 
currently running asynchronous query to be cancelled and rolled back. It has no effect if no asynchronous 
query is currently running.</p>
</dd>
<dt><strong><a name="pg_oldquery_wait" class="item">PG_OLDQUERY_WAIT</a></strong></dt>

<dd>
<p>This is a constant for the number 4. When passed to either the <a href="../../lib/pods/perlfunc.html#do">do</a> or the <a href="#prepare">prepare</a> method, it waits for any 
currently running asynchronous query to complete. It has no effect if there is no asynchronous query currently running.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="asynchronous_methods">Asynchronous Methods</a></h3>
<dl>
<dt><strong><a name="pg_cancel" class="item"><strong>pg_cancel</strong></a></strong></dt>

<dd>
<p>This database-level method attempts to cancel any currently running asynchronous query. It returns true if 
the cancel succeeded, and false otherwise. Note that a query that has finished before this method is executed 
will also return false. <strong>WARNING</strong>: a successful cancellation may leave the database in an unusable state, 
so you may need to ROLLBACK or ROLLBACK TO a savepoint. As of version 2.17.0 of DBD::Pg, rollbacks are 
not done automatically.</p>
<pre>
  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
</pre>
</dd>
<dt><strong><a name="pg_ready" class="item"><strong>pg_ready</strong></a></strong></dt>

<dd>
<p>This method can be called as a database handle method or (for convenience) as a statement handle method. Both simply 
see if a previously issued asynchronous query has completed yet. It returns true if the statement has finished, in which 
case you should then call the <a href="#pg_result">pg_result</a> method. Calls to <a href="#pg_ready"><code>pg_ready()</code></a> should only be used when you have other 
things to do while the query is running. If you simply want to wait until the query is done, do not call <a href="#pg_ready"><code>pg_ready()</code></a>
over and over, but simply call the <a href="#pg_result"><code>pg_result()</code></a> method.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$time</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(!</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Query is still running. Seconds: </span><span class="variable">$time</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="variable">$time</span><span class="operator">++;</span>
    <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
</pre>
</dd>
<dt><strong><a name="pg_result" class="item"><strong>pg_result</strong></a></strong></dt>

<dd>
<p>This database handle method returns the results of a previously issued asynchronous query. If the query is still 
running, this method will wait until it has finished. The result returned is the number of rows: the same thing 
that would have been returned by the asynchronous <a href="../../lib/pods/perlfunc.html#do">do</a> or <a href="#execute">execute</a> if it had been called without an asynchronous flag.</p>
<pre>
  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
</pre>
</dd>
</dl>
<p>
</p>
<h3><a name="asynchronous_examples">Asynchronous Examples</a></h3>
<p>Here are some working examples of asynchronous queries. Note that we'll use the <strong>pg_sleep</strong> function to emulate a 
long-running query.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Time::HiRes</span> <span class="string">'sleep'</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Kick off a long running query on the first database:</span>
  <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT pg_sleep(?)"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## While that is running, do some other things</span>
  <span class="keyword">print</span> <span class="string">"Your query is processing. Thanks for waiting\n"</span><span class="operator">;</span>
  <span class="variable">check_on_the_kids</span><span class="operator">();</span> <span class="comment">## Expensive sub, takes at least three seconds.</span>
</pre>
<pre>
  <span class="keyword">while</span> <span class="operator">(!</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">check_on_the_kids</span><span class="operator">();</span>
    <span class="comment">## If the above function returns quickly for some reason, we add a small sleep</span>
    <span class="keyword">sleep</span> <span class="number">0</span><span class="operator">.</span><span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="string">"The query has finished. Gathering results\n"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"Result: </span><span class="variable">$result</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$info</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">();</span>
</pre>
<p>Without asynchronous queries, the above script would take about 8 seconds to run: five seconds waiting 
for the execute to finish, then three for the <code>check_on_the_kids()</code> function to return. With asynchronous 
queries, the script takes about 6 seconds to run, and gets in two iterations of check_on_the_kids in 
the process.</p>
<p>Here's an example showing the ability to cancel a long-running query. Imagine two slave databases in 
different geographic locations over a slow network. You need information as quickly as possible, so 
you query both at once. When you get an answer, you tell the other one to stop working on your query, 
as you don't need it anymore.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Time::HiRes</span> <span class="string">'sleep'</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbhslave1</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres;host=slave1'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$dbhslave2</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres;host=slave2'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"SELECT count(*) FROM largetable WHERE flavor='blueberry'"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbhslave1</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span> <span class="operator">=</span> <span class="variable">$dbhslave2</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$winner</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(!</span><span class="keyword">defined</span> <span class="variable">$winner</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$winner</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$winner</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">Time::HiRes::sleep</span> <span class="number">0</span><span class="operator">.</span><span class="number">05</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$count</span><span class="operator">;</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$winner</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">][</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">else</span> <span class="operator">{</span>
    <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">][</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<h2><a name="array_support">Array support</a></h2>
<p>DBD::Pg allows arrays (as arrayrefs) to be passed in to both 
the <a href="#quote">quote</a> and the <a href="#execute">execute</a> methods. In both cases, the array is 
flattened into a string representing a Postgres array.</p>
<p>When fetching rows from a table that contains a column with an 
array type, the result will be passed back to your script as an arrayref.</p>
<p>To turn off the automatic parsing of returned arrays into arrayrefs, 
you can set the attribute <a href="#pg_expand_array__boolean_">pg_expand_array</a>, which is true by default.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_expand_array</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
<p>
</p>
<h2><a name="copy_support">COPY support</a></h2>
<p>DBD::Pg allows for quick (bulk) reading and storing of data by using 
the <strong>COPY</strong> command. The basic process is to use <a href="../../lib/pods/perlfunc.html#do"><code>$dbh-&gt;do</code></a> to issue a 
COPY command, and then to either add rows using <a href="#pg_putcopydata">pg_putcopydata</a>, or to 
read them by using <a href="#pg_getcopydata">pg_getcopydata</a>.</p>
<p>The first step is to put the server into &quot;COPY&quot; mode. This is done by 
sending a complete COPY command to the server, by using the <a href="../../lib/pods/perlfunc.html#do">do</a> method. 
For example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY foobar FROM STDIN"</span><span class="operator">);</span>
</pre>
<p>This would tell the server to enter a COPY IN mode (yes, that's confusing, but 
the <em>mode</em> is COPY IN because of the <em>command</em> COPY FROM). It is now ready to 
receive information via the <a href="#pg_putcopydata">pg_putcopydata</a> method. The complete syntax of the 
COPY command is more complex and not documented here: the canonical 
PostgreSQL documentation for COPY can be found at:</p>
<p><a href="http://www.postgresql.org/docs/current/static/sql-copy.html">http://www.postgresql.org/docs/current/static/sql-copy.html</a></p>
<p>Once a COPY command has been issued, no other SQL commands are allowed 
until <a href="#pg_putcopyend">pg_putcopyend</a> has been issued (for COPY FROM), or the final 
<a href="#pg_getcopydata">pg_getcopydata</a> has been called (for COPY TO).</p>
<p>Note: All other COPY methods (pg_putline, pg_getline, etc.) are now 
heavily deprecated in favor of the pg_getcopydata, pg_putcopydata, and 
pg_putcopyend methods.</p>
<p>
</p>
<h3><a name="pg_getcopydata"><strong>pg_getcopydata</strong></a></h3>
<p>Used to retrieve data from a table after the server has been put into a 
COPY OUT mode by calling &quot;COPY tablename TO STDOUT&quot;. Data is always returned 
one data row at a time. The first argument to pg_getcopydata 
is the variable into which the data will be stored (this variable should not 
be undefined, or it may throw a warning, although it may be a reference). The 
pg_gecopydata method returns a number greater than 1 indicating the new size of 
the variable, or a -1 when the COPY has finished. Once a -1 has been returned, no 
other action is necessary, as COPY mode will have already terminated. Example:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable TO STDOUT"</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@data</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$x</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span>
  <span class="number">1</span> <span class="keyword">while</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_getcopydata</span><span class="operator">(</span><span class="variable">$data</span><span class="operator">[</span><span class="variable">$x</span><span class="operator">++</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="number">0</span><span class="operator">;</span>
</pre>
<p>There is also a variation of this method called <strong>pg_getcopydata_async</strong>, which, 
as the name suggests, returns immediately. The only difference from the original 
method is that this version may return a 0, indicating that the row is not 
ready to be delivered yet. When this happens, the variable has not been changed, 
and you will need to call the method again until you get a non-zero result.
(Data is still always returned one data row at a time.)</p>
<p>
</p>
<h3><a name="pg_putcopydata"><strong>pg_putcopydata</strong></a></h3>
<p>Used to put data into a table after the server has been put into COPY IN mode 
by calling &quot;COPY tablename FROM STDIN&quot;. The only argument is the data you want 
inserted. Issue a <code>pg_putcopyend()</code> when you have added all your rows.</p>
<p>The default delimiter is a tab character, but this can be changed in 
the COPY statement. Returns a 1 on successful input. Examples:</p>
<pre>
  <span class="comment">## Simple example:</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable FROM STDIN"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"123\tPepperoni\t3\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"314\tMushroom\t8\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"6\tAnchovies\t100\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopyend</span><span class="operator">();</span>
</pre>
<pre>
  <span class="comment">## This example uses explicit columns and a custom delimiter</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable(flavor, slices) FROM STDIN WITH DELIMITER '~'"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Pepperoni~123\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Mushroom~314\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Anchovies~6\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopyend</span><span class="operator">();</span>
</pre>
<p>
</p>
<h3><a name="pg_putcopyend"><strong>pg_putcopyend</strong></a></h3>
<p>When you are finished with pg_putcopydata, call pg_putcopyend to let the server know 
that you are done, and it will return to a normal, non-COPY state. Returns a 1 on 
success. This method will fail if called when not in COPY IN mode.</p>
<p>
</p>
<h2><a name="large_objects">Large Objects</a></h2>
<p>DBD::Pg supports all largeobject functions provided by libpq via the
<code>$dbh-&gt;pg_lo*</code> methods. Please note that access to a large object, even read-only 
large objects, must be put into a transaction.</p>
<p>
</p>
<h2><a name="cursors">Cursors</a></h2>
<p>Although PostgreSQL supports cursors, they have not been used in the current
implementation. When DBD::Pg was created, cursors in PostgreSQL could only be
used inside a transaction block. Because only one transaction block at a time
is allowed, this would have implied the restriction not to use any nested
<code>SELECT</code> statements. Therefore the <a href="#execute">execute</a> method fetches all data at
once into data structures located in the front-end application. This fact
must to be considered when selecting large amounts of data!</p>
<p>You can use cursors in your application, but you'll need to do a little
work. First you must declare your cursor. Now you can issue queries against
the cursor, then select against your queries. This typically results in a
double loop, like this:</p>
<pre>
  <span class="comment"># WITH HOLD is not needed if AutoCommit is off</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"DECLARE csr CURSOR WITH HOLD FOR </span><span class="variable">$sql</span><span class="string">"</span><span class="operator">);</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"fetch 1000 from csr"</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">last</span> <span class="keyword">if</span> <span class="number">0</span> <span class="operator">==</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$row</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="comment"># Do something with the data.</span>
    <span class="operator">}</span>
      <span class="operator">}</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CLOSE csr"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="datatype_bool">Datatype bool</a></h2>
<p>The current implementation of PostgreSQL returns 't' for true and 'f' for
false. From the Perl point of view, this is a rather unfortunate
choice. DBD::Pg therefore translates the result for the <code>BOOL</code> data type in a
Perlish manner: 'f' becomes the number <code>0</code> and 't' becomes the number <code>1</code>. This way 
the application does not have to check the database-specific returned values for 
the data-type <code>BOOL</code> because Perl treats <code>0</code> as false and <code>1</code> as true. You may 
set the <a href="#pg_bool_tf__boolean_">pg_bool_tf</a> attribute to a true value to change the values back to 't' and
'f' if you wish.</p>
<p>Boolean values can be passed to PostgreSQL as TRUE, 't', 'true', 'y', 'yes' or
'1' for true and FALSE, 'f', 'false', 'n', 'no' or '0' for false.</p>
<p>
</p>
<h2><a name="schema_support">Schema support</a></h2>
<p>The PostgreSQL schema concept may differ from those of other databases. In a nutshell,
a schema is a named collection of objects within a single database. Please refer to the
PostgreSQL documentation for more details:</p>
<p><a href="http://www.postgresql.org/docs/current/static/ddl-schemas.html">http://www.postgresql.org/docs/current/static/ddl-schemas.html</a></p>
<p>DBD::Pg does not provide explicit support for PostgreSQL schemas.
However, schema functionality may be used without any restrictions by
explicitly addressing schema objects, e.g.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="string">"SELECT * FROM my_schema.my_table"</span><span class="operator">);</span>
</pre>
<p>or by manipulating the schema search path with <code>SET search_path</code>, e.g.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"SET search_path TO my_schema, public"</span><span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<a href="http://search.cpan.org/~timb/DBI/DBI.pm">The DBI module</a><p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>To report a bug, or view the current list of bugs, please visit 
<a href="http://rt.cpan.org/Public/Dist/Display.html?Name=DBD-Pg">http://rt.cpan.org/Public/Dist/Display.html?Name=DBD-Pg</a></p>
<p>
</p>
<hr />
<h1><a name="authors">AUTHORS</a></h1>
<p>DBI by Tim Bunce <a href="http://www.tim.bunce.name">http://www.tim.bunce.name</a></p>
<p>The original DBD-Pg was by Edmund Mergl (<a href="mailto:E.Mergl@bawue.de">E.Mergl@bawue.de</a>) and Jeffrey W. Baker
(<a href="mailto:jwbaker@acm.org">jwbaker@acm.org</a>) Major developers include David Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;, Jason
Stewart &lt;<a href="mailto:jason@openinformatics.com">jason@openinformatics.com</a>&gt;, Bruce Momjian &lt;<a href="mailto:pgman@candle.pha.pa.us">pgman@candle.pha.pa.us</a>&gt;, and 
Greg Sabino Mullane &lt;<a href="mailto:greg@turnstep.com">greg@turnstep.com</a>&gt;, with help from many others: see the <em class="file">Changes</em>
file for a complete list.</p>
<p>Parts of this package were originally copied from DBI and DBD-Oracle.</p>
<p><strong>Mailing List</strong></p>
<p>The current maintainers may be reached through the 'dbd-pg' mailing list:
&lt;<a href="mailto:dbd-pg@perl.org">dbd-pg@perl.org</a>&gt;</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright (C) 1994-2011, Greg Sabino Mullane</p>
<p>This module (DBD::Pg) is free software; you can redistribute it and/or modify it 
under the same terms as Perl 5.10.0. For more details, see the full text of the 
licenses in the directory LICENSES.</p>

</body>

</html>
