<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>DBD::ODBC - ODBC Driver for DBI</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>DBD::ODBC - ODBC Driver for DBI</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#change_log_and_faqs">Change log and FAQs</a></li>
		<li><a href="#important_note_about_the_tests">Important note about the tests</a></li>
		<li><a href="#version_control">Version Control</a></li>
		<li><a href="#contributing">Contributing</a></li>
		<li><a href="#dbi_attribute_handling">DBI attribute handling</a></li>
		<ul>

			<li><a href="#readonly__boolean_">ReadOnly (boolean)</a></li>
		</ul>

		<li><a href="#private_attributes_common_to_connection_and_statement_handles">Private attributes common to connection and statement handles</a></li>
		<ul>

			<li><a href="#odbc_ignore_named_placeholders">odbc_ignore_named_placeholders</a></li>
			<li><a href="#odbc_default_bind_type">odbc_default_bind_type</a></li>
			<li><a href="#odbc_force_bind_type">odbc_force_bind_type</a></li>
			<li><a href="#odbc_force_rebind">odbc_force_rebind</a></li>
			<li><a href="#odbc_async_exec">odbc_async_exec</a></li>
			<li><a href="#odbc_query_timeout">odbc_query_timeout</a></li>
			<li><a href="#odbc_putdata_start">odbc_putdata_start</a></li>
			<li><a href="#odbc_column_display_size">odbc_column_display_size</a></li>
			<li><a href="#odbc_utf8_on">odbc_utf8_on</a></li>
			<li><a href="#odbc_old_unicode">odbc_old_unicode</a></li>
			<li><a href="#odbc_describe_parameters">odbc_describe_parameters</a></li>
		</ul>

		<li><a href="#private_connection_attributes">Private connection attributes</a></li>
		<ul>

			<li><a href="#odbc_err_handler">odbc_err_handler</a></li>
			<li><a href="#odbc_sql_rowset_size">odbc_SQL_ROWSET_SIZE</a></li>
			<li><a href="#odbc_exec_direct">odbc_exec_direct</a></li>
			<li><a href="#odbc_sql_driver_odbc_ver">odbc_SQL_DRIVER_ODBC_VER</a></li>
			<li><a href="#odbc_cursortype">odbc_cursortype</a></li>
			<li><a href="#odbc_has_unicode">odbc_has_unicode</a></li>
			<li><a href="#odbc_out_connect_string">odbc_out_connect_string</a></li>
			<li><a href="#odbc_version">odbc_version</a></li>
		</ul>

		<li><a href="#private_statement_methods">Private statement methods</a></li>
		<ul>

			<li><a href="#odbc_lob_read">odbc_lob_read</a></li>
		</ul>

		<li><a href="#private_statement_attributes">Private statement attributes</a></li>
		<ul>

			<li><a href="#odbc_more_results">odbc_more_results</a></li>
		</ul>

		<li><a href="#private_dbd__odbc_functions">Private DBD::ODBC Functions</a></li>
		<ul>

			<li><a href="#getinfo">GetInfo</a></li>
			<li><a href="#sqlgettypeinfo">SQLGetTypeInfo</a></li>
			<li><a href="#getfunctions">GetFunctions</a></li>
			<li><a href="#getstatistics">GetStatistics</a></li>
			<li><a href="#getforeignkeys">GetForeignKeys</a></li>
			<li><a href="#getprimarykeys">GetPrimaryKeys</a></li>
			<li><a href="#data_sources">data_sources</a></li>
			<li><a href="#getspecialcolumns">GetSpecialColumns</a></li>
			<li><a href="#colattributes">ColAttributes</a></li>
			<li><a href="#describecol">DescribeCol</a></li>
		</ul>

		<li><a href="#additional_bind_col_attributes">Additional bind_col attributes</a></li>
		<ul>

			<li><a href="#discardstring">DiscardString</a></li>
			<li><a href="#strictlytyped">StrictlyTyped</a></li>
			<li><a href="#treataslob">TreatAsLOB</a></li>
		</ul>

		<li><a href="#tracing">Tracing</a></li>
		<li><a href="#deviations_from_the_dbi_specification">Deviations from the DBI specification</a></li>
		<ul>

			<li><a href="#last_insert_id">last_insert_id</a></li>
			<li><a href="#comments_in_sql">Comments in SQL</a></li>
			<li><a href="#do">do</a></li>
			<li><a href="#mixed_placeholder_types">Mixed placeholder types</a></li>
			<li><a href="#using_the_same_placeholder_more_than_once">Using the same placeholder more than once</a></li>
			<li><a href="#binding_named_placeholders">Binding named placeholders</a></li>
			<li><a href="#sticky_parameter_types">Sticky Parameter Types</a></li>
			<li><a href="#disconnect_and_transactions">disconnect and transactions</a></li>
		</ul>

		<li><a href="#unicode">Unicode</a></li>
		<ul>

			<li><a href="#enabling_and_disabling_unicode_support">Enabling and Disabling Unicode support</a></li>
			<li><a href="#unicode___what_is_supported">Unicode - What is supported?</a></li>
			<li><a href="#unicode___what_is_not_supported">Unicode - What is not supported?</a></li>
			<li><a href="#unicode___caveats">Unicode - Caveats</a></li>
			<li><a href="#unicode_implementation_in_dbd__odbc">Unicode implementation in DBD::ODBC</a></li>
			<li><a href="#unicode_and_oracle">Unicode and Oracle</a></li>
			<li><a href="#unicode_and_postgresql">Unicode and PostgreSQL</a></li>
			<li><a href="#unicode_and_easysoft_odbc_drivers">Unicode and Easysoft ODBC Drivers</a></li>
			<li><a href="#unicode_and_other_odbc_drivers">Unicode and other ODBC drivers</a></li>
		</ul>

		<li><a href="#odbc_support_in_odbc_drivers">ODBC Support in ODBC Drivers</a></li>
		<ul>

			<li><a href="#drivers_without_sqldescribeparam">Drivers without SQLDescribeParam</a></li>
		</ul>

		<li><a href="#cpan_testers_reporting">CPAN Testers Reporting</a></li>
		<li><a href="#others_todo">Others/todo?</a></li>
		<li><a href="#random_links">Random Links</a></li>
		<li><a href="#frequently_asked_questions">Frequently Asked Questions</a></li>
	</ul>

	<li><a href="#configuration_and_environment">CONFIGURATION AND ENVIRONMENT</a></li>
	<li><a href="#dependencies">DEPENDENCIES</a></li>
	<li><a href="#incompatibilities">INCOMPATIBILITIES</a></li>
	<li><a href="#bugs_and_limitations">BUGS AND LIMITATIONS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#license_and_copyright">LICENSE AND COPYRIGHT</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>DBD::ODBC - ODBC Driver for DBI</p>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>This documentation refers to DBD::ODBC version 1.31.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:ODBC:DSN'</span><span class="operator">,</span> <span class="string">'user'</span><span class="operator">,</span> <span class="string">'password'</span><span class="operator">);</span>
</pre>
<p>See <a href="../../lib/DBI.html">the DBI manpage</a> for more information.</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>
</p>
<h2><a name="change_log_and_faqs">Change log and FAQs</a></h2>
<p>Please note that the change log has been moved to
DBD::ODBC::Changes. To access this documentation, use
<code>perldoc DBD::ODBC::Changes</code>.</p>
<p>The FAQs have also moved to DBD::ODBC::FAQ.pm. To access the FAQs use
<code>perldoc DBD::ODBC::FAQ</code>.</p>
<p>
</p>
<h2><a name="important_note_about_the_tests">Important note about the tests</a></h2>
<p>Please note that some tests may fail or report they are unsupported on
this platform.  Notably Oracle's ODBC driver will fail the &quot;advanced&quot;
binding tests in t/08bind2.t.  These tests run perfectly under SQL
Server 2000. This is normal and expected.  Until Oracle fixes their
drivers to do the right thing from an ODBC perspective, it's going to
be tough to fix the issue.  The workaround for Oracle is to bind date
types with SQL_TIMESTAMP.  Also note that some tests may be skipped,
such as t/09multi.t, if your driver doesn't seem to support returning
multiple result sets.  This is normal.</p>
<p>
</p>
<h2><a name="version_control">Version Control</a></h2>
<p>DBD::ODBC source code is under version control at svn.perl.org.  If
you would like to use the &quot;bleeding&quot; edge version, you can get the
latest from svn.perl.org via Subversion version control.  Note there
is no guarantee that this version is any different than what you get
from the tarball from CPAN, but it might be :)</p>
<p>You may read about Subversion at <a href="http://subversion.tigris.org">http://subversion.tigris.org</a></p>
<p>You can get a subversion client from there and check dbd-odbc out via:</p>
<pre>
   svn checkout <a href="http://svn.perl.org/modules/dbd-odbc/trunk">http://svn.perl.org/modules/dbd-odbc/trunk</a> &lt;your directory name here&gt;</pre>
<p>Which will pull all the files from the subversion trunk to your
specified directory. If you want to see what has changed since the
last release of DBD::ODBC read the Changes file or use &quot;svn log&quot; to
get a list of checked in changes.</p>
<p>
</p>
<h2><a name="contributing">Contributing</a></h2>
<p>There are seven main ways you may help with the development and
maintenance of this module:</p>
<dl>
<dt><strong><a name="submitting_patches" class="item">Submitting patches</a></strong></dt>

<dd>
<p>Please use Subversion (see above) to get the latest version of
DBD::ODBC from the trunk and submit any patches against that.</p>
<p>Please, before submitting a patch:</p>
<pre>
   svn update
   &lt;try and included a test which demonstrates the fix/change working&gt;
   &lt;test your patch&gt;
   svn diff &gt; describe_my_diffs.patch</pre>
<p>and send the resulting file to me and cc the <a href="mailto:dbi-users@perl.org">dbi-users@perl.org</a>
mailing list (if you are not a member - why not!).</p>
</dd>
<dt><strong><a name="reporting_installs" class="item">Reporting installs</a></strong></dt>

<dd>
<p>Install CPAN::Reporter and report you installations. This is easy to
do - see <a href="#cpan_testers_reporting">CPAN Testers Reporting</a>.</p>
</dd>
<dt><strong><a name="report_bugs" class="item">Report bugs</a></strong></dt>

<dd>
<p>If you find what you believe is a bug then enter it into the
<a href="http://rt.cpan.org/Dist/Display.html?Name=DBD-ODBC">http://rt.cpan.org/Dist/Display.html</a> system. Where
possible include code which reproduces the problem including any
schema required and the versions of software you are using.</p>
<p>If you are unsure whether you have found a bug report it anyway or
post it to the dbi-users mailing list.</p>
</dd>
<dt><strong><a name="pod_comments_and_corrections" class="item">pod comments and corrections</a></strong></dt>

<dd>
<p>If you find inaccuracies in the DBD::ODBC pod or have a comment which
you think should be added then go to <a href="http://annocpan.org">http://annocpan.org</a> and submit
them there. I get an email for every comment added and will review
each one and apply any changes to the documentation.</p>
</dd>
<dt><strong><a name="review_dbd_odbc" class="item">Review DBD::ODBC</a></strong></dt>

<dd>
<p>Add your review of DBD::ODBC on <a href="http://cpanratings.perl.org">http://cpanratings.perl.org</a>.</p>
<p>If you are a member on ohloh then add your review or register your
use of DBD::ODBC at <a href="http://www.ohloh.net/projects/perl_dbd_odbc">http://www.ohloh.net/projects/perl_dbd_odbc</a>.</p>
</dd>
<dt><strong><a name="submit_test_cases" class="item">submit test cases</a></strong></dt>

<dd>
<p>Most DBDs are built against a single client library for the database.</p>
<p>Unlike other DBDs, DBD::ODBC works with many different ODBC drivers.
Although they all should be written with regard to the ODBC
specification drivers have bugs and in some places the specification is
open to interpretation. As a result, when changes are applied to
DBD::ODBC it is very easy to break something in one ODBC driver.</p>
<p>What helps enormously to identify problems in the many combinations
of DBD::ODBC and ODBC drivers is a large test suite. I would greatly
appreciate any test cases and in particular any new test cases for
databases other than MS SQL Server.</p>
</dd>
<dt><strong><a name="test_dbd_odbc" class="item">Test DBD::ODBC</a></strong></dt>

<dd>
<p>I have a lot of problems deciding when to move a development release
to an official release since I get few test reports for development
releases. What often happens is I call for testers on various lists,
get a few and then get inundated with requests to do an official
release. Then I do an official release and loads of rts appear out of
nowhere and the cycle starts again.</p>
<p>DBD::ODBC by its very nature works with many ODBC Drivers and it is
impossible for me to have and test them all (this differs from other
DBDs). If you depend on DBD::ODBC you should be interested in new
releases and if you send me your email address suggesting you are
prepared to be part of the DBD::ODBC testing network I will credit you
in the Changes file and perhaps the main DBD::ODBC file.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="dbi_attribute_handling">DBI attribute handling</a></h2>
<p>If a DBI defined attribute is not mentioned here it behaves as per the
DBI specification.</p>
<p>
</p>
<h3><a name="readonly__boolean_">ReadOnly (boolean)</a></h3>
<p>DBI documents the <code>ReadOnly</code> attribute as being settleable and
retrievable on connection and statement handles. In ODBC setting
ReadOnly to true causes the connection attribute <code>SQL_ATTR_ACCESS_MODE</code>
to be set to <code>SQL_MODE_READ_ONLY</code> and setting it to false will set the
access mode to <code>SQL_MODE_READ_WRITE</code> (which is the default in ODBC).</p>
<p><strong>Note:</strong> There is no equivalent of setting ReadOnly on a statement
handle in ODBC.</p>
<p><strong>Note:</strong> See ODBC documentation on <code>SQL_ATTR_ACCESS_MODE</code> as setting it
to <code>SQL_MODE_READ_ONLY</code> does <strong>not</strong> prevent your script from running
updates or deletes; it is simply a hint to the driver/database that
you won't being doing updates.</p>
<p>This attribute requires DBI version 1.55 or better.</p>
<p>
</p>
<h2><a name="private_attributes_common_to_connection_and_statement_handles">Private attributes common to connection and statement handles</a></h2>
<p>
</p>
<h3><a name="odbc_ignore_named_placeholders">odbc_ignore_named_placeholders</a></h3>
<p>Use this if you have special needs (such as Oracle triggers, etc)
where :new or :name mean something special and are not just place
holder names. You <em>must</em> then use ? for binding parameters.  Example:</p>
<pre>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_ignore_named_placeholders</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"create trigger foo as if :new.x &lt;&gt; :old.x then ... etc"</span><span class="operator">);</span>
</pre>
<p>Without this, DBD::ODBC will think :new and :old are placeholders for
binding and get confused.</p>
<p>
</p>
<h3><a name="odbc_default_bind_type">odbc_default_bind_type</a></h3>
<p>This value defaults to 0.</p>
<p>Older versions of DBD::ODBC assumed that the parameter binding type
was 12 (<code>SQL_VARCHAR</code>).  Newer versions always attempt to call
<code>SQLDescribeParam</code> to find the parameter types but if
<code>SQLDescribeParam</code> is unavailable DBD::ODBC falls back to a default
bind type. The internal default bind type is <code>SQL_VARCHAR</code> (for
non-unicode build) and <code>SQL_WVARCHAR</code> (for a unicode build). If you
set <code>odbc_default_bind_type</code> to a value other than 0 you override the
internal default.</p>
<p><strong>N.B</strong> If you call the <code>bind_param</code> method with a SQL type this
overrides everything else above.</p>
<p>
</p>
<h3><a name="odbc_force_bind_type">odbc_force_bind_type</a></h3>
<p>This value defaults to 0.</p>
<p>If set to anything other than 0 this will force bound parameters to be
bound as this type and <code>SQLDescribeParam</code> will not be used.</p>
<p>Older versions of DBD::ODBC assumed the parameter binding type was 12
(<code>SQL_VARCHAR</code>) and newer versions always attempt to call
<code>SQLDescribeParam</code> to find the parameter types. If your driver
supports <code>SQLDescribeParam</code> and it succeeds it may still fail to
describe the parameters accurately (MS SQL Server sometimes does this
with some SQL like <em>select myfunc(?)  where 1 = 1</em>). Setting
<code>odbc_force_bind_type</code> to <code>SQL_VARCHAR</code> will force DBD::ODBC to bind
all the parameters as <code>SQL_VARCHAR</code> and ignore SQLDescribeParam.</p>
<p>Bare in mind that if you are inserting unicode data you probably want
to use <code>SQL_WVARCHAR</code> and not <code>SQL_VARCHAR</code>.</p>
<p>As this attribute was created to work around buggy ODBC Drivers which
support SQLDescribeParam but describe the parameters incorrectly you
are probably better specifying the bind type on the <code>bind_param</code> call
on a per statement level rather than blindly setting
<code>odbc_force_bind_type</code> across a whole connection.</p>
<p><strong>N.B</strong> If you call the <code>bind_param</code> method with a SQL type this
overrides everything else above.</p>
<p>
</p>
<h3><a name="odbc_force_rebind">odbc_force_rebind</a></h3>
<p>This is to handle special cases, especially when using multiple result sets.
Set this before execute to &quot;force&quot; DBD::ODBC to re-obtain the result set's
number of columns and column types for each execute.  Especially useful for
calling stored procedures which may return different result sets each
execute.  The only performance penalty is during <code>execute()</code>, but I didn't
want to incur that penalty for all circumstances.  It is probably fairly
rare that this occurs.  This attribute will be automatically set when
multiple result sets are triggered.  Most people shouldn't have to worry
about this.</p>
<p>
</p>
<h3><a name="odbc_async_exec">odbc_async_exec</a></h3>
<p>Allow asynchronous execution of queries.  This causes a spin-loop
(with a small &quot;sleep&quot;) until the ODBC API being called is complete
(i.e., while the ODBC API returns <code>SQL_STILL_EXECUTING</code>).  This is
useful, however, if you want the error handling and asynchronous
messages (see the <a href="#odbc_err_handler">odbc_err_handler</a> and <em class="file">t/20SQLServer.t</em> for an
example of this).</p>
<p>
</p>
<h3><a name="odbc_query_timeout">odbc_query_timeout</a></h3>
<p>This allows you to change the ODBC query timeout (the ODBC statement
attribute <code>SQL_ATTR_QUERY_TIMEOUT</code>). ODBC defines the query time out as
the number of seconds to wait for a SQL statement to execute before
returning to the application. A value of 0 (the default) means there
is no time out. Do not confuse this with the ODBC attributes
<code>SQL_ATTR_LOGIN_TIMEOUT</code> and <code>SQL_ATTR_CONNECTION_TIMEOUT</code>. Add</p>
<pre>
  <span class="operator">{</span> <span class="string">odbc_query_timeout</span> <span class="operator">=&gt;</span> <span class="number">30</span> <span class="operator">}</span>
</pre>
<p>to your connect, set on the <code>dbh</code> before creating a statement or
explicitly set it on your statement handle. The odbc_query_timeout on
a statement is inherited from the parent connection.</p>
<p>Note that internally DBD::ODBC only sets the query timeout if you set it
explicitly and the default of 0 (no time out) is implemented by the
ODBC driver and not DBD::ODBC.</p>
<p>Note that some ODBC drivers implement a maximum query timeout value
and will limit timeouts set above their maximum. You may see a
warning if your time out is capped by the driver but there is
currently no way to retrieve the capped value back from the driver.</p>
<p>Note that some drivers may not support this attribute.</p>
<p>See <em class="file">t/20SqlServer.t</em> for an example.</p>
<p>
</p>
<h3><a name="odbc_putdata_start">odbc_putdata_start</a></h3>
<p><code>odbc_putdata_start</code> defines the size at which DBD::ODBC uses
<code>SQLPutData</code> and <code>SQLParamData</code> to send larger objects to the
database instead of simply binding them as normal with
<code>SQLBindParameter</code>. It is mostly a placeholder for future changes
allowing chunks of data to be sent to the database and there is little
reason for anyone to change it currently.</p>
<p>The default for odbc_putdata_start is 32768 because this value was
hard-coded in DBD::ODBC until 1.16_1.</p>
<p>
</p>
<h3><a name="odbc_column_display_size">odbc_column_display_size</a></h3>
<p>If you ODBC driver does not support the SQL_COLUMN_DISPLAY_SIZE and
SQL_COLUMN_LENGTH attributes to SQLColAtrributes then DBD::ODBC does
not know how big the column might be. odbc_column_display_size sets
the default value for the column size when retrieving column data
where the size cannot be determined.</p>
<p>The default for odbc_column_display_size is 2001 because this value was
hard-coded in DBD::ODBC until 1.17_3.</p>
<p>
</p>
<h3><a name="odbc_utf8_on">odbc_utf8_on</a></h3>
<p>Set this flag to treat all strings returned from the ODBC driver
(except columns described as SQL_BINARY or SQL_TIMESTAMP and its
variations) as UTF-8 encoded.  Some ODBC drivers (like Aster and maybe
PostgreSQL) return UTF-8 encoded data but do not support the SQLxxxW
unicode API. Enabling this flag will cause DBD::ODBC to treat driver
returned data as UTF-8 encoded and it will be marked as such in Perl.</p>
<p>Do not confuse this with DBD::ODBC's unicode support. The
<code>odbc_utf8_on</code> attribute only applies to non-unicode enabled builds
of DBD::ODBC.</p>
<p>
</p>
<h3><a name="odbc_old_unicode">odbc_old_unicode</a></h3>
<p>Defaults to off. If set to true returns DBD::ODBC to the old unicode
behavior in 1.29 and earlier. You can also set this on the prepare
method.</p>
<p>By default DBD::ODBC now binds all char columns as SQL_WCHARs meaning
the driver is asked to return the bound data as wide (Unicode)
characters encoded in UCS2. So long as the driver supports the ODBC
Unicode API properly this should mean you get your data back correctly
in Perl even if it is in a character set (codepage) different from the
one you are working in.</p>
<p>However, if you wrote code using DBD::ODBC 1.29 or earlier and knew
DBD::ODBC bound varchar/longvarchar columns as SQL_CHARs and decoded
them yourself the new behaviour will adversely affect you (sorry). To
revret to the old behaviour set odbc_old_unicode to true.</p>
<p>You can also set this attribute in the attributes passed to the
prepare method.</p>
<p>See the stackoverflow question at
<a href="http://stackoverflow.com/questions/5912082">http://stackoverflow.com/questions/5912082</a>, the RT at
<a href="http://rt.cpan.org/Public/Bug/Display.html?id=67994">http://rt.cpan.org/Public/Bug/Display.html</a> and lastly a
small discussion on dbi-dev at
<a href="http://www.nntp.perl.org/group/perl.dbi.dev/2011/05/msg6559.html">http://www.nntp.perl.org/group/perl.dbi.dev/2011/05/msg6559.html</a>.</p>
<p>
</p>
<h3><a name="odbc_describe_parameters">odbc_describe_parameters</a></h3>
<p>Defaults to on. When set this allows DBD::ODBC to call SQLDescribeParam
(if the driver supports it) to retrieve information about any
parameters.</p>
<p>When off/false DBD::ODBC will not call SQLDescribeParam and defaults
to binding parameters as SQL_CHAR/SQL_WCHAR depending on the build
type.</p>
<p>You do not have to disable odbc_describe_parameters just because your
driver does not support SQLDescribeParam as DBD::ODBC will work this
out at the start via SQLGetFunctions.</p>
<p>Note: disabling odbc_describe_parameters when your driver does support
SQLDescribeParam may prevent DBD::ODBC binding parameters for some
column types properly.</p>
<p>You can also set this attribute in the attributes passed to the
prepare method.</p>
<p>This attribute was added so someone moving from freeTDS (a driver
which does not support SQLDescribeParam) to a driver which does
support SQLDescribeParam could do so without changing any Perl. The
situation was very specific since dates were being bound as dates when
SQLDescribeParam was called and chars without and the data format was
not a supported date format.</p>
<p>
</p>
<h2><a name="private_connection_attributes">Private connection attributes</a></h2>
<p>
</p>
<h3><a name="odbc_err_handler">odbc_err_handler</a></h3>
<p><strong>NOTE:</strong> You might want to look at DBI's error handler before using
the one in DBD::ODBC however, there are subtle
differences. DBD::ODBC's odbc_err_handler is called for error <strong>and</strong>
informational diagnostics i.e., it is called when an ODBC call fails
the SQL_SUCCEEDED macro which means the ODBC call returned SQL_ERROR
(-1) or SQL_SUCCESS_WITH_INFO (1).</p>
<p>Allow error and informational diagnostics to be handled by the
application.  A call-back function supplied by the application to
handle or ignore messages.</p>
<p>The callback function receives four parameters: state (string),
error (string), native error code (number) and the status returned
from the last ODBC API. The fourth argument was added in 1.30_7.</p>
<p>If the error handler returns 0, the error is ignored, otherwise the
error is passed through the normal DBI error handling. Note, if the
status is SQL_SUCCESS_WITH_INFO this will <strong>not</strong> reach the DBI error
handler as it is not an error.</p>
<p>This can also be used for procedures under MS SQL Server (Sybase too,
probably) to obtain messages from system procedures such as DBCC.
Check <em class="file">t/20SQLServer.t</em> and <em class="file">t/10handler.t</em>.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> err_handler </span><span class="operator">{</span>
     <span class="operator">(</span><span class="variable">$state</span><span class="operator">,</span> <span class="variable">$msg</span><span class="operator">,</span> <span class="variable">$native</span><span class="operator">,</span> <span class="variable">$rc</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$state</span> <span class="operator">=</span> <span class="string">'12345'</span><span class="operator">)</span>
         <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span> <span class="comment"># ignore this error</span>
     <span class="keyword">else</span>
         <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span> <span class="comment"># propagate error</span>
  <span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_err_handler</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">err_handler</span><span class="operator">;</span>
  <span class="comment"># do something to cause an error</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_err_handler</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span> <span class="comment"># cancel the handler</span>
</pre>
<p>
</p>
<h3><a name="odbc_sql_rowset_size">odbc_SQL_ROWSET_SIZE</a></h3>
<p>Setting odbc_SQL_ROWSET_SIZE results in a call to SQLSetConnectAttr
to set the ODBC SQL_ROWSET_SIZE (9) attribute to whatever value you
set odbc_SQL_ROWSET_SIZE to.</p>
<p>The ODBC default for SQL_ROWSET_SIZE is 1.</p>
<p>Usually MS SQL Server does not support multiple active statements
(MAS) i.e., you cannot have 2 or more outstanding selects.  You can
set odbc_SQL_ROWSET_SIZE to 2 to persuade MS SQL Server to support
multiple active statements.</p>
<p>Setting SQL_ROWSET_SIZE usually only affects calls to SQLExtendedFetch
but does allow MAS and as DBD::ODBC does not use SQLExtendedFetch there
should be no ill effects to DBD::ODBC.</p>
<p>Be careful with this attribute as once set to anything larger than 1
(the default) you must retrieve all result-sets before the statement
handle goes out of scope or you can upset the TDS protocol and this
can result in a hang. With DBI this is unlikely as DBI warns when a
statement goes out of scope with outstanding results.</p>
<p>NOTE: if you get an error saying &quot;[Microsoft][ODBC SQL Server
Driver]Invalid attribute/option identifier (SQL-HY092)&quot; when you set
odbc_SQL_ROWSET_SIZE in the connect method you need to either a)
upgrade to DBI 1.616 or above b) set odbc_SQL_ROWSET_SIZE after
connect.</p>
<p>In versions of SQL Server 2005 and later see &quot;Multiple Active
Statements (MAS)&quot; in the DBD::ODBC::FAQ instead of using this
attribute.</p>
<p>Thanks to Andrew Brown for the original patch.</p>
<p>DBD developer note: Here lies a bag of worms. Firstly, SQL_ROWSET_SIZE
is an ODBC 2 attribute and is usally a statement attribute not a
connection attribute. However, in ODBC 2.0 you could set statement
attributes on a connection handle and it acted as a default for all
subsequent statement handles created under that connection handle. If
you are using ODBC 3 the driver manager continues to map this call but
the ODBC Driver needs to act on it (the MS SQL Server driver still
appears to but some other ODBC drivers for MS SQL Server do not).
Secondly, somewhere a long the line MS decided it was no longer valid
to retrieve the SQL_ROWSET_SIZE attribute from a connection handle in
an ODBC 3 application (which DBD::ODBC now is). In itself, this would
not be a problem except for a minor bug in DBI which until release
1.616 mistakenly issued a FETCH on any attribute mentioned in the
connect method call. As a result, it you use a DBI prior to 1.616 and
attempt to set odbc_SQL_ROWSET_SIZE in the connect method call, DBI
issues a FETCH on odbc_SQL_ROWSET_SIZE and the driver manager throws
it out as an invalid attribute thus resulting in an error. The only
way around this (other than upgrading DBI) is to set
odbc_SQL_ROWSET_SIZE AFTER the call to connect. Thirdly, MS withdrew
the SQLROWSETSIZE macro from the sql header files in MDAC 2.7 for 64
bit platforms i.e., SQLROWSETSIZE is not defined on 64 bit platforms
from MDAC 2.7 as it is in a &quot;#ifdef win32&quot; (see
<a href="http://msdn.microsoft.com/en-us/library/ms716287%28v=vs.85%29.aspx).">http://msdn.microsoft.com/en-us/library/ms716287%28v=vs.85%29.aspx).</a>
Setting SQL_ROWSET_SIZE still seems to take effect on 64 bit platforms
but you can no longer retrieve its value from a connection handle
(hence the issue above with DBI redundant FETCH).</p>
<p>
</p>
<h3><a name="odbc_exec_direct">odbc_exec_direct</a></h3>
<p>Force DBD::ODBC to use <code>SQLExecDirect</code> instead of
<code>SQLPrepare</code>/<code>SQLExecute</code>.</p>
<p>There are drivers that only support <code>SQLExecDirect</code> and the DBD::ODBC
<a href="../../lib/pods/perlfunc.html#do"><code>do()</code></a> override does not allow returning result sets.  Therefore, the
way to do this now is to set the attribute odbc_exec_direct.</p>
<p>NOTE: You may also want to use this option if you are creating
temporary objects (e.g., tables) in MS SQL Server and for some
reason cannot use the <a href="../../lib/pods/perlfunc.html#do"><code>do</code></a> method. see
<a href="http://technet.microsoft.com/en-US/library/ms131667.aspx">http://technet.microsoft.com/en-US/library/ms131667.aspx</a> which says
<em>Prepared statements cannot be used to create temporary objects on
SQL Server 2000 or later...</em>. Without odbc_exec_direct, the temporary
object will disappear before you can use it.</p>
<p>There are currently two ways to get this:</p>
<pre>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">odbc_exec_direct</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>and</p>
<pre>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_exec_direct</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p><strong>NOTE:</strong> Even if you build DBD::ODBC with unicode support you can
still not pass unicode strings to the prepare method if you also set
odbc_exec_direct. This is a restriction in this attribute which is
unavoidable.</p>
<p>
</p>
<h3><a name="odbc_sql_driver_odbc_ver">odbc_SQL_DRIVER_ODBC_VER</a></h3>
<p>This, while available via <code>get_info()</code> is captured here.  I may get rid
of this as I only used it for debugging purposes.</p>
<p>
</p>
<h3><a name="odbc_cursortype">odbc_cursortype</a></h3>
<p>This allows multiple concurrent statements on SQL*Server.  In your
connect, add</p>
<pre>
  <span class="operator">{</span> <span class="string">odbc_cursortype</span> <span class="operator">=&gt;</span> <span class="number">2</span> <span class="operator">}.</span>
</pre>
<p>If you are using DBI &gt; 1.41, you should also be able to use</p>
<pre>
 <span class="operator">{</span> <span class="string">odbc_cursortype</span> <span class="operator">=&gt;</span> <span class="variable">DBI::SQL_CURSOR_DYNAMIC</span> <span class="operator">}</span>
</pre>
<p>instead.  For example:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:ODBC:</span><span class="variable">$DSN</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$pass</span><span class="operator">,</span>
                  <span class="operator">{</span> <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">odbc_cursortype</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"one statement"</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$sth2</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"two statement"</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">@row</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">)</span> <span class="operator">{</span>
       <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$row</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">);</span>
    <span class="operator">}</span>
</pre>
<p>See <em class="file">t/20SqlServer.t</em> for an example.</p>
<p>
</p>
<h3><a name="odbc_has_unicode">odbc_has_unicode</a></h3>
<p>A read-only attribute signifying whether DBD::ODBC was built with the
C macro WITH_UNICODE or not. A value of 1 indicates DBD::ODBC was built
with WITH_UNICODE else the value returned is 0.</p>
<p>Building WITH_UNICODE affects columns and parameters which are
SQL_C_WCHAR, SQL_WCHAR, SQL_WVARCHAR, and SQL_WLONGVARCHAR, SQL,
the connect method and a lot more. See <a href="#unicode">Unicode</a>.</p>
<p>When odbc_has_unicode is 1, DBD::ODBC will:</p>
<dl>
<dt><strong><a name="bind_columns_the_database_declares_as_wide_characters_as_sql_wxxx" class="item">bind columns the database declares as wide characters as SQL_Wxxx</a></strong></dt>

<dd>
<p>This means that UNICODE data stored in these columns will be returned
to Perl in UTF-8 and with the UTF8 flag set.</p>
</dd>
<dt><strong><a name="bind_parameters_the_database_declares_as_wide_characters_as_sql_wxxx" class="item">bind parameters the database declares as wide characters as SQL_Wxxx</a></strong></dt>

<dd>
<p>Parameters bound where the database declares the parameter as being
a wide character (or where the parameter type is explicitly set to a
wide type - SQL_Wxxx) can be UTF8 in Perl and will be mapped to UTF16
before passing to the driver.</p>
</dd>
<dt><strong><a name="sql" class="item">SQL</a></strong></dt>

<dd>
<p>SQL passed to the <code>prepare</code> or <a href="../../lib/pods/perlfunc.html#do"><code>do</code></a> methods which has the UTF8 flag set
will be converted to UTF16 before being passed to the ODBC APIs <code>SQLPrepare</code>
or <code>SQLExecDirect</code>.</p>
</dd>
<dt><strong><a name="connection_strings" class="item">connection strings</a></strong></dt>

<dd>
<p>Connection strings passed to the <a href="../../lib/pods/perlfunc.html#connect"><code>connect</code></a> method will be converted
to UTF16 before being passed to the ODBC API <code>SQLDriverConnectW</code>. This happens
irrespective of whether the UTF8 flag is set on the perl connect strings
because unixODBC requires an application to call SQLDriverConnectW to indicate
it will be calling the wide ODBC APIs.</p>
</dd>
</dl>
<p>NOTE: You will need at least Perl 5.8.1 to use UNICODE with DBD::ODBC.</p>
<p>NOTE: Binding of unicode output parameters is coded but untested.</p>
<p>NOTE: When building DBD::ODBC on Windows ($^O eq 'MSWin32') the
WITH_UNICODE macro is automatically added. To disable specify -nou as
an argument to Makefile.PL (e.g. <code>perl Makefile.PL -nou</code>). On non-Windows
platforms the WITH_UNICODE macro is <strong>not</strong> enabled by default and to enable
you need to specify the -u argument to Makefile.PL. Please bare in mind
that some ODBC drivers do not support SQL_Wxxx columns or parameters.</p>
<p>NOTE: Unicode support on Windows 64 bit platforms is currently
untested.  Let me know how you get on with it.</p>
<p>UNICODE support in ODBC Drivers differs considerably. Please read the
README.unicode file for further details.</p>
<p>
</p>
<h3><a name="odbc_out_connect_string">odbc_out_connect_string</a></h3>
<p>After calling the connect method this will be the ODBC driver's
out connection string - see documentation on SQLDriverConnect.</p>
<p>
</p>
<h3><a name="odbc_version">odbc_version</a></h3>
<p>This was added prior to the move to ODBC 3.x to allow the caller to
&quot;force&quot; ODBC 3.0 compatibility.  It's probably not as useful now, but
it allowed get_info and get_type_info to return correct/updated
information that ODBC 2.x didn't permit/provide.  Since DBD::ODBC is
now 3.x, this can be used to force 2.x behavior via something like: my</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:ODBC:</span><span class="variable">$DSN</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$pass</span><span class="operator">,</span>
                      <span class="operator">{</span> <span class="string">odbc_version</span> <span class="operator">=&gt;</span><span class="number">2</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="private_statement_methods">Private statement methods</a></h2>
<p>
</p>
<h3><a name="odbc_lob_read">odbc_lob_read</a></h3>
<pre>
  <span class="variable">$chrs_or_bytes_read</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">lob_read</span><span class="operator">(</span><span class="variable">$column_no</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$lob</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Reads <code>$length</code> bytes from the lob at column <code>$column_no</code> returning
the lob into <code>$lob</code> and the number of bytes or characters read into
<code>$chrs_or_bytes_read</code>. If an error occurs undef will be returned.
When there is no more data to be read 0 is returned.</p>
<p>NOTE: This is currently an experimental method and may change in the
future e.g., it may support automatic concatenation of the lob
parts onto the end of the <code>$lob</code> with the addition of an extra flag
or destination offset as in DBI's undocumented blob_read.</p>
<p>The type the lob is retrieved as may be overriden in <code>%attr</code> using
<code>TYPE =&gt; sql_type</code>. <code>%attr</code> is optional and if omitted defaults to
SQL_C_BINARY for binary columns and SQL_C_CHAR/SQL_C_WCHAR for other
column types depending on whether DBD::ODBC is built with unicode
support. <code>$chrs_or_bytes_read</code> will by the bytes read when the column
types SQL_C_CHAR or SQL_C_BINARY are used and characters read if the
column type is SQL_C_WCHAR.</p>
<p>When built with unicode support <code>$length</code> specifes the amount of
buffer space to be used when retrieving the lob data but as it is
returned as SQLWCHAR characters this means you at most retrieve
<code>$length/2</code> characters. When those retrieved characters are encoded
in UTF-8 for Perl, the <code>$lob</code> scalar may need to be larger than
<code>$length</code> so DBD::ODBC grows it appropriately.</p>
<p>You can retrieve a lob in chunks like this:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="operator">{</span><span class="string">TreatAsLOB</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">while</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$retrieved</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">odbc_lob_read</span><span class="operator">(</span><span class="variable">$column</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">))</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"retrieved=</span><span class="variable">$retrieved</span><span class="string"> lob_data=</span><span class="variable">$data</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>NOTE: to retrieve a lob like this you <strong>must</strong> first bind the lob
column specifying BindAsLOB or DBD::ODBC will 1) bind the column as
normal and it will be subject to LongReadLen and b) fail
odbc_lob_read.</p>
<p>NOTE: Some database engines and ODBC drivers do not allow you to
retrieve columns out of order (e.g., MS SQL Server unless you are
using cursors).  In those cases you must ensure the lob retrieved is
the last (or only) column in your select list.</p>
<p>NOTE: You can retrieve only part of a lob but you will probably have
to call finish on the statement handle before you do anything else
with that statement.</p>
<p>NOTE: If your select contains multiple lobs you cannot read part of
the first lob, the second lob then return to the first lob. You must
read all lobs in order and completely or read part of a lob and then
do no further calls to odbc_lob_read.</p>
<p>
</p>
<h2><a name="private_statement_attributes">Private statement attributes</a></h2>
<p>
</p>
<h3><a name="odbc_more_results">odbc_more_results</a></h3>
<p>Use this attribute to determine if there are more result sets
available.  SQL Server supports this feature.  Use this as follows:</p>
<pre>
  <span class="keyword">do</span> <span class="operator">{</span>
     <span class="keyword">my</span> <span class="variable">@row</span><span class="operator">;</span>
     <span class="keyword">while</span> <span class="operator">(</span><span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">())</span> <span class="operator">{</span>
        <span class="comment"># do stuff here</span>
     <span class="operator">}</span>
  <span class="operator">}</span> <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_more_results</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>Note that with multiple result sets and output parameters (i.e,. using
bind_param_inout), don't expect output parameters to be bound until ALL
result sets have been retrieved.</p>
<p>
</p>
<h2><a name="private_dbd__odbc_functions">Private DBD::ODBC Functions</a></h2>
<p>You use DBD::ODBC private functions like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">arg</span><span class="operator">,</span> <span class="variable">private_function_name</span><span class="operator">,</span> <span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="getinfo">GetInfo</a></h3>
<p><strong>This private function is now superceded by DBI's get_info method.</strong></p>
<p>This function maps to the ODBC SQLGetInfo call and the argument
should be a valid ODBC information type (see ODBC specification).
e.g.</p>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="number">6</span><span class="operator">,</span> <span class="string">'GetInfo'</span><span class="operator">);</span>
</pre>
<p>which returns the <code>SQL_DRIVER_NAME</code>.</p>
<p>This function returns a scalar value, which can be a numeric or string
value depending on the information value requested.</p>
<p>
</p>
<h3><a name="sqlgettypeinfo">SQLGetTypeInfo</a></h3>
<p><strong>This private function is now superceded by DBI's type_info and
type_info_all methods.</strong></p>
<p>This function maps to the ODBC SQLGetTypeInfo API and the argument
should be a SQL type number (e.g. SQL_VARCHAR) or
SQL_ALL_TYPES. SQLGetTypeInfo returns information about a data type
supported by the data source.</p>
<p>e.g.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">SQL_ALL_TYPES</span><span class="operator">,</span> <span class="variable">GetTypeInfo</span><span class="operator">);</span>
  <span class="variable">DBI::dump_results</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">);</span>
</pre>
<p>This function returns a DBI statement handle for the SQLGetTypeInfo
result-set containing many columns of type attributes (see ODBC
specification).</p>
<p>NOTE: It is VERY important that the <a href="../../lib/pods/perlfunc.html#use"><code>use DBI</code></a> includes the
<code>qw(:sql_types)</code> so that values like SQL_VARCHAR are correctly
interpreted.  This &quot;imports&quot; the sql type names into the program's
name space.  A very common mistake is to forget the <code>qw(:sql_types)</code>
and obtain strange results.</p>
<p>
</p>
<h3><a name="getfunctions">GetFunctions</a></h3>
<p>This function maps to the ODBC SQLGetFunctions API which returns
information on whether a function is supported by the ODBC driver.</p>
<p>The argument should be <code>SQL_API_ALL_FUNCTIONS</code> (0) for all functions
or a valid ODBC function number (e.g. <code>SQL_API_SQLDESCRIBEPARAM</code>
which is 58). See ODBC specification or examine your sqlext.h and
sql.h header files for all the SQL_API_XXX macros.</p>
<p>If called with <code>SQL_API_ALL_FUNCTIONS</code> (0), then a 100 element array is
returned where each element will contain a '1' if the ODBC function with
that SQL_API_XXX index is supported or '' if it is not.</p>
<p>If called with a specific SQL_API_XXX value for a single function it will
return true if the ODBC driver supports that function, otherwise false.</p>
<p>e.g.</p>
<pre>
    <span class="keyword">my</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="string">"GetFunctions"</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"SQLDescribeParam is supported\n"</span> <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$x</span><span class="operator">[</span><span class="number">58</span><span class="operator">]</span><span class="operator">);</span>
</pre>
<p>or</p>
<pre>
    <span class="keyword">print</span> <span class="string">"SQLDescribeParam is supported\n"</span>
        <span class="keyword">if</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="number">58</span><span class="operator">,</span> <span class="string">"GetFunctions"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="getstatistics">GetStatistics</a></h3>
<p><strong>This private function is now superceded by DBI's statistics_info
method.</strong></p>
<p>See the ODBC specification for the SQLStatistics API.
You call SQLStatistics like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$catalog</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$unique</span><span class="operator">,</span> <span class="string">'GetStatistics'</span><span class="operator">);</span>
</pre>
<p>Prior to DBD::ODBC 1.16 $unique was not defined as being true/false or
SQL_INDEX_UNIQUE/SQL_INDEX_ALL. In fact, whatever value you provided
for $unique was passed through to the ODBC API SQLStatistics call
unchanged. This changed in 1.16, where $unique became a true/false
value which is interpreted into SQL_INDEX_UNIQUE for true and
SQL_INDEX_ALL for false.</p>
<p>
</p>
<h3><a name="getforeignkeys">GetForeignKeys</a></h3>
<p><strong>This private function is now superceded by DBI's foreign_key_info
method.</strong></p>
<p>See the ODBC specification for the SQLForeignKeys API.
You call SQLForeignKeys like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$pcatalog</span><span class="operator">,</span> <span class="variable">$pschema</span><span class="operator">,</span> <span class="variable">$ptable</span><span class="operator">,</span>
             <span class="variable">$fcatalog</span><span class="operator">,</span> <span class="variable">$fschema</span><span class="operator">,</span> <span class="variable">$ftable</span><span class="operator">,</span>
             <span class="string">"GetForeignKeys"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="getprimarykeys">GetPrimaryKeys</a></h3>
<p><strong>This private function is now superceded by DBI's primary_key_info
method.</strong></p>
<p>See the ODBC specification for the SQLPrimaryKeys API.
You call SQLPrimaryKeys like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$catalog</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="string">"GetPrimaryKeys"</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="data_sources">data_sources</a></h3>
<p><strong>This private function is now superceded by DBI's data_sources
method.</strong></p>
<p>You call data_sources like this:</p>
<pre>
  <span class="variable">@dsns</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="string">"data_sources);
  </span>
</pre>
<p>Handled since 0.21.</p>
<p>
</p>
<h3><a name="getspecialcolumns">GetSpecialColumns</a></h3>
<p>See the ODBC specification for the SQLSpecialColumns API.
You call SQLSpecialColumns like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$identifier</span><span class="operator">,</span> <span class="variable">$catalog</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$scope</span><span class="operator">,</span>
             <span class="variable">$nullable</span><span class="operator">,</span> <span class="string">'GetSpecialColumns'</span><span class="operator">);</span>
</pre>
<p>Handled as of version 0.28</p>
<p>
</p>
<h3><a name="colattributes">ColAttributes</a></h3>
<p><strong>This private function is now superceded by DBI's statement attributes
NAME, TYPE, PRECISION, SCALE, NULLABLE etc).</strong></p>
<p>See the ODBC specification for the SQLColAttributes API.
You call SQLColAttributes like this:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$column</span><span class="operator">,</span> <span class="variable">$ftype</span><span class="operator">,</span> <span class="string">"ColAttributes"</span><span class="operator">);</span>
</pre>
<pre>
  SQL_COLUMN_COUNT = 0
  SQL_COLUMN_NAME = 1
  SQL_COLUMN_TYPE = 2
  SQL_COLUMN_LENGTH = 3
  SQL_COLUMN_PRECISION = 4
  SQL_COLUMN_SCALE = 5
  SQL_COLUMN_DISPLAY_SIZE = 6
  SQL_COLUMN_NULLABLE = 7
  SQL_COLUMN_UNSIGNED = 8
  SQL_COLUMN_MONEY = 9
  SQL_COLUMN_UPDATABLE = 10
  SQL_COLUMN_AUTO_INCREMENT = 11
  SQL_COLUMN_CASE_SENSITIVE = 12
  SQL_COLUMN_SEARCHABLE = 13
  SQL_COLUMN_TYPE_NAME = 14
  SQL_COLUMN_TABLE_NAME = 15
  SQL_COLUMN_OWNER_NAME = 16
  SQL_COLUMN_QUALIFIER_NAME = 17
  SQL_COLUMN_LABEL = 18</pre>
<p><strong>Note:</strong>Oracle's ODBC driver for linux in instant client 11r1 often
returns strange values for column name e.g., '20291'. It is wiser to
use DBI's NAME and NAME_xx attributes for portability.</p>
<p>
</p>
<h3><a name="describecol">DescribeCol</a></h3>
<p><strong>This private function is now superceded by DBI's statement attributes
NAME, TYPE, PRECISION, SCLARE, NULLABLE etc).</strong></p>
<p>See the ODBC specification for the SQLDescribeCol API.
You call SQLDescribeCol like this:</p>
<pre>
  <span class="variable">@info</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$column</span><span class="operator">,</span> <span class="string">"DescribeCol"</span><span class="operator">);</span>
</pre>
<p>The returned array contains the column attributes in the order described
in the ODBC specification for SQLDescribeCol.</p>
<p>
</p>
<h2><a name="additional_bind_col_attributes">Additional bind_col attributes</a></h2>
<p>DBD::ODBC supports a few additional attributes which may be passed to
the bind_col method in the attributes.</p>
<p>
</p>
<h3><a name="discardstring">DiscardString</a></h3>
<p>See DBI's sql_type_cast utility function.</p>
<p>If you bind a column as a specific type (SQL_INTEGER, SQL_DOUBLE and
SQL_NUMERIC are the only ones supported currently) and you add
DiscardString to the prepare attributes then if the returned bound
data is capable of being converted to that type the scalar's pv (the
string portion of a scalar) is cleared.</p>
<p>This is especially useful if you are using a module which uses a
scalars flags and/or pv to decide if a scalar is a number. JSON::XS
does this and without this flag you have to add 0 to all bound column
data returning numbers to get JSON::XS to encode it is N instead of
&quot;N&quot;.</p>
<p>
</p>
<h3><a name="strictlytyped">StrictlyTyped</a></h3>
<p>See DBI's sql_type_cast utility function.</p>
<p>See <a href="#discardstring">DiscardString</a> above.</p>
<p>Specifies that when DBI's sql_type_cast function is called on returned
data where a bind type is specified that if the conversion cannot be
performed an error will be raised.</p>
<p>This is probably not a lot of use with DBD::ODBC as if you ask for say
an SQL_INTEGER and the data is not able to be converted to an integer
the ODBC driver will problably return &quot;Invalid character value for
cast specification (SQL-22018)&quot;.</p>
<p>
</p>
<h3><a name="treataslob">TreatAsLOB</a></h3>
<p>See <a href="#odbc_lob_read">odbc_lob_read</a>.</p>
<p>
</p>
<h2><a name="tracing">Tracing</a></h2>
<p>DBD::ODBC now supports the parse_trace_flag and parse_trace_flags
methods introduced in DBI 1.42 (see DBI for a full description).  As
of DBI 1.604, the only trace flag defined which is relevant to
DBD::ODBC is 'SQL' which DBD::ODBC supports by outputting the SQL
strings (after modification) passed to the prepare and do methods.</p>
<p>From DBI 1.617 DBI also defines ENC (encoding), CON (connection) TXN
(transaction) and DBD (DBD only) trace flags. DBI's ENC and CON trace
flags are synonomous with DBD::ODBC's odbcunicode and odbcconnection
trace flags though I may remove the DBD::ODBC ones in the
future. DBI's DBD trace flag allows output of only DBD::ODBC trace
messages without DBI's trace messages.</p>
<p>Currently DBD::ODBC supports two private trace flags. The
'odbcunicode' flag traces some unicode operations and the
odbcconnection traces the connect process.</p>
<p>To enable tracing of particular flags you use:</p>
<pre>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'SQL|odbcconnection'</span><span class="operator">));</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'1|odbcunicode'</span><span class="operator">));</span>
</pre>
<p>In the first case 'SQL' and 'odbcconnection' tracing is enabled on
$h. In the second case trace level 1 is set and 'odbcunicode' tracing
is enabled.</p>
<p>If you want to enable a DBD::ODBC private trace flag before connecting
you need to do something like:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::ODBC</span><span class="operator">;</span>
  <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">DBD::ODBC</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flag</span><span class="operator">(</span><span class="string">'odbcconnection'</span><span class="operator">));</span>
</pre>
<p>or</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::ODBC</span><span class="operator">;</span>
  <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">DBD::ODBC</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'odbcconnection|odbcunicode'</span><span class="operator">));</span>
</pre>
<p>or</p>
<pre>
  DBI_TRACE=odbcconnection|odbcunicode perl myscript.pl</pre>
<p>From DBI 1.617 you can output only DBD::ODBC trace messages using</p>
<pre>
  DBI_TRACE=DBD perl myscript.pl</pre>
<p>DBD::ODBC outputs tracing at levels 3 and above (as levels 1 and 2 are
reserved for DBI).</p>
<p>For comprehensive tracing of DBI method calls without all the DBI
internals see <a href="../../DBIx/Log4perl.html">the DBIx::Log4perl manpage</a>.</p>
<p>
</p>
<h2><a name="deviations_from_the_dbi_specification">Deviations from the DBI specification</a></h2>
<p>
</p>
<h3><a name="last_insert_id">last_insert_id</a></h3>
<p>DBD::ODBC does not support DBI's last_insert_id. There is no ODBC
defined way of obtaining this information. Generally the mechanism
(and it differs vastly between databases and ODBC drivers) it to issue
a select of some form (e.g., select @@identity or select
sequence.currval from dual, etc).</p>
<p>There are literally dozens of databases and ODBC drivers supported by
DBD::ODBC and I cannot have them all. If you know how to retrieve the
information for last_insert_id and you mail me the ODBC Driver
name/version and database name/version with a small working example I
will collect examples and document them here.</p>
<p><strong>Microsoft Access</strong>. Recent versions of MS Access support <em>select
@@identity</em> to retrieve the last insert ID.  See
<a href="http://support.microsoft.com/kb/815629.">http://support.microsoft.com/kb/815629.</a> Information provided by Robert
Freimuth.</p>
<p>
</p>
<h3><a name="comments_in_sql">Comments in SQL</a></h3>
<p>DBI does not say anything in particular about comments in SQL.
DBD::ODBC looks for placeholders in the SQL string and until 1.24_2 it
did not recognise comments in SQL strings so could find what it
believes to be a placeholder in a comment e.g.,</p>
<pre>
  select '1' /* placeholder ? in comment */
  select -- named placeholder :named in comment
    '1'</pre>
<p>I cannot be exact about support for ignoring placeholders in literals
but it has existed for a long time in DBD::ODBC. Support for ignoring
placeholders in comments was added in 1.24_2. If you find a case where
a named placeholder is not ignored and should be, see
<a href="#odbc_ignore_named_placeholders">odbc_ignore_named_placeholders</a> for a workaround and mail me an
example along with your ODBC driver name.</p>
<p>
</p>
<h3><a name="do">do</a></h3>
<p>This is not really a deviation from the DBI specification since DBI
allows a driver to avoid the overhead of creating an DBI statement
handle for <a href="../../lib/pods/perlfunc.html#do"><code>do()</code></a>.</p>
<p>DBD::ODBC implements <a href="../../lib/pods/perlfunc.html#do"><code>do</code></a> by calling SQLExecDirect in ODBC and not
SQLPrepare followed by SQLExecute so <a href="../../lib/pods/perlfunc.html#do"><code>do</code></a> is not the same as:</p>
<pre>
  $dbh-&gt;prepare($sql)-&gt;execute()</pre>
<p>It does this to avoid a round-trip to the server so it is faster.
Normally this is good but some people fall foul of this with MS SQL
Server if they call a procedure which outputs print statements (e.g.,
backup) as the procedure may not complete. See the DBD::ODBC FAQ and
in general you are better to use prepare/execute when calling
procedures.</p>
<p>In addition, you should realise that since DBD::ODBC does not create a
DBI statement for do calls, if you set up an error handler the handle
passed in when a do fails will be the database handle and not
a statement handle.</p>
<p>
</p>
<h3><a name="mixed_placeholder_types">Mixed placeholder types</a></h3>
<p>There are 3 conventions for place holders in DBI. These are '?', ':N'
and ':name' (where 'N' is a number and 'name' is an alpha numeric
string not beginning with a number). DBD::ODBC supports all these methods
for naming placeholders but you must only use one method throughout
a particular SQL string. If you mix placeholder methods you will get
an error like:</p>
<pre>
  Can't mix placeholder styles (1/2)</pre>
<p>
</p>
<h3><a name="using_the_same_placeholder_more_than_once">Using the same placeholder more than once</a></h3>
<p>DBD::ODBC does not support (currently) the use of one named placeholder
more than once in the a single SQL string. i.e.,</p>
<pre>
  <span class="variable">insert</span> <span class="variable">into</span> <span class="variable">foo</span> <span class="keyword">values</span> <span class="operator">(:</span><span class="variable">bar</span><span class="operator">,</span> <span class="operator">:</span><span class="variable">p1</span><span class="operator">,</span> <span class="operator">:</span><span class="variable">p2</span><span class="operator">,</span> <span class="operator">:</span><span class="variable">bar</span><span class="operator">);</span>
</pre>
<p>is not supported because 'bar' is used more than once but:</p>
<pre>
  insert into foo values(:bar, :p1, :p2)</pre>
<p>is ok. If you do the former you will get an error like:</p>
<pre>
  DBD::ODBC does not yet support binding a named parameter more than once</pre>
<p>
</p>
<h3><a name="binding_named_placeholders">Binding named placeholders</a></h3>
<p>Although the DBI documentation (as of 1.604) does not say how named
parameters are bound Tim Bunce has said that in Oracle they are bound
with the leading ':' as part of the name and that has always been the
case. i.e.,</p>
<pre>
  <span class="variable">prepare</span><span class="operator">(</span><span class="string">"insert into mytable values (:fred)"</span><span class="operator">);</span>
  <span class="variable">bind_param</span><span class="operator">(</span><span class="string">":foo"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</pre>
<p>DBD::ODBC does not support binding named parameters with the ':' introducer.
In the above example you must use:</p>
<pre>
  <span class="variable">bind_param</span><span class="operator">(</span><span class="string">"foo"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</pre>
<p>In discussion on the dbi-dev list is was suggested that the ':' could
be made optional and there were no basic objections but it has not
made it's way into the pod yet.</p>
<p>
</p>
<h3><a name="sticky_parameter_types">Sticky Parameter Types</a></h3>
<p>The DBI specification post 1.608 says in bind_param:</p>
<pre>
  The data type is 'sticky' in that bind values passed to execute()
  are bound with the data type specified by earlier bind_param()
  calls, if any.  Portable applications should not rely on being able
  to change the data type after the first C&lt;bind_param&gt; call.</pre>
<p>DBD::ODBC does allow a parameter to be rebound with another data type as
ODBC inherently allows this. Therefore you can do:</p>
<pre>
  <span class="comment"># parameter 1 set as a SQL_LONGVARCHAR</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">DBI::SQL_LONGVARCHAR</span><span class="operator">);</span>
  <span class="comment"># without the bind above the $data parameter would be either a DBD::ODBC</span>
  <span class="comment"># internal default or whatever the ODBC driver said it was but because</span>
  <span class="comment"># parameter types are sticky, the type is still SQL_LONGVARCHAR.</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$data</span><span class="operator">);</span>
  <span class="comment"># change the bound type to SQL_VARCHAR</span>
  <span class="comment"># some DBDs will ignore the type in the following, DBD::ODBC does not</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">DBI::SQL_VARCHAR</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="disconnect_and_transactions">disconnect and transactions</a></h3>
<p>DBI does not define whether a driver commits or rolls back any
outstanding transaction when disconnect is called. As such DBD::ODBC
cannot deviate from the specification but you should know it rolls
back an uncommitted transaction when disconnect is called if
SQLDisconnect returns state 25000 (transaction in progress).</p>
<p>
</p>
<h2><a name="unicode">Unicode</a></h2>
<p>The ODBC specification supports wide character versions (a postfix of
'W') of some of the normal ODBC APIs e.g., SQLDriverConnectW is a wide
character version of SQLDriverConnect.</p>
<p>In ODBC on Windows the wide characters are defined as SQLWCHARs (2
bytes) and are UCS-2. On non-Windows, the main driver managers I know
of have implemented the wide character APIs differently:</p>
<dl>
<dt><strong><a name="unixodbc" class="item">unixODBC</a></strong></dt>

<dd>
<p>unixODBC mimics the Windows ODBC API precisely meaning the wide
character versions expect and return 2-byte characters in
UCS-2.</p>
<p>unixODBC will happily recognise ODBC drivers which only have the ANSI
versions of the ODBC API and those that have the wide versions
too.</p>
<p>unixODBC will allow an ANSI application to work with a unicode
ODBC driver and vice versa (although in the latter case you obviously
cannot actually use unicode).</p>
<p>unixODBC does not prevent you sending UTF-8 in the ANSI versions of
the ODBC APIs but whether that is understood by your ODBC driver is
another matter.</p>
<p>unixODBC differs in only one way from the Microsoft ODBC driver in
terms of unicode support in that it avoids unnecessary translations
between single byte and double byte characters when an ANSI
application is using a unicode-aware ODBC driver by requiring unicode
applications to signal their intent by calling SQLDriverConnectW
first. On Windows, the ODBC driver manager always uses the wide
versions of the ODBC API in ODBC drivers which provide the wide
versions regardless of what the application really needs and this
results in a lot of unnecessary character translations when you have
an ANSI application and a unicode ODBC driver.</p>
</dd>
<dt><strong><a name="iodbc" class="item">iODBC</a></strong></dt>

<dd>
<p>The wide character versions expect and return wchar_t types.</p>
</dd>
</dl>
<p>DBD::ODBC has gone with unixODBC so you cannot use iODBC with a
unicode build of DBD::ODBC. However, some ODBC drivers support UTF-8
(although how they do this with SQLGetData reliably I don't know)
and so you should be able to use those with DBD::ODBC not built for
unicode.</p>
<p>
</p>
<h3><a name="enabling_and_disabling_unicode_support">Enabling and Disabling Unicode support</a></h3>
<p>On Windows Unicode support is enabled by default and to disable it
you will need to specify <code>-nou</code> to <em class="file">Makefile.PL</em> to get back to the
original behavior of DBD::ODBC before any Unicode support was added.</p>
<p>e.g.,</p>
<pre>
  perl Makfile.PL -nou</pre>
<p>On non-Windows platforms Unicode support is disabled by default. To
enable it specify <a href="../../lib/pods/perlrun.html#u"><code>-u</code></a> to <em class="file">Makefile.PL</em> when you configure DBD::ODBC.</p>
<p>e.g.,</p>
<pre>
  perl Makefile.PL -u</pre>
<p>
</p>
<h3><a name="unicode___what_is_supported">Unicode - What is supported?</a></h3>
<p>As of version 1.17 DBD::ODBC has the following unicode support:</p>
<dl>
<dt><strong>SQL (introduced in 1.16_2)</strong></dt>

<dd>
<p>Unicode strings in calls to the <code>prepare</code> and <a href="../../lib/pods/perlfunc.html#do"><code>do</code></a> methods are
supported so long as the <code>odbc_execdirect</code> attribute is not used.</p>
</dd>
<dt><strong><a name="strings" class="item">unicode connection strings (introduced in 1.16_2)</a></strong></dt>

<dd>
<p>Unicode connection strings are supported but you will need a DBI
post 1.607 for that.</p>
</dd>
<dt><strong><a name="column_names" class="item">column names</a></strong></dt>

<dd>
<p>Unicode column names are returned.</p>
</dd>
<dt><strong><a name="columns" class="item">bound columns (introduced in 1.15)</a></strong></dt>

<dd>
<p>If the DBMS reports the column as being a wide character (SQL_Wxxx) it
will be bound as a wide character and any returned data will be
converted from UTF16 to UTF8 and the UTF8 flag will then be set on the
data.</p>
</dd>
<dt><strong><a name="bound_parameters" class="item">bound parameters</a></strong></dt>

<dd>
<p>If the perl scalars you bind to parameters are marked UTF8 and the
DBMS reports the type as being a wide type or you bind the parameter
as a wide type they will be converted to wide characters and bound as
such.</p>
</dd>
</dl>
<p>Since version 1.16_4, the default parameter bind type is SQL_WVARCHAR
for unicode builds of DBD::ODBC. This only affects ODBC drivers which
do not support SQLDescribeParam and only then if you do not
specifically set a sql type on the bind_param method call.</p>
<p>The above Unicode support has been tested with the SQL Server, Oracle
9.2+ and Postgres drivers on Windows and various Easysoft ODBC drivers
on UNIX.</p>
<p>
</p>
<h3><a name="unicode___what_is_not_supported">Unicode - What is not supported?</a></h3>
<p>You cannot use unicode parameter names e.g.,</p>
<pre>
  select * from table where column = :unicode_param_name</pre>
<p>You cannot use unicode strings in calls to prepare if you set the
odbc_execdirect attribute.</p>
<p>You cannot use the iODBC driver manager with DBD::ODBC built for
unicode.</p>
<p>
</p>
<h3><a name="unicode___caveats">Unicode - Caveats</a></h3>
<p>For Unicode support on any platform in Perl you will need at least
Perl 5.8.1 - sorry but this is the way it is with Perl.</p>
<p>The Unicode support in DBD::ODBC expects a WCHAR to be 2 bytes (as it
is on Windows and as the ODBC specification suggests it is). Until
ODBC specifies any other Unicode support it is not envisioned this
will change.  On UNIX there are a few different ODBC driver
managers. I have only tested the unixODBC driver manager
(http://www.unixodbc.org) with Unicode support and it was built with
defaults which set WCHAR as 2 bytes.</p>
<p>I believe that the iODBC driver manager expects wide characters to be
wchar_t types (which are usually 4) and hence DBD::ODBC will not work
iODBC when built for unicode.</p>
<p>The ODBC Driver must expect Unicode data specified in SQLBindParameter
and SQLBindCol to be UTF16 in local endianness. Similarly, in calls to
SQLPrepareW, SQLDescribeColW and SQLDriverConnectW.</p>
<p>You should be aware that once Unicode support is enabled it affects a
number of DBI methods (some of which you might not expect). For
instance, when listing tables, columns etc some drivers
(e.g. Microsoft SQL Server) will report the column types as wide types
even if the strings actually fit in 7-bit ASCII. As a result, there is
an overhead for retrieving this column data as 2 bytes per character
will be transmitted (compared with 1 when Unicode support is not
enabled) and these strings will be converted into UTF8 but will end up
fitting (in most cases) into 7bit ASCII so a lot of conversion work
has been performed for nothing. If you don't have Unicode table and
column names or Unicode column data in your tables you are best
disabling Unicode support.</p>
<p>I am at present unsure if ChopBlanks processing on Unicode strings is
working correctly on UNIX. If nothing else the construct L' ' in
dbdimp.c might not work with all UNIX compilers. Reports of issues and
patches welcome.</p>
<p>
</p>
<h3><a name="unicode_implementation_in_dbd__odbc">Unicode implementation in DBD::ODBC</a></h3>
<p>DBD::ODBC uses the wide character versions of the ODBC API and the
SQL_WCHAR ODBC type to support unicode in Perl.</p>
<p>Wide characters returned from the ODBC driver will be converted to
UTF-8 and the perl scalars will have the utf8 flag set (by using
sv_utf8_decode).</p>
<p>perl scalars which are UTF-8 and are sent through the ODBC API will be
converted to UTF-16 and passed to the ODBC wide APIs or signalled as
SQL_WCHARs (e.g., in the case of bound columns).</p>
<p>When built for unicode, DBD::ODBC will always call SQLDriverConnectW
(and not SQLDriverConnect) even if a) your connection string is not
unicode b) you have not got a DBI later than 1.607, because unixODBC
requires SQLDriverConnectW to be called if you want to call other
unicode ODBC APIs later. As a result, if you build for unicode and
pass ASCII strings to the connect method they will be converted to
UTF-16 and passed to SQLDriverConnectW. This should make no real
difference to perl not using unicode connection strings.</p>
<p>You will need a DBI later than 1.607 to support unicode connection
strings because until post 1.607 there was no way for DBI to pass
unicode strings to the DBD.</p>
<p>
</p>
<h3><a name="unicode_and_oracle">Unicode and Oracle</a></h3>
<p>You have to set the environment variables <code>NLS_NCHAR=AL32UTF8</code> and
<code>NLS_LANG=AMERICAN_AMERICA.AL32UTF8</code> (or any other language setting
ending with <code>.AL32UTF8</code>) before loading DBD::ODBC to make Oracle
return Unicode data. (See also &quot;Oracle and Unicode&quot; in the POD of
DBD::Oracle.)</p>
<p>On Windows, using the Oracle ODBC Driver you have to enable the <strong>Force
SQL_WCHAR support</strong> Workaround in the data source configuration to make
Oracle return Unicode to a non-Unicode application. Alternatively, you
can include <code>FWC=T</code> in your connect string.</p>
<p>Unless you need to use ODBC, if you want Unicode support with Oracle
you are better off using <a href="../../lib/DBD/Oracle.html">the DBD::Oracle manpage</a>.</p>
<p>
</p>
<h3><a name="unicode_and_postgresql">Unicode and PostgreSQL</a></h3>
<p>See the odbc_utf8_on parameter to treat all strings as utf8.</p>
<p>Some tests from the original DBD::ODBC 1.13 fail with PostgreSQL
8.0.3, so you may not want to use DBD::ODBC to connect to PostgreSQL
8.0.3.</p>
<p>Unicode tests fail because PostgreSQL seems not to give any hints
about Unicode, so all data is treated as non-Unicode.</p>
<p>Unless you need to use ODBC, if you want Unicode support with Postgres
you are better off with <a href="../../lib/Bundle/DBD/Pg.html">the DBD::Pg manpage</a> as it has a specific attribute named
<code>pg_enable_utf8</code> to enable Unicode support.</p>
<p>
</p>
<h3><a name="unicode_and_easysoft_odbc_drivers">Unicode and Easysoft ODBC Drivers</a></h3>
<p>We have tested the Easysoft SQL Server, Oracle and ODBC Bridge drivers
with DBD::ODBC built for Unicode. All work as described without
modification except for the Oracle driver you will need to set you
NLS_LANG as mentioned above.</p>
<p>
</p>
<h3><a name="unicode_and_other_odbc_drivers">Unicode and other ODBC drivers</a></h3>
<p>If you have a unicode-enabled ODBC driver and it works with DBD::ODBC
let me know and I will include it here.</p>
<p>
</p>
<h2><a name="odbc_support_in_odbc_drivers">ODBC Support in ODBC Drivers</a></h2>
<p>
</p>
<h3><a name="drivers_without_sqldescribeparam">Drivers without SQLDescribeParam</a></h3>
<p>Some drivers do not support the <code>SQLDescribeParam</code> ODBC API (e.g.,
Microsoft Access, FreeTDS).</p>
<p>DBD::ODBC uses the <code>SQLDescribeParam</code> API when parameters are bound
to your SQL to find the types of the parameters. If the ODBC driver
does not support <code>SQLDescribeParam</code>, DBD::ODBC assumes the parameters
are <code>SQL_VARCHAR</code> or <code>SQL_WVARCHAR</code> types (depending on whether
DBD::ODBC is built for unicode or not). In any case, if you bind a
parameter and specify a SQL type this overrides any type DBD::ODBC
would choose.</p>
<p>For ODBC drivers which do not support <code>SQLDescribeParam</code> the default
behavior in DBD::ODBC may not be what you want. To change the default
parameter bind type set <a href="#odbc_default_bind_type">odbc_default_bind_type</a>. If, after that you
have some SQL where you need to vary the parameter types used add the
SQL type to the end of the <code>bind_param</code> method.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
  <span class="variable">$h</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">;</span>
  <span class="comment"># set the default bound parameter type</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">odbc_default_bind_type</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">SQL_VARCHAR</span><span class="operator">;</span>
  <span class="comment"># bind a parameter with a specific type</span>
  <span class="variable">$s</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q/insert into mytable values(?)/</span><span class="operator">);</span>
  <span class="variable">$s</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="string">"\x{263a}"</span><span class="operator">,</span> <span class="variable">SQL_WVARCHAR</span><span class="operator">);</span>
</pre>
<p>
</p>
<h2><a name="cpan_testers_reporting">CPAN Testers Reporting</a></h2>
<p>Please, please, please (is that enough), consider installing
CPAN::Reporter so that when you install perl modules a report of the
installation success or failure can be sent to cpan testers. In this
way module authors 1) get feedback on the fact that a module is being
installed 2) get to know if there are any installation problems. Also
other people like you may look at the test reports to see how
successful they are before choosing the version of a module to
install.</p>
<p>See this guide on how to get started with sending test reports:
<a href="http://wiki.cpantesters.org/wiki/QuickStart">http://wiki.cpantesters.org/wiki/QuickStart</a>.</p>
<p>
</p>
<h2><a name="others_todo">Others/todo?</a></h2>
<p>Level 2</p>
<pre>
    SQLColumnPrivileges
    SQLProcedureColumns
    SQLProcedures
    SQLTablePrivileges
    SQLDrivers
    SQLNativeSql</pre>
<p>
</p>
<h2><a name="random_links">Random Links</a></h2>
<p>These are in need of sorting and annotating. Some are relevant only
to ODBC developers.</p>
<p>You can find DBD::ODBC on ohloh now at:</p>
<p><a href="http://www.ohloh.net/projects/perl_dbd_odbc">http://www.ohloh.net/projects/perl_dbd_odbc</a></p>
<p>If you use ohloh and DBD::ODBC please say you use it and rate it.</p>
<p>There is a good search engine for the various Perl DBI lists at the
following URLS:</p>
<p><a href="http://perl.markmail.org/search/list:org.perl.dbi-users">http://perl.markmail.org/search/list:org.perl.dbi-users</a></p>
<p><a href="http://perl.markmail.org/search/list:org.perl.dbi-dev">http://perl.markmail.org/search/list:org.perl.dbi-dev</a></p>
<p><a href="http://perl.markmail.org/search/list:org.perl.dbi-announce">http://perl.markmail.org/search/list:org.perl.dbi-announce</a></p>
<p><a href="http://www.syware.com">http://www.syware.com</a></p>
<p><a href="http://www.microsoft.com/odbc">http://www.microsoft.com/odbc</a></p>
<p>For Linux/Unix folks, compatible ODBC driver managers can be found at:</p>
<p><a href="http://www.unixodbc.org">http://www.unixodbc.org</a> (unixODBC source and rpms)</p>
<p><a href="http://www.iodbc.org">http://www.iodbc.org</a> (iODBC driver manager source)</p>
<p>For Linux/Unix folks, you can checkout the following for ODBC Drivers and
Bridges:</p>
<p><a href="http://www.easysoft.com">http://www.easysoft.com</a></p>
<p><a href="http://www.openlinksw.com">http://www.openlinksw.com</a></p>
<p><a href="http://www.datadirect.com">http://www.datadirect.com</a></p>
<p><a href="http://www.atinet.com">http://www.atinet.com</a></p>
<p>Some useful tutorials:</p>
<p>Debugging Perl DBI:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/dbi-debugging.html">http://www.easysoft.com/developer/languages/perl/dbi-debugging.html</a></p>
<p>Enabling ODBC support in Perl with Perl DBI and DBD::ODBC:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/dbi_dbd_odbc.html">http://www.easysoft.com/developer/languages/perl/dbi_dbd_odbc.html</a></p>
<p>Perl DBI/DBD::ODBC Tutorial Part 1 - Drivers, Data Sources and Connection:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_1.html">http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_1.html</a></p>
<p>Perl DBI/DBD::ODBC Tutorial Part 2 - Introduction to retrieving data from your database:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_2.html">http://www.easysoft.com/developer/languages/perl/dbd_odbc_tutorial_part_2.html</a></p>
<p>Perl DBI/DBD::ODBC Tutorial Part 3 - Connecting Perl on UNIX or Linux to Microsoft SQL Server:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/sql_server_unix_tutorial.html">http://www.easysoft.com/developer/languages/perl/sql_server_unix_tutorial.html</a></p>
<p>Perl DBI - Put Your Data On The Web:</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/tutorial_data_web.html">http://www.easysoft.com/developer/languages/perl/tutorial_data_web.html</a></p>
<p>Multiple Active Statements (MAS) and DBD::ODBC</p>
<p><a href="http://www.easysoft.com/developer/languages/perl/multiple-active-statements.html">http://www.easysoft.com/developer/languages/perl/multiple-active-statements.html</a></p>
<p>
</p>
<h2><a name="frequently_asked_questions">Frequently Asked Questions</a></h2>
<p>Frequently asked questions are now in <a href="../../lib/DBD/ODBC/FAQ.html">the DBD::ODBC::FAQ manpage</a>. Run
<code>perldoc DBD::ODBC::FAQ</code> to view them.</p>
<p>
</p>
<hr />
<h1><a name="configuration_and_environment">CONFIGURATION AND ENVIRONMENT</a></h1>
<p>You should consult the documentation for the ODBC Driver Manager
you are using.</p>
<p>
</p>
<hr />
<h1><a name="dependencies">DEPENDENCIES</a></h1>
<p><a href="../../lib/DBI.html">the DBI manpage</a></p>
<p><a href="../../lib/Test/Simple.html">the Test::Simple manpage</a></p>
<p>
</p>
<hr />
<h1><a name="incompatibilities">INCOMPATIBILITIES</a></h1>
<p>None known.</p>
<p>
</p>
<hr />
<h1><a name="bugs_and_limitations">BUGS AND LIMITATIONS</a></h1>
<p>None known other than the deviations from the DBI specification mentioned
above in <a href="#deviations_from_the_dbi_specification">Deviations from the DBI specification</a>.</p>
<p>Please report any to me via the CPAN RT system. See
<a href="http://rt.cpan.org/">http://rt.cpan.org/</a> for more details.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Tim Bunce</p>
<p>Jeff Urlwin</p>
<p>Thomas K. Wenrich</p>
<p>Martin J. Evans</p>
<p>
</p>
<hr />
<h1><a name="license_and_copyright">LICENSE AND COPYRIGHT</a></h1>
<p>This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. See <a href="../../lib/pods/perlartistic.html">the perlartistic manpage</a>. This
program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.</p>
<p>Portions of this software are Copyright Tim Bunce, Thomas K. Wenrich,
Jeff Urlwin and Martin J. Evans - see the source.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../lib/DBI.html">the DBI manpage</a></p>

</body>

</html>
