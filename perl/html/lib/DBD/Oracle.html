<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>DBD::Oracle - Oracle database driver for the DBI module</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>DBD::Oracle - Oracle database driver for the DBI module</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#module_documentation">Module Documentation</a></li>
	<li><a href="#which_version_dbd__oracle_is_for_me">Which version DBD::Oracle is for me?</a></li>
	<li><a href="#constants">Constants</a></li>
	<li><a href="#the_dbi_class">The DBI Class</a></li>
	<ul>

		<li><a href="#dbi_class_methods">DBI Class Methods</a></li>
		<ul>

			<li><a href="#connect"><strong>connect</strong></a></li>
			<ul>

				<li><a href="#connecting_without_environment_variables_or_tnsnames_ora_file">Connecting without environment variables or tnsnames.ora file</a></li>
				<li><a href="#oracle_environment_variables">Oracle Environment Variables</a></li>
				<li><a href="#connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></li>
				<li><a href="#connecting_to_oracle">Connecting To Oracle</a></li>
				<li><a href="#connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></li>
				<li><a href="#timezones">Timezones</a></li>
				<li><a href="#oracle_drcp">Oracle DRCP</a></li>
				<li><a href="#taf__transparent_application_failover_">TAF (Transparent Application Failover)</a></li>
				<li><a href="#optimizing_oracle_s_listener">Optimizing Oracle's listener</a></li>
				<li><a href="#oracle_utilities">Oracle utilities</a></li>
			</ul>

			<li><a href="#private_connect_attributes">Private Connect Attributes</a></li>
			<ul>

				<li><a href="#ora_ncs_buff_mtpl">ora_ncs_buff_mtpl</a></li>
				<li><a href="#ora_drcp">ora_drcp</a></li>
				<li><a href="#ora_drcp_class">ora_drcp_class</a></li>
				<li><a href="#ora_drcp_min">ora_drcp_min</a></li>
				<li><a href="#ora_drcp_max">ora_drcp_max</a></li>
				<li><a href="#ora_drcp_incr">ora_drcp_incr</a></li>
				<li><a href="#ora_taf">ora_taf</a></li>
				<li><a href="#ora_taf_function">ora_taf_function</a></li>
				<li><a href="#ora_taf_sleep">ora_taf_sleep</a></li>
				<li><a href="#ora_session_mode">ora_session_mode</a></li>
				<li><a href="#ora_oratab_orahome">ora_oratab_orahome</a></li>
				<li><a href="#ora_module_name">ora_module_name</a></li>
				<li><a href="#ora_driver_name">ora_driver_name</a></li>
				<li><a href="#ora_client_info">ora_client_info</a></li>
				<li><a href="#ora_client_identifier">ora_client_identifier</a></li>
				<li><a href="#ora_action">ora_action</a></li>
				<li><a href="#ora_dbh_share">ora_dbh_share</a></li>
				<li><a href="#ora_envhp">ora_envhp</a></li>
				<li><a href="#ora_charset__ora_ncharset">ora_charset, ora_ncharset</a></li>
				<li><a href="#ora_verbose">ora_verbose</a></li>
				<li><a href="#ora_oci_success_warn">ora_oci_success_warn</a></li>
				<li><a href="#ora_objects">ora_objects</a></li>
				<li><a href="#ora_ph_type">ora_ph_type</a></li>
				<li><a href="#ora_parse_error_offset">ora_parse_error_offset</a></li>
				<li><a href="#ora_array_chunk_size">ora_array_chunk_size</a></li>
				<li><a href="#ora_connect_with_default_signals">ora_connect_with_default_signals</a></li>
			</ul>

			<li><a href="#connect_cached"><strong>connect_cached</strong></a></li>
			<li><a href="#data_sources"><strong>data_sources</strong></a></li>
		</ul>

		<li><a href="#methods_common_to_all_handles">Methods Common To All Handles</a></li>
		<ul>

			<li><a href="#err"><strong>err</strong></a></li>
			<li><a href="#errstr"><strong>errstr</strong></a></li>
			<li><a href="#state"><strong>state</strong></a></li>
			<li><a href="#trace"><strong>trace</strong></a></li>
			<li><a href="#trace_msg"><strong>trace_msg</strong></a></li>
			<li><a href="#parse_trace_flag_and_parse_trace_flags"><strong>parse_trace_flag</strong> and <strong>parse_trace_flags</strong></a></li>
			<li><a href="#func"><strong>func</strong></a></li>
			<li><a href="#private_database_handle_functions"><strong>Private database handle functions</strong></a></li>
			<li><a href="#plsql_errstr"><strong>plsql_errstr</strong></a></li>
			<li><a href="#dbms_output_enable___dbms_output_put___dbms_output_get"><strong>dbms_output_enable / dbms_output_put / dbms_output_get</strong></a></li>
			<li><a href="#dbms_output_enable_____buffer_size____"><strong>dbms_output_enable ( [ buffer_size ] )</strong></a></li>
			<li><a href="#dbms_output_put______lines____"><strong>dbms_output_put ( [ @lines ] )</strong></a></li>
			<li><a href="#dbms_output_get"><strong>dbms_output_get</strong></a></li>
			<li><a href="#reauthenticate____username___password__"><strong>reauthenticate ( $username, $password )</strong></a></li>
			<li><a href="#private_attribute_info"><strong>private_attribute_info</strong></a></li>
		</ul>

		<li><a href="#attributes_common_to_all_handles">Attributes Common To All Handles</a></li>
		<ul>

			<li><a href="#inactivedestroy__boolean_"><strong>InactiveDestroy</strong> (boolean)</a></li>
			<li><a href="#raiseerror__boolean__inherited_"><strong>RaiseError</strong> (boolean, inherited)</a></li>
			<li><a href="#printerror__boolean__inherited_"><strong>PrintError</strong> (boolean, inherited)</a></li>
			<li><a href="#showerrorstatement__boolean__inherited_"><strong>ShowErrorStatement</strong> (boolean, inherited)</a></li>
			<li><a href="#warn__boolean__inherited_"><strong>Warn</strong> (boolean, inherited)</a></li>
			<li><a href="#executed__boolean__read_only_"><strong>Executed</strong> (boolean, read-only)</a></li>
			<li><a href="#tracelevel__integer__inherited_"><strong>TraceLevel</strong> (integer, inherited)</a></li>
			<li><a href="#active__boolean__read_only_"><strong>Active</strong> (boolean, read-only)</a></li>
			<li><a href="#kids__integer__read_only_"><strong>Kids</strong> (integer, read-only)</a></li>
			<li><a href="#activekids__integer__read_only_"><strong>ActiveKids</strong> (integer, read-only)</a></li>
			<li><a href="#cachedkids__hash_ref_"><strong>CachedKids</strong> (hash ref)</a></li>
			<li><a href="#childhandles__array_ref_"><strong>ChildHandles</strong> (array ref)</a></li>
			<li><a href="#printwarn__boolean__inherited_"><strong>PrintWarn</strong> (boolean, inherited)</a></li>
			<li><a href="#handleerror__boolean__inherited_"><strong>HandleError</strong> (boolean, inherited)</a></li>
			<li><a href="#handleseterr__code_ref__inherited_"><strong>HandleSetErr</strong> (code ref, inherited)</a></li>
			<li><a href="#errcount__unsigned_integer_"><strong>ErrCount</strong> (unsigned integer)</a></li>
			<li><a href="#fetchhashkeyname__string__inherited_"><strong>FetchHashKeyName</strong> (string, inherited)</a></li>
			<li><a href="#chopblanks__boolean__inherited_"><strong>ChopBlanks</strong> (boolean, inherited)</a></li>
			<li><a href="#taint__boolean__inherited_"><strong>Taint</strong> (boolean, inherited)</a></li>
			<li><a href="#taintin__boolean__inherited_"><strong>TaintIn</strong> (boolean, inherited)</a></li>
			<li><a href="#taintout__boolean__inherited_"><strong>TaintOut</strong> (boolean, inherited)</a></li>
			<li><a href="#profile__inherited_"><strong>Profile</strong> (inherited)</a></li>
			<li><a href="#type__scalar_"><strong>Type</strong> (scalar)</a></li>
			<li><a href="#longreadlen"><strong>LongReadLen</strong></a></li>
			<li><a href="#longtruncok"><strong>LongTruncOk</strong></a></li>
			<li><a href="#compatmode"><strong>CompatMode</strong></a></li>
		</ul>

	</ul>

	<li><a href="#dbi_database_handle_object">DBI Database Handle Object</a></li>
	<ul>

		<li><a href="#database_handle_methods">Database Handle Methods</a></li>
		<ul>

			<li><a href="#selectall_arrayref"><strong>selectall_arrayref</strong></a></li>
			<li><a href="#selectall_hashref"><strong>selectall_hashref</strong></a></li>
			<li><a href="#selectcol_arrayref"><strong>selectcol_arrayref</strong></a></li>
			<li><a href="#prepare"><strong>prepare</strong></a></li>
			<ul>

				<li><a href="#prepare_attributes"><strong>Prepare Attributes</strong></a></li>
				<li><a href="#placeholders"><strong>Placeholders</strong></a></li>
			</ul>

			<li><a href="#prepare_cached"><strong>prepare_cached</strong></a></li>
			<li><a href="#do"><strong>do</strong></a></li>
			<li><a href="#last_insert_id"><strong>last_insert_id</strong></a></li>
			<li><a href="#commit"><strong>commit</strong></a></li>
			<li><a href="#rollback"><strong>rollback</strong></a></li>
			<li><a href="#begin_work"><strong>begin_work</strong></a></li>
			<li><a href="#disconnect"><strong>disconnect</strong></a></li>
			<li><a href="#ping"><strong>ping</strong></a></li>
			<li><a href="#get_info__"><strong>get_info()</strong></a></li>
			<li><a href="#table_info__"><strong>table_info()</strong></a></li>
			<li><a href="#primary_key_info__"><strong>primary_key_info()</strong></a></li>
			<li><a href="#foreign_key_info__"><strong>foreign_key_info()</strong></a></li>
			<li><a href="#column_info__"><strong>column_info()</strong></a></li>
			<li><a href="#selectrow_array"><strong>selectrow_array</strong></a></li>
			<li><a href="#selectrow_arrayref"><strong>selectrow_arrayref</strong></a></li>
			<li><a href="#selectrow_hashref"><strong>selectrow_hashref</strong></a></li>
			<li><a href="#clone"><strong>clone</strong></a></li>
		</ul>

		<li><a href="#private_database_handle_methods">Private Database Handle Methods</a></li>
		<ul>

			<li><a href="#ora_can_unicode______refresh____"><strong>ora_can_unicode ( [ $refresh ] )</strong></a></li>
			<li><a href="#ora_can_taf"><strong>ora_can_taf</strong></a></li>
			<li><a href="#ora_nls_parameters______refresh____"><strong>ora_nls_parameters ( [ $refresh ] )</strong></a></li>
		</ul>

		<li><a href="#database_handle_attributes">Database Handle Attributes</a></li>
		<ul>

			<li><a href="#autocommit__boolean_"><strong>AutoCommit</strong> (boolean)</a></li>
			<li><a href="#readonly__boolean_"><strong>ReadOnly</strong> (boolean)</a></li>
			<li><a href="#name__string__read_only_"><strong>Name</strong> (string, read-only)</a></li>
			<li><a href="#username__string__read_only_"><strong>Username</strong> (string, read-only)</a></li>
			<li><a href="#driver__handle__read_only_"><strong>Driver</strong> (handle, read-only)</a></li>
			<li><a href="#rowcachesize"><strong>RowCacheSize</strong></a></li>
			<ul>

				<li><a href="#row_caching"><strong>Row Caching</strong></a></li>
				<li><a href="#row_prefetching">Row Prefetching</a></li>
			</ul>

		</ul>

	</ul>

	<li><a href="#dbi_statement_handle_object">DBI Statement Handle Object</a></li>
	<ul>

		<li><a href="#statement_handle_methods">Statement Handle Methods</a></li>
		<ul>

			<li><a href="#bind_param"><strong>bind_param</strong></a></li>
			<li><a href="#optimizing_results">Optimizing Results</a></li>
			<ul>

				<li><a href="#prepare_postponed_till_execute">Prepare Postponed Till Execute</a></li>
			</ul>

			<li><a href="#spaces___padding">Spaces &amp; Padding</a></li>
			<ul>

				<li><a href="#trailing_spaces">Trailing Spaces</a></li>
				<li><a href="#padded_char_fields">Padded Char Fields</a></li>
				<li><a href="#unicode">Unicode</a></li>
				<li><a href="#perl_and_unicode">Perl and Unicode</a></li>
				<li><a href="#oracle_and_unicode">Oracle and Unicode</a></li>
				<li><a href="#oracle_utf8_is_not_utf_8">Oracle UTF8 is not UTF-8</a></li>
				<li><a href="#dbd__oracle_and_unicode">DBD::Oracle and Unicode</a></li>
				<li><a href="#dbd__oracle_and_other_character_sets_and_encodings">DBD::Oracle and Other Character Sets and Encodings</a></li>
				<li><a href="#other_data_types">Other Data Types</a></li>
				<li><a href="#object___collection_data_types">Object &amp; Collection Data Types</a></li>
				<li><a href="#support_for_insert_of_xmltype__ora_xmltype_">Support for Insert of XMLType (ORA_XMLTYPE)</a></li>
				<li><a href="#binding_cursors">Binding Cursors</a></li>
				<li><a href="#fetching_nested_cursors">Fetching Nested Cursors</a></li>
				<li><a href="#pre_fetching_nested_cursors">Pre-fetching Nested Cursors</a></li>
			</ul>

			<li><a href="#bind_param_inout"><strong>bind_param_inout</strong></a></li>
			<ul>

				<li><a href="#returning_a_value_from_an_insert"><strong>Returning A Value from an INSERT</strong></a></li>
				<li><a href="#returning_a_recordset">Returning A Recordset</a></li>
				<li><a href="#sys_dbms_sql_datatypes"><strong>SYS.DBMS_SQL datatypes</strong></a></li>
				<li><a href="#ora_varchar2_table"><strong>ORA_VARCHAR2_TABLE</strong></a></li>
				<li><a href="#ora_number_table"><strong>ORA_NUMBER_TABLE</strong></a></li>
			</ul>

			<li><a href="#bind_param_inout_array"><strong>bind_param_inout_array</strong></a></li>
			<li><a href="#bind_param_array"><strong>bind_param_array</strong></a></li>
			<li><a href="#execute"><strong>execute</strong></a></li>
			<li><a href="#execute_array"><strong>execute_array</strong></a></li>
			<li><a href="#execute_for_fetch"><strong>execute_for_fetch</strong></a></li>
			<li><a href="#fetchrow_arrayref"><strong>fetchrow_arrayref</strong></a></li>
			<li><a href="#fetchrow_array"><strong>fetchrow_array</strong></a></li>
			<li><a href="#fetchrow_hashref"><strong>fetchrow_hashref</strong></a></li>
			<li><a href="#fetchall_arrayref"><strong>fetchall_arrayref</strong></a></li>
			<li><a href="#fetchall_hashref"><strong>fetchall_hashref</strong></a></li>
			<li><a href="#finish"><strong>finish</strong></a></li>
			<li><a href="#rows"><strong>rows</strong></a></li>
			<li><a href="#bind_col"><strong>bind_col</strong></a></li>
			<li><a href="#bind_columns"><strong>bind_columns</strong></a></li>
			<li><a href="#dump_results"><strong>dump_results</strong></a></li>
		</ul>

		<li><a href="#private_statement_handle_methods">Private Statement Handle Methods</a></li>
		<ul>

			<li><a href="#ora_stmt_type"><strong>ora_stmt_type</strong></a></li>
			<li><a href="#ora_stmt_type_name"><strong>ora_stmt_type_name</strong></a></li>
		</ul>

		<li><a href="#statement_handle_attributes">Statement Handle Attributes</a></li>
		<ul>

			<li><a href="#num_of_fields__integer__read_only_"><strong>NUM_OF_FIELDS</strong> (integer, read-only)</a></li>
			<li><a href="#num_of_params__integer__read_only_"><strong>NUM_OF_PARAMS</strong> (integer, read-only)</a></li>
			<li><a href="#name__arrayref__read_only_"><strong>NAME</strong> (arrayref, read-only)</a></li>
			<li><a href="#name_lc__arrayref__read_only_"><strong>NAME_lc</strong> (arrayref, read-only)</a></li>
			<li><a href="#name_uc__arrayref__read_only_"><strong>NAME_uc</strong>  (arrayref, read-only)</a></li>
			<li><a href="#name_hash__hashref__read_only_"><strong>NAME_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#name_lc_hash__hashref__read_only_"><strong>NAME_lc_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#name_uc_hash__hashref__read_only_"><strong>NAME_uc_hash</strong> (hashref, read-only)</a></li>
			<li><a href="#type__arrayref__read_only_"><strong>TYPE</strong> (arrayref, read-only)</a></li>
			<li><a href="#precision__arrayref__read_only_"><strong>PRECISION</strong> (arrayref, read-only)</a></li>
			<li><a href="#scale__arrayref__read_only_"><strong>SCALE</strong> (arrayref, read-only)</a></li>
			<li><a href="#nullable__arrayref__read_only_"><strong>NULLABLE</strong> (arrayref, read-only)</a></li>
			<li><a href="#database__dbh__read_only_"><strong>Database</strong> (dbh, read-only)</a></li>
			<li><a href="#paramvalues__hash_ref__read_only_"><strong>ParamValues</strong> (hash ref, read-only)</a></li>
			<li><a href="#paramtypes__hash_ref__read_only_"><strong>ParamTypes</strong> (hash ref, read-only)</a></li>
			<li><a href="#statement__string__read_only_"><strong>Statement</strong> (string, read-only)</a></li>
			<li><a href="#rowsincache"><strong>RowsInCache</strong></a></li>
		</ul>

		<li><a href="#scrollable_cursors">Scrollable Cursors</a></li>
		<ul>

			<li><a href="#enabling_scrollable_cursors"><strong>Enabling Scrollable Cursors</strong></a></li>
			<li><a href="#scrollable_cursor_methods"><strong>Scrollable Cursor Methods</strong></a></li>
			<li><a href="#scrollable_cursor_usage"><strong>Scrollable Cursor Usage</strong></a></li>
		</ul>

		<li><a href="#lobs_and_longs">LOBs and LONGs</a></li>
		<ul>

			<li><a href="#data_interface_for_persistent_lobs"><strong>Data Interface for Persistent LOBs</strong></a></li>
			<ul>

				<li><a href="#simple_fetch_for_longs_and_long_raws">Simple Fetch for LONGs and LONG RAWs</a></li>
				<li><a href="#using_ora_ncs_buff_mtpl">Using ora_ncs_buff_mtpl</a></li>
				<li><a href="#simple_fetch_for_clobs_and_blobs">Simple Fetch for CLOBs and BLOBs</a></li>
				<li><a href="#piecewise_fetch_with_callback">Piecewise Fetch with Callback</a></li>
				<li><a href="#piecewise_fetch_with_polling">Piecewise Fetch with Polling</a></li>
				<li><a href="#binding_for_updates_and_inserts_for_clobs_and_blobs">Binding for Updates and Inserts for CLOBs and  BLOBs</a></li>
				<li><a href="#support_for_remote_lobs_">Support for Remote LOBs;</a></li>
			</ul>

			<li><a href="#locator_data_interface"><strong>Locator Data Interface</strong></a></li>
			<ul>

				<li><a href="#simple_usage">Simple Usage</a></li>
				<li><a href="#lob_support_in_pl_sql">LOB support in PL/SQL</a></li>
			</ul>

			<li><a href="#persistent___locator_interface_caveats"><strong>Persistent &amp; Locator Interface Caveats</strong></a></li>
			<li><a href="#data_interface_for_lob_locators"><strong>Data Interface for LOB Locators</strong></a></li>
			<ul>

				<li><a href="#lob_locator_method_examples">LOB Locator Method Examples</a></li>
				<li><a href="#example__inserting_a_new_row_with_large_data">Example: Inserting a new row with large data</a></li>
				<li><a href="#example__updating_an_existing_row_with_large_data">Example: Updating an existing row with large data</a></li>
				<li><a href="#example__streaming_character_data_from_the_database">Example: Streaming character data from the database</a></li>
				<li><a href="#example__truncating_existing_large_data">Example: Truncating existing large data</a></li>
			</ul>

		</ul>

	</ul>

	<li><a href="#pl_sql_examples">PL/SQL Examples</a></li>
	<ul>

		<li><a href="#avoid_using_sql_call">Avoid Using &quot;SQL Call&quot;</a></li>
	</ul>

	<li><a href="#contributing">CONTRIBUTING</a></li>
	<ul>

		<li><a href="#how_to_create_a_patch_using_subversion">How to create a patch using Subversion</a></li>
		<li><a href="#how_to_create_a_patch_without_subversion">How to create a patch without Subversion</a></li>
		<li><a href="#speak_before_you_patch">Speak before you patch</a></li>
	</ul>

	<li><a href="#oracle_related_links">Oracle Related Links</a></li>
	<ul>

		<li><a href="#dbd__oracle_tutorial">DBD::Oracle Tutorial</a></li>
		<li><a href="#oracle_instant_client">Oracle Instant Client</a></li>
		<li><a href="#oracle_on_linux">Oracle on Linux</a></li>
		<li><a href="#free_oracle_tools_and_links">Free Oracle Tools and Links</a></li>
		<li><a href="#commercial_oracle_tools_and_links">Commercial Oracle Tools and Links</a></li>
	</ul>

	<li><a href="#bugs_and_limitations">BUGS AND LIMITATIONS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#acknowledgements">ACKNOWLEDGEMENTS</a></li>
	<li><a href="#maintainer">MAINTAINER</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>DBD::Oracle - Oracle database driver for the DBI module</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:host=</span><span class="variable">$host</span><span class="string">;sid=</span><span class="variable">$sid</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># See the DBI module documentation for full details</span>
</pre>
<pre>
  <span class="comment"># for some advanced uses you may need Oracle type values:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>DBD::Oracle is a Perl module which works with the DBI module to provide
access to Oracle databases.</p>
<p>
</p>
<hr />
<h1><a name="module_documentation">Module Documentation</a></h1>
<p>This documentation describes driver specific behaviour and restrictions. It is
not supposed to be used as the only reference for the user. In any case
consult the <strong>DBI</strong> documentation first!</p>
<a href="http://search.cpan.org/~timb/DBI/DBI.pm">Latest DBI documentation.</a><p>
</p>
<hr />
<h1><a name="which_version_dbd__oracle_is_for_me">Which version DBD::Oracle is for me?</a></h1>
<p>From version 1.25 onwards DBD::Oracle will only support Oracle clients
9.2 or greater. Support for ProC connections was dropped in 1.29.</p>
<p>If you are still stuck with an older version of Oracle or its client you might want to look at the table below.</p>
<pre>
  +---------------------+-----------------------------------------------------+
  |                     |                   Oracle Version                    |
  +---------------------+----+-------------+---------+------+--------+--------+
  | DBD::Oracle Version | &lt;8 | 8.0.3~8.0.6 | 8iR1~R2 | 8iR3 |   9i   | 9.2~11 |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      0.1~16         | Y  |      Y      |    Y    |  Y   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.17           | Y  |      Y      |    Y    |  Y   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.18           | N  |      N      |    N    |  Y   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.19           | N  |      N      |    N    |  Y   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.20           | N  |      N      |    N    |  Y   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.21~1.24      | N  |      N      |    N    |  N   |    Y   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+
  |      1.25+          | N  |      N      |    N    |  N   |    N   |    Y   |
  +---------------------+----+-------------+---------+------+--------+--------+</pre>
<p>As there are dozens of different versions of Oracle's clients this
list does not include all of them, just the major released versions of
Oracle.</p>
<p>Note that one can still connect to any Oracle version with the older
DBD::Oracle versions the only problem you will have is that some of
the newer OCI and Oracle features available in later DBD::Oracle
releases will not be available to you.</p>
<p>So to make a short story a little longer;</p>
<pre>
  1) If you are using Oracle 7 or early 8 DB and you can manage to get a 9 client and you can use
     any DBD::Oracle version.
  2) If you have to use an Oracle 7 client then DBD::Oracle 1.17 should work
  3) Same thing for 8 up to R2, use 1.17, if you are lucky and have the right patch-set you might
     go with 1.18.
  4) For 8iR3 you can use any of the DBD::Oracle versions up to 1.21. Again this depends on your
     patch-set, If you run into trouble go with 1.19
  5) After 9.2 you can use any version you want.
  6) For you Luddites out there ORAPERL still works and is still included but not updated or supported anymore and was removed in 1.29.
  7) It seems that the 10g client can only connect to 9 and 11 DBs while the 9 can go back to 7
     and even get to 10. I am not sure what the 11g client can connect to.</pre>
<p>
</p>
<hr />
<h1><a name="constants">Constants</a></h1>
<dl>
<dt><strong><a name="ora_session_modes" class="item">:ora_session_modes</a></strong></dt>

<dd>
<p>ORA_SYSDBA ORA_SYSOPER</p>
</dd>
<dt><strong><a name="ora_types" class="item">:ora_types</a></strong></dt>

<dd>
<pre>
  ORA_VARCHAR2 ORA_STRING ORA_NUMBER ORA_LONG ORA_ROWID ORA_DATE ORA_RAW
  ORA_LONGRAW ORA_CHAR ORA_CHARZ ORA_MLSLABEL ORA_XMLTYPE ORA_CLOB ORA_BLOB
  ORA_RSET ORA_VARCHAR2_TABLE ORA_NUMBER_TABLE SQLT_INT SQLT_FLT ORA_OCI
  SQLT_CHR SQLT_BIN</pre>
</dd>
<dt><strong><a name="sqlcs_implicit" class="item">SQLCS_IMPLICIT</a></strong></dt>

<dt><strong><a name="sqlcs_nchar" class="item">SQLCS_NCHAR</a></strong></dt>

<dd>
<p>SQLCS_IMPLICIT and SQLCS_NCHAR are <em>character set form</em> values.
See notes about Unicode elsewhere in this document.</p>
</dd>
<dt><strong><a name="sqlt_int" class="item">SQLT_INT</a></strong></dt>

<dt><strong><a name="sqlt_flt" class="item">SQLT_FLT</a></strong></dt>

<dd>
<p>These types are used only internally, and may be specified as internal
bind type for ORA_NUMBER_TABLE. See notes about ORA_NUMBER_TABLE elsewhere
in this document</p>
</dd>
<dt><strong><a name="ora_oci" class="item">ORA_OCI</a></strong></dt>

<dd>
<p>Oracle doesn't provide a formal API for determining the exact version
number of the OCI client library used, so DBD::Oracle has to go digging
(and sometimes has to more or less guess).  The ORA_OCI constant
holds the result of that process.</p>
<p>In string context ORA_OCI returns the full &quot;A.B.C.D&quot; version string.</p>
<p>In numeric context ORA_OCI returns the major.minor version number
(8.1, 9.2, 10.0 etc).  But note that version numbers are not actually
floating point and so if Oracle ever makes a release that has a two
digit minor version, such as <code>9.10</code> it will have a lower numeric
value than the preceding <code>9.9</code> release. So use with care.</p>
<p>The contents and format of ORA_OCI are subject to change (it may,
for example, become a <em>version object</em> in later releases).
I recommend that you avoid checking for exact values.</p>
</dd>
<dt><strong><a name="ora_fetch_orient" class="item">:ora_fetch_orient</a></strong></dt>

<dd>
<pre>
  OCI_FETCH_CURRENT OCI_FETCH_NEXT OCI_FETCH_FIRST OCI_FETCH_LAST
  OCI_FETCH_PRIOR OCI_FETCH_ABSOLUTE OCI_FETCH_RELATIVE</pre>
<p>These constants are used to set the orientation of a fetch on a scrollable cursor.</p>
</dd>
<dt><strong><a name="ora_exe_modes" class="item">:ora_exe_modes</a></strong></dt>

<dd>
<pre>
  OCI_STMT_SCROLLABLE_READONLY</pre>
</dd>
<dt><strong><a name="ora_fail_over" class="item">:ora_fail_over</a></strong></dt>

<dd>
<pre>
  OCI_FO_END OCI_FO_ABORT OCI_FO_REAUTH OCI_FO_BEGIN OCI_FO_ERROR
  OCI_FO_NONE OCI_FO_SESSION OCI_FO_SELECT OCI_FO_TXNAL</pre>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="the_dbi_class">The DBI Class</a></h1>
<p>
</p>
<h2><a name="dbi_class_methods">DBI Class Methods</a></h2>
<p>
</p>
<h3><a name="connect"><strong>connect</strong></a></h3>
<p>This method creates a database handle by connecting to a database, and is the DBI
equivalent of the &quot;new&quot; method.</p>
<p>This is a topic which often causes problems. Mainly due to Oracle's many
and sometimes complex ways of specifying and connecting to databases.
James Taylor and Lane Sharman have contributed much of the text in
this section. Unfortunately it is only really relative for connecting into older Oracle (&lt;9) versions.
Most of this stuff is well out of date  but it will be left in for now.
See the next section <a href="#connecting_to_oracle">Connecting To Oracle</a> for some more up to date connection hints.</p>
<p>
</p>
<h4><a name="connecting_without_environment_variables_or_tnsnames_ora_file">Connecting without environment variables or tnsnames.ora file</a></h4>
<p>If you use the <code>host=$host;sid=$sid</code> style syntax, for example:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:host=myhost.com;sid=ORCL"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<p>then DBD::Oracle will construct a full connection descriptor string
for you and Oracle will not need to consult the tnsnames.ora file.</p>
<p>If a <code>port</code> number is not specified then the descriptor will try both
1526 and 1521 in that order (e.g., new then old).  You can check which
port(s) are in use by typing &quot;$ORACLE_HOME/bin/lsnrctl stat&quot; on the server.</p>
<p>
</p>
<h4><a name="oracle_environment_variables">Oracle Environment Variables</a></h4>
<p>Oracle typically no longer needs two environment variables to specify default
connections: ORACLE_SID and TWO_TASK.</p>
<p>ORACLE_SID is really unnecessary to set since TWO_TASK provides the
same functionality in addition to allowing remote connections.</p>
<pre>
  % setenv //xxx.yyy.zzz:1521/ORACLE_SID           # for csh shell
  $ TWO_TASK=T:hostname:ORACLE_SID export TWO_TASK   # for sh shell</pre>
<pre>
  % sqlplus username/password</pre>
<p>Note that if you have *both* local and remote databases, and you
have ORACLE_SID *and* TWO_TASK set, and you don't specify a fully
qualified connect string on the command line, TWO_TASK takes precedence
over ORACLE_SID (i.e. you get connected to remote system).</p>
<pre>
  TWO_TASK=P:sid</pre>
<p>will use the pipe driver for local connections using SQL*Net v1.</p>
<pre>
  TWO_TASK=T:machine:sid</pre>
<p>will use TCP/IP (or D for DECNET, etc.) for remote SQL*Net v1 connection.</p>
<pre>
  TWO_TASK=dbname</pre>
<p>will use the info stored in the SQL*Net v2 <em class="file">tnsnames.ora</em>
configuration file for local or remote connections.</p>
<p>Support for 'T:' syntax of Oracle SQL*Net V1 is only supported on older 7 clients and
I have my doubts it will even work if the DB or client has been patched and I know it
will not work on any later clients.</p>
<p>The ORACLE_HOME environment variable should be set correctly.
In general, the value used should match the version of Oracle that
was used to build DBD::Oracle.  If using dynamic linking then
ORACLE_HOME should match the version of Oracle that will be used
to load in the Oracle client libraries (via LD_LIBRARY_PATH, ldconfig,
or similar on Unix).</p>
<p>ORACLE_HOME can be left unset if you aren't using any of Oracle's
executables, but it is <em>not</em> recommended and error messages may not display.
It should be set to the ORACLE_HOME directory of the version of Oracle
that DBD::Oracle was compiled with.</p>
<p>Discouraging the use of ORACLE_SID makes it easier on the users to see
what is going on. (It's unfortunate that TWO_TASK couldn't be renamed,
since it makes no sense to the end user, and doesn't have the ORACLE prefix).</p>
<p>Also remember that depending on the operating system you are using
the differing &quot;ORACLE&quot; environment variables may be case sensitive, so if you are not connecting
as you should double check the case of both the variable and its value.</p>
<p>
</p>
<h4><a name="connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></h4>
<p>First, how to connect to a local database <em>without</em> using a Listener:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:SID'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
</pre>
<p>you can also leave the SID empty:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
</pre>
<p>in which case Oracle client code will use the ORACLE_SID environment
variable (if the TWO_TASK environment varariable is not defined).</p>
<p>Below are various ways of connecting to an Oracle database using
SQL*Net 1.x and SQL*Net 2.x.  &quot;Machine&quot; is the computer the database is
running on, &quot;SID&quot; is the SID of the database, &quot;DB&quot; is the SQL*Net 2.x
connection descriptor for the database.</p>
<p><strong>Note:</strong> Some of these formats may not work with Oracle 9+.</p>
<pre>
  <span class="keyword">BEGIN</span> <span class="operator">{</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_HOME</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'/home/oracle/product/10.x.x'</span><span class="operator">;</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TWO_TASK</span><span class="operator">}</span>    <span class="operator">=</span> <span class="string">'DB'</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
  <span class="comment">#  - or -</span>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott/tiger'</span><span class="operator">);</span>
</pre>
<p>Refer to your Oracle documentation for valid values of TWO_TASK.</p>
<p>Here are some variations (not setting TWO_TASK) in order of preference:</p>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB','username','password')</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB','username/password','')</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:','username@DB','password')</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:host=foobar;sid=ORCL;port=1521'</span><span class="operator">,</span> <span class="string">'scott/tiger'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">)</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span> <span class="string">q{scott/tiger@(DESCRIPTION=
  (ADDRESS=(PROTOCOL=TCP)(HOST= foobar)(PORT=1521))
  (CONNECT_DATA=(SID=ORCL)))}</span><span class="operator">,</span> <span class="string">""</span><span class="operator">)</span>
</pre>
<p>If you are having problems with login taking a long time (&gt;10 seconds say)
then you might have tripped up on an Oracle bug. You can try using one
of the ...@DB variants as a workaround. e.g.,</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span><span class="string">'username/password@DB'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>On the other hand, that may cause you to trip up on another Oracle bug
that causes alternating connection attempts to fail! (in reality only
a small proportion of people experience these problems)</p>
<p>To connect to a local database with a user which has been set up to
authenticate via the OS (&quot;ALTER USER username IDENTIFIED EXTERNALLY&quot;):</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'/'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>Note the lack of a connection name (use the ORACLE_SID environment
variable). If an explicit SID is used you will probably get an ORA-01004 error.</p>
<p>That only works for local databases. (Authentication to remote Oracle
databases using your Unix login name without a password is possible
but it is not secure and not recommended so not documented here.</p>
<p>
</p>
<h4><a name="connecting_to_oracle">Connecting To Oracle</a></h4>
<p>If you are reading this it is assumed that you have successfully
installed DBD::Oracle and you are having some problems connecting to
Oracle.</p>
<p>First off you will have to tell DBD::Oracle where the binaries reside
for the Oracle client it was compiled against.  This is the case when
you encounter a</p>
<pre>
 DBI connect('','system',...) failed: ERROR OCIEnvNlsCreate.</pre>
<p>error in Linux or in Windows when you get</p>
<pre>
  OCI.DLL not found</pre>
<p>The solution to this problem in the case of Linux is to ensure your
'ORACLE_HOME' (or LD_LIBRARY_PATH for InstantClient) environment
variable points to the correct directory.</p>
<pre>
  export ORACLE_HOME=/app/oracle/product/xx.x.x</pre>
<p>For Windows the solution is to add this value to you PATH</p>
<pre>
  <span class="variable">PATH</span><span class="operator">=</span><span class="variable">c</span><span class="operator">:\</span><span class="variable">app</span><span class="operator">\</span><span class="variable">oracle</span><span class="operator">\</span><span class="variable">product</span><span class="operator">\</span><span class="variable">xx</span><span class="operator">.x.x;</span><span class="variable">%PATH</span><span class="operator">%
  </span>
</pre>
<p>If you get past this stage and get a</p>
<pre>
  ORA-12154: TNS:could not resolve the connect identifier specified</pre>
<p>error then the most likely cause is DBD::ORACLE cannot find your .ORA
(<em class="file">TNSNAMES.ORA</em>, <em class="file">LISTENER.ORA</em>, <em class="file">SQLNET.ORA</em>) files. This can be
solved by setting the TNS_ADMIN environment variable to the directory
where these files can be found.</p>
<p>If you get to this stage and you have either one of the following
errors;</p>
<pre>
  ORA-12560: TNS:protocol adapter error
  ORA-12162: TNS:net service name is incorrectly specified</pre>
<p>usually means that DBD::Oracle can find the listener but the it cannot connect to the DB because the listener cannot find the DB you asked for.</p>
<p>
</p>
<h4><a name="connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></h4>
<p>It is best to not use ORACLE_SID or TWO_TASK as both of these are rather out of date. You are better off keeping it simple like the following examples</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:DB'</span><span class="operator">,</span><span class="string">'username'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:DB'</span><span class="operator">,</span><span class="string">'username/password'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'username@DB'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:host=foobar;sid=DB;port=1521'</span><span class="operator">,</span> <span class="string">'scott/tiger'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
</pre>
<p>For those who really want to use ORACLE_SID and TWO_TASK here are examples of it in use;</p>
<p>Given this TNS entry;</p>
<pre>
 DB.TEST =
    (DESCRIPTION =
         (ADDRESS =
            (PROTOCOL = TCP)
            (HOST = xxx.xxx.xxx.xx)
            (PORT = 1523))
         (CONNECT_DATA =      (SID = DB)    )
)</pre>
<p>and this code</p>
<pre>
  <span class="keyword">BEGIN</span> <span class="operator">{</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'DB'</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'username/password'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>you will be able to connect to DB. Note this may not work for Windows.</p>
<p>TWO_TASK works the same way except it should override the value in ORACLE_SID so this</p>
<pre>
  <span class="keyword">BEGIN</span> <span class="operator">{</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'DB'</span><span class="operator">;</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TWO_TASK</span><span class="operator">}</span>  <span class="operator">=</span> <span class="string">'DB.TEST'</span><span class="operator">;</span>
</pre>
<pre>
  }</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'username/password'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>will work as well. Note this may not work for Windows.</p>
<p>
</p>
<h4><a name="timezones">Timezones</a></h4>
<p>If TWO_TASK isn't set, Oracle uses the TZ variable from the local environment.</p>
<p>If TWO_TASK IS set, Oracle uses the TZ variable of the listener process
running on the server.</p>
<p>You could have multiple listeners, each with their own TZ, and assign
users to the appropriate listener by setting TNS_ADMIN to a directory
that contains a tnsnames.ora file that points to the port that their
listener is on.</p>
<p>[Brad Howerter, who supplied this info said: &quot;I've done this to simulate
running a Perl script at the end of the previous month even though it
was the 6th of the new month.  I had the dba start up a listener with
TZ=X+144.  (144 hours = 6 days)&quot;]</p>
<p>
</p>
<h4><a name="oracle_drcp">Oracle DRCP</a></h4>
<p>DBD::Oracle now supports DRCP (Database Resident Connection Pool) so
if you have an 11.2 database and DRCP is enabled you can now direct
all of your connections to it by simply adding ':POOLED' to the SID or
setting a connection attribute of ora_drcp, or set the SERVER=POOLED
when using a TNSENTRY style connection or even by setting an
environment variable ORA_DRCP.  All of which are demonstrated below;</p>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB:POOLED','username','password')</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:','username@DB:POOLED','password')</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:DB'</span><span class="operator">,</span><span class="string">'username'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_drcp</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">)</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:DB'</span><span class="operator">,</span><span class="string">'username'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_drcp</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span>
                                                             <span class="string">ora_drcp_class</span><span class="operator">=&gt;</span><span class="string">'my_app'</span><span class="operator">,</span>
                                                             <span class="string">ora_drcp_min</span>  <span class="operator">=&gt;</span><span class="number">10</span><span class="operator">}</span><span class="operator">)</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:host=foobar;sid=ORCL;port=1521;SERVER=POOLED'</span><span class="operator">,</span> <span class="string">'scott/tiger'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">)</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span> <span class="string">q{scott/tiger@(DESCRIPTION=
  (ADDRESS=(PROTOCOL=TCP)(HOST= foobar)(PORT=1521))
  (CONNECT_DATA=(SID=ORCL)(SERVER=POOLED)))}</span><span class="operator">,</span> <span class="string">""</span><span class="operator">)</span>
</pre>
<pre>
  if the ORA_DRCP environment variable is set then just this</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB','username','password')</pre>
<p>You can find a white paper on setting up DRCP and its advantages at <a href="http://www.oracle.com/technology/tech/oci/pdf/oracledrcp11g.pdf">http://www.oracle.com/technology/tech/oci/pdf/oracledrcp11g.pdf</a>.</p>
<p>Please note that DRCP support in DBD::Oracle is relatively new so the
mechanics or its implementation are subject to change.</p>
<p>
</p>
<h4><a name="taf__transparent_application_failover_">TAF (Transparent Application Failover)</a></h4>
<p>Transparent Application Failover (TAF) is the feature in OCI that
allows for clients to automatically reconnect to an instance in the
event of a failure of the instance. The reconnect happens
automatically from within the OCI (Oracle Call Interface) library.
DBD::Oracle now supports a callback function that will fire when a TAF
event takes place. The main use of the callback is to give your
program the opportunity to inform the user that a failover is taking
place.</p>
<p>You will have to set up TAF on your instance before you can use this
callback.  You can test your instance to see if you can use TAF
callback with</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_can_taf</span><span class="operator">();</span>
</pre>
<p>If you try to set up a callback without it being enabled DBD::Oracle will croak.</p>
<p>It is outside the scope of this documents to go through all of the
possible TAF situations you might want to set up but here is a simple
example:</p>
<p>The TNS entry for the instance has had the following added to the
CONNECT_DATA section</p>
<pre>
   (FAILOVER_MODE=
               (TYPE=select)
               (METHOD=basic)
               (RETRIES=10)
               (DELAY=10))</pre>
<p>You will also have to create your own perl function that will be
called from the client.  You can name it anything you want and it will
always be passed two parameters, the failover event value and the
failover type.  You can also set a sleep value in case of failover
error and the OCI client will sleep for the specified seconds before it
attempts another event.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span><span class="operator">(</span><span class="string">qw(:ora_fail_over)</span><span class="operator">);</span>
  <span class="comment">#import the ora fail over constants</span>
</pre>
<pre>
  <span class="comment">#set up TAF on the connection</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:XE'</span><span class="operator">,</span><span class="string">'hr'</span><span class="operator">,</span><span class="string">'hr'</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_taf</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">taf_sleep</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">,</span><span class="string">ora_taf_function</span><span class="operator">=&gt;</span><span class="string">'handle_taft'</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">#create the perl TAF event function</span>
</pre>
<pre>
  <span class="keyword">sub</span><span class="variable"> handle_taf </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$fo_event</span><span class="operator">,</span><span class="variable">$fo_type</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$fo_event</span> <span class="operator">==</span> <span class="variable">OCI_FO_BEGIN</span><span class="operator">){</span>
</pre>
<pre>
      <span class="keyword">print</span> <span class="string">" Instance Unavailable Please stand by!! \n"</span><span class="operator">;</span>
      <span class="keyword">printf</span><span class="operator">(</span><span class="string">" Your TAF type is %s \n"</span><span class="operator">,</span>
                       <span class="operator">((</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_NONE</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"NONE"</span>
                       <span class="operator">:(</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_SESSION</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"SESSION"</span>
                       <span class="operator">:(</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_SELECT</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"SELECT"</span>
                       <span class="operator">:</span> <span class="string">"UNKNOWN!"</span><span class="operator">));</span>
          <span class="operator">}</span>
          <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$fo_event</span> <span class="operator">==</span> <span class="variable">OCI_FO_ABORT</span><span class="operator">){</span>
       <span class="keyword">print</span> <span class="string">" Failover aborted. Failover will not take place.\n"</span><span class="operator">;</span>
          <span class="operator">}</span>
          <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$fo_event</span> <span class="operator">==</span> <span class="variable">OCI_FO_END</span><span class="operator">){</span>
       <span class="keyword">printf</span><span class="operator">(</span><span class="string">" Failover ended ...Resuming your %s\n"</span><span class="operator">,((</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_NONE</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"NONE"</span>
                                                      <span class="operator">:(</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_SESSION</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"SESSION"</span>
                                                      <span class="operator">:(</span><span class="variable">$fo_type</span><span class="operator">==</span><span class="variable">OCI_FO_SELECT</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"SELECT"</span>
                                                      <span class="operator">:</span> <span class="string">"UNKNOWN!"</span><span class="operator">));</span>
          <span class="operator">}</span>
          <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$fo_event</span> <span class="operator">==</span> <span class="variable">OCI_FO_REAUTH</span><span class="operator">){</span>
       <span class="keyword">print</span> <span class="string">" Failed over user. Resuming services\n"</span><span class="operator">;</span>
          <span class="operator">}</span>
          <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$fo_event</span> <span class="operator">==</span> <span class="variable">OCI_FO_ERROR</span><span class="operator">){</span>
       <span class="keyword">print</span> <span class="string">" Failover error Sleeping...\n"</span><span class="operator">;</span>
          <span class="operator">}</span>
          <span class="keyword">else</span> <span class="operator">{</span>
       <span class="keyword">printf</span><span class="operator">(</span><span class="string">" Bad Failover Event: %d.\n"</span><span class="operator">,</span>  <span class="variable">$fo_event</span><span class="operator">);</span>
</pre>
<pre>
    <span class="operator">}</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
      <span class="operator">}</span>
</pre>
<p>The TAF types are as follows</p>
<pre>
  OCI_FO_SESSION indicates the user has requested only session failover.
  OCI_FO_SELECT indicates the user has requested select failover.
  OCI_FO_NONE indicates the user has not requested a failover type.
  OCI_FO_TXNAL indicates the user has requested a transaction failover.</pre>
<p>The TAF events are as follows</p>
<pre>
  OCI_FO_BEGIN indicates that failover has detected a lost connection and failover is starting.
  OCI_FO_END   indicates successful completion of failover.
  OCI_FO_ABORT indicates that failover was unsuccessful, and there is no option of retrying.
  OCI_FO_ERROR also indicates that failover was unsuccessful, but it gives the application the opportunity to handle the error and retry failover.
  OCI_FO_REAUTH indicates that you have multiple authentication handles and failover has occurred after the original authentication. It indicates that a user handle has been re-authenticated. To find out which, the application checks the OCI_ATTR_SESSION attribute of the service context handle (which is the first parameter).</pre>
<p>
</p>
<h4><a name="optimizing_oracle_s_listener">Optimizing Oracle's listener</a></h4>
<p>[By Lane Sharman &lt;<a href="mailto:lane@bienlogic.com">lane@bienlogic.com</a>&gt;] I spent a lot of time optimizing
listener.ora and I am including it here for anyone to benefit from. My
connections over tnslistener on the same humble Netra 1 take an average
of 10-20 milli seconds according to tnsping. If anyone knows how to
make it better, please let me know!</p>
<pre>
  LISTENER =
   (ADDRESS_LIST =
    (ADDRESS =
      (PROTOCOL = TCP)
      (Host = aa.bbb.cc.d)
      (Port = 1521)
      (QUEUESIZE=10)
    )
   )</pre>
<pre>
  STARTUP_WAIT_TIME_LISTENER = 0
  CONNECT_TIMEOUT_LISTENER = 10
  TRACE_LEVEL_LISTENER = OFF
  SID_LIST_LISTENER =
   (SID_LIST =
    (SID_DESC =
      (SID_NAME = xxxx)
      (ORACLE_HOME = /xxx/local/oracle7-3)
        (PRESPAWN_MAX = 40)
        (PRESPAWN_LIST=
        (PRESPAWN_DESC=(PROTOCOL=tcp) (POOL_SIZE=40) (TIMEOUT=120))
      )
     )
   )</pre>
<p>1) When the application is co-located on the host and there is no need for
outside SQLNet connectivity, stop the listener. You do not need it. Get
your application/cgi/whatever working using pipes and shared memory. I am
convinced that this is one of the connection bugs (sockets over the same
machine). Note the $ENV{ORAPIPES} env var.  The essential code to do
this at the end of this section.</p>
<p>2) Be careful in how you implement the multi-threaded server. Currently I
am not using it in the initxxxx.ora file but will be doing some more testing.</p>
<p>3) Be sure to create user rollback segments and use them; do not use the
system rollback segments; however, you must also create a small rollback
space for the system as well.</p>
<p>5) Use large tuning settings and get lots of RAM. Check out all the
parameters you can set in v$parameters because there are quite a few not
documented you may to set in your initxxx.ora file.</p>
<p>6) Use svrmgrl to control oracle from the command line. Write lots of small
SQL scripts to get at V$ info.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  <span class="comment"># Environmental variables used by Oracle</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span>   <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_HOME</span><span class="operator">}</span>  <span class="operator">=</span> <span class="string">"/opt/oracle7"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">EPC_DISABLED</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"TRUE"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORAPIPES</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"V2"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbname</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbuser</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbpass</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$dbuser</span><span class="operator">,</span> <span class="variable">$dbpass</span><span class="operator">)</span>
             <span class="operator">||</span> <span class="keyword">die</span> <span class="string">"Unable to connect to </span><span class="variable">$dbname</span><span class="string">: </span><span class="variable">$DBI</span><span class="string">::errstr\n"</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="oracle_utilities">Oracle utilities</a></h4>
<p>If you are still having problems connecting then the Oracle adapters
utility may offer some help. Run these two commands:</p>
<pre>
  $ORACLE_HOME/bin/adapters
  $ORACLE_HOME/bin/adapters $ORACLE_HOME/bin/sqlplus</pre>
<p>and check the output. The &quot;Protocol Adapters&quot; section should be the
same.  It should include at least &quot;IPC Protocol Adapter&quot; and &quot;TCP/IP
Protocol Adapter&quot;.</p>
<p>If it generates any errors which look relevant then please talk to your
Oracle technical support (and not the dbi-users mailing list). Thanks.
Thanks to Mark Dedlow for this information.</p>
<p>
</p>
<h3><a name="private_connect_attributes">Private Connect Attributes</a></h3>
<p>
</p>
<h4><a name="ora_ncs_buff_mtpl">ora_ncs_buff_mtpl</a></h4>
<p>You can now customize the size of the buffer when selecting LOBs with
the built in AUTO Lob.  The default value is 4 which is probably
excessive for most situations but is needed for backward
compatibility.  If you not converting between a NCS on the DB and the
Client then you might want to set this to 1 to reduce memory usage.</p>
<p>This value can also be specified with the <code>ORA_DBD_NCS_BUFFER</code>
environment variable in which case it sets the value at the connect
stage.</p>
<p>See more details in the LOB section of the POD</p>
<p>
</p>
<h4><a name="ora_drcp">ora_drcp</a></h4>
<p>If you have an 11.2 or greater database your can utilize the DRCP by setting
this attribute to 1 at connect time.</p>
<p>This value can also be set with the <code>ORA_DRCP</code> environment variable.</p>
<p>
</p>
<h4><a name="ora_drcp_class">ora_drcp_class</a></h4>
<p>If you are using DRCP, you can set a CONNECTION_CLASS for your pools
as well.  As sessions from a DRCP cannot be shared by users, you can
use this setting to identify the same user across different
applications. OCI will ensure that sessions belonging to a 'class' are
not shared outside the class'.</p>
<p>The values for ora_drcp_class cannot contain a '*' and must be less
than 1024 characters.</p>
<p>This value can be also be specified with the <code>ORA_DRCP_CLASS</code>
environment variable.</p>
<p>
</p>
<h4><a name="ora_drcp_min">ora_drcp_min</a></h4>
<p>This optional value specifies the minimum number of sessions that are
initially opened.  New sessions are only opened after this value has
been reached.</p>
<p>The default value is 4 and  any value above 0 is valid.</p>
<p>Generally, it should be set to the number of concurrent statements the
application is planning or expecting to run.</p>
<p>This value can also be specified with the <code>ORA_DRCP_MIN</code> environment
variable.</p>
<p>
</p>
<h4><a name="ora_drcp_max">ora_drcp_max</a></h4>
<p>This optional value specifies the maximum number of sessions that can
be open at one time.  Once reached no more sessions can be opened
until one becomes free. The default value is 40 and any value above 1
is valid.  You should not set this value lower than ora_drcp_min as
that will just waste resources.</p>
<p>This value can also be specified with the <code>ORA_DRCP_MAX</code> environment
variable.</p>
<p>
</p>
<h4><a name="ora_drcp_incr">ora_drcp_incr</a></h4>
<p>This optional value specifies the next increment for sessions to be
started if the current number of sessions are less than
ora_drcp_max. The default value is 2 and any value above 0 is
valid as long as the value of ora_drcp_min + ora_drcp_incr is not
greater than ora_drcp_max.</p>
<p>This value can also be specified with the <code>ORA_DRCP_INCR</code> environment
variable.</p>
<p>
</p>
<h4><a name="ora_taf">ora_taf</a></h4>
<p>If your Oracle instance has been configured to use TAF events you can
enable the TAF callback by setting this value to anything other than 0.</p>
<p>
</p>
<h4><a name="ora_taf_function">ora_taf_function</a></h4>
<p>The name of the Perl subroutine that will be called from OCI when a
TAF event occurs. You must supply a perl function to use the callback
and it will always receive two parameters, the failover event value
and the failover type. Below is an example of a TAF function</p>
<pre>
  <span class="keyword">sub</span><span class="variable"> taf_event</span><span class="operator">{</span>
     <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$event</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">print</span> <span class="string">"My TAF event=</span><span class="variable">$event</span><span class="string">\n"</span><span class="operator">;</span>
     <span class="keyword">print</span> <span class="string">"My TAF type=</span><span class="variable">$type</span><span class="string">\n"</span><span class="operator">;</span>
     <span class="keyword">return</span><span class="operator">;</span>
       <span class="operator">}</span>
</pre>
<p>
</p>
<h4><a name="ora_taf_sleep">ora_taf_sleep</a></h4>
<p>The amount of time in seconds the OCI client will sleep between attempting
successive failover events when the event is OCI_FO_ERROR.</p>
<p>
</p>
<h4><a name="ora_session_mode">ora_session_mode</a></h4>
<p>The ora_session_mode attribute can be used to connect with SYSDBA
authorization and SYSOPER authorization.
The ORA_SYSDBA and ORA_SYSOPER constants can be imported using</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_session_modes)</span><span class="operator">;</span>
</pre>
<p>This is one case where setting ORACLE_SID may be useful since
connecting as SYSDBA or SYSOPER via SQL*Net is frequently disabled
for security reasons.</p>
<p>Example:</p>
<pre>
  <span class="variable">$dsn</span> <span class="operator">=</span> <span class="string">"dbi:Oracle:"</span><span class="operator">;</span>       <span class="comment"># no dbname here</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"orcl"</span><span class="operator">;</span>  <span class="comment"># set ORACLE_SID as needed</span>
  <span class="keyword">delete</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TWO_TASK</span><span class="operator">}</span><span class="operator">;</span>      <span class="comment"># make sure TWO_TASK isn't set</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_session_mode</span> <span class="operator">=&gt;</span> <span class="variable">ORA_SYSDBA</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>It has been reported that this only works if <code>$dsn</code> does not contain
a SID so that Oracle then uses the value of ORACLE_SID (not
TWO_TASK) environment variable to connect to a local instance. Also
the username and password should be empty, and the user executing the
script needs to be part of the dba group or osdba group.</p>
<p>
</p>
<h4><a name="ora_oratab_orahome">ora_oratab_orahome</a></h4>
<p>Passing a true value for the ora_oratab_orahome attribute will make
DBD::Oracle change <code>$ENV{ORACLE_HOME}</code> to make the Oracle home directory
that specified in the <code>/etc/oratab</code> file <em>if</em> the database to connect to
is specified as a SID that exists in the oratab file, and DBD::Oracle was
built to use the Oracle 7 OCI API (not Oracle 8+).</p>
<p>
</p>
<h4><a name="ora_module_name">ora_module_name</a></h4>
<p>After connecting to the database the value of this attribute is passed
to the <code>SET_MODULE()</code> function in the <code>DBMS_APPLICATION_INFO</code> PL/SQL
package. This can be used to identify the application to the DBA for
monitoring and performance tuning purposes. For example:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_module_name</span> <span class="operator">=&gt;</span> <span class="variable">$0</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_module_name</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$y</span><span class="operator">;</span>
</pre>
<p>The maximum size is 48 bytes.</p>
<p>
</p>
<h4><a name="ora_driver_name">ora_driver_name</a></h4>
<p>For 11g and later you can now set the name of the driver layer using OCI.
Perl, Perl5, ApachePerl so on. Names starting with &quot;ORA&quot; are reserved. You
can enter up to 8 characters.  If none is enter then this will default to
DBDOxxxx where xxxx is the current version number. This value can be
retrieved on the server side using V$SESSION_CONNECT_INFO or
GV$SESSION_CONNECT_INFO</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_driver_name</span> <span class="operator">=&gt;</span> <span class="string">'ModPerl_1'</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_driver_name</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$q</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_client_info">ora_client_info</a></h4>
<p>Allows you to add any value (up to 64 bytes) to your session and it can be
retrieved on the server side from the <code>V$SESSION</code>a view.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_client_info</span> <span class="operator">=&gt;</span> <span class="string">'Remote2'</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_client_info</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"Remote2"</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_client_identifier">ora_client_identifier</a></h4>
<p>Allows you to specify the user identifier in the session handle.</p>
<p>Most useful for web applications as it can pass in the session user
name which might be different to the connection user name. Can be up
to 64 bytes long but do not to include the password for security
reasons and the first character of the identifier should not be
':'. This value can be retrieved on the server side using <code>V$SESSION</code>
view.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_client_identifier</span> <span class="operator">=&gt;</span> <span class="variable">$some_web_user</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_client_identifier</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$local_user</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_action">ora_action</a></h4>
<p>Allows you to specify any string up to 32 bytes which may be retrieved
on the server side using <code>V$SESSION</code> view.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_action</span> <span class="operator">=&gt;</span> <span class="string">"Login"</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_action</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"New Long Query 22"</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_dbh_share">ora_dbh_share</a></h4>
<p>Requires at least Perl 5.8.0 compiled with ithreads. Allows you to share
database connections between threads. The first connect will make the
connection, all following calls to connect with the same ora_dbh_share
attribute will use the same database connection. The value must be a
reference to a already shared scalar which is initialized to an empty
string.</p>
<pre>
  <span class="keyword">our</span> <span class="variable">$orashr</span> <span class="operator">:</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="string">''</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span> <span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span><span class="string">ora_dbh_share</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$orashr</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_envhp">ora_envhp</a></h4>
<p>The first time a connection is made a new OCI 'environment' is
created by DBD::Oracle and stored in the driver handle.
Subsequent connects reuse (share) that same OCI environment
by default.</p>
<p>The ora_envhp attribute can be used to disable the reuse of the OCI
environment from a previous connect. If the value is <code>0</code> then
a new OCI environment is allocated and used for this connection.</p>
<p>The OCI environment holds information about the client side context,
such as the local NLS environment. By altering <a href="../../lib/pods/perlvar.html#_env"><code>%ENV</code></a> and setting
ora_envhp to 0 you can create connections with different NLS
settings. This is most useful for testing.</p>
<p>
</p>
<h4><a name="ora_charset__ora_ncharset">ora_charset, ora_ncharset</a></h4>
<p>For oracle versions &gt;= 9.2 you can specify the client charset and
ncharset with the ora_charset and ora_ncharset attributes.  You
still need to pass <code>ora_envhp = 0</code> for all but the first connect.</p>
<p>These attributes override the settings from environment variables.</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span> <span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span>
                       <span class="operator">{</span><span class="string">ora_charset</span> <span class="operator">=&gt;</span> <span class="string">'AL32UTF8'</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>
</p>
<h4><a name="ora_verbose">ora_verbose</a></h4>
<p>Use this value to enable DBD::Oracle only tracing.  Simply either set
the ora_verbose attribute on the <a href="../../lib/pods/perlfunc.html#connect"><code>connect()</code></a> method to the trace level
you desire like this</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="operator">{</span><span class="string">ora_verbose</span><span class="operator">=&gt;</span><span class="number">6</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>or set it directly on the DB handle like this;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_verbose</span><span class="operator">}</span> <span class="operator">=</span><span class="number">6</span><span class="operator">;</span>
</pre>
<p>In both cases the DBD::Oracle trace level is set to 6, which is the highest
level tracing most of the calls to OCI.</p>
<p>
</p>
<h4><a name="ora_oci_success_warn">ora_oci_success_warn</a></h4>
<p>Use this value to print otherwise silent OCI warnings that may happen
when an execute or fetch returns &quot;Success With Info&quot; or when you want
to tune RowCaching and LOB Reads</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_oci_success_warn</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_objects">ora_objects</a></h4>
<p>Use this value to enable extended embedded oracle objects mode. In extended:</p>
<ol>
<li>
<p>Embedded objects are returned as &lt;DBD::Oracle::Object&gt; instance (including type-name etc.) instead of simple ARRAY.</p>
</li>
<li>
<p>Determine object type for each instance. All object attributes are returned (not only super-type's attributes).</p>
</li>
</ol>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_objects</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>
</p>
<h4><a name="ora_ph_type">ora_ph_type</a></h4>
<p>The default placeholder datatype for the database session.
The <code>TYPE</code> or <a href="#ora_type">ora_type</a> attributes to <a href="../../lib/DBI/bind_param.html">bind_param in the DBI manpage</a> and
<a href="../../lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a> override the datatype for individual placeholders.
The most frequent reason for using this attribute is to permit trailing spaces
in values passed by placeholders.</p>
<p>Constants for the values allowed for this attribute can be imported using</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>Only the following values are permitted for this attribute.</p>
<dl>
<dt><strong><a name="ora_varchar2" class="item">ORA_VARCHAR2</a></strong></dt>

<dd>
<p>Oracle clients using OCI 8 will strip trailing spaces and allow embedded \0 bytes.
Oracle clients using OCI 9.2 do not strip trailing spaces and allow embedded \0 bytes.
This is the normal default placeholder type.</p>
</dd>
<dt><strong><a name="ora_string" class="item">ORA_STRING</a></strong></dt>

<dd>
<p>Do not strip trailing spaces and end the string at the first \0.</p>
</dd>
<dt><strong><a name="ora_char" class="item">ORA_CHAR</a></strong></dt>

<dd>
<p>Do not strip trailing spaces and allow embedded \0.
Force 'blank-padded comparison semantics'.</p>
<p>For example:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">"select username from all_users where username = ?"</span><span class="operator">;</span>
  <span class="comment">#username is a char(8)</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">)</span><span class="string">";
  </span><span class="variable">$sth</span><span class="string">-&gt;bind_param(1,'bloggs',{ ora_type =&gt; ORA_CHAR});
  </span>
</pre>
<p>Will pad bloggs out to 8 characters and return the username.</p>
</dd>
</dl>
<p>
</p>
<h4><a name="ora_parse_error_offset">ora_parse_error_offset</a></h4>
<p>If the previous error was from a failed <code>prepare</code> due to a syntax error,
this attribute gives the offset into the <code>Statement</code> attribute where the
error was found.</p>
<p>
</p>
<h4><a name="ora_array_chunk_size">ora_array_chunk_size</a></h4>
<p>Due to OCI limitations, DBD::Oracle needs to buffer up rows of
bind values in its <code>execute_for_fetch</code> implementation. This attribute
sets the number of rows to buffer at a time (default value is 1000).</p>
<p>The <code>execute_for_fetch</code> function will collect (at most) this many
rows in an array, send them off to the DB for execution, then go back
to collect the next chunk of rows and so on. This attribute can be
used to limit or extend the number of rows processed at a time.</p>
<p>Note that this attribute also applies to <code>execute_array</code>, since that
method is implemented using <code>execute_for_fetch</code>.</p>
<p>
</p>
<h4><a name="ora_connect_with_default_signals">ora_connect_with_default_signals</a></h4>
<p>Sometimes the Oracle client seems to change some of the signal
handlers of the process during the connect phase.  For instance, some
users have observed Perl's default <code>$SIG{INT}</code> handler being ignored
after connecting to an Oracle database.  If this causes problems in
your application, set this attribute to an array reference of signals
you would like to be localized during the connect process.  Once the
connect is complete, the signal handlers should be returned to their
previous state.</p>
<p>For example:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span> <span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span>
                       <span class="operator">{</span><span class="string">ora_connect_with_default_signals</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">'INT'</span> <span class="operator">]</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>NOTE disabling the signal handlers the OCI library sets up may affect
functionality in the OCI library.</p>
<p>
</p>
<h3><a name="connect_cached"><strong>connect_cached</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact. Please note that connect_cached as not been tested with DRCP.</p>
<p>
</p>
<h3><a name="data_sources"><strong>data_sources</strong></a></h3>
<pre>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'Oracle'</span><span class="operator">);</span>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">();</span>
</pre>
<p>Returns a list of available databases. You will have to set either the 'ORACLE_HOME' or
'TNS_ADMIN' environment value to retrieve this list.  It will read these values from
TNSNAMES.ORA file entries.</p>
<p>
</p>
<h2><a name="methods_common_to_all_handles">Methods Common To All Handles</a></h2>
<p>For all of the methods below, <strong>$h</strong> can be either a database handle (<strong>$dbh</strong>)
or a statement handle (<strong>$sth</strong>). Note that <em>$dbh</em> and <em>$sth</em> can be replaced with
any variable name you choose: these are just the names most often used. Another
common variable used in this documentation is $<em>rv</em>, which stands for &quot;return value&quot;.</p>
<p>
</p>
<h3><a name="err"><strong>err</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">err</span><span class="operator">;</span>
</pre>
<p>Returns the error code from the last method called.</p>
<p>
</p>
<h3><a name="errstr"><strong>errstr</strong></a></h3>
<pre>
  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<p>Returns the last error that was reported by Oracle. Starting with &quot;ORA-00000&quot; code followed by the error message.</p>
<p>
</p>
<h3><a name="state"><strong>state</strong></a></h3>
<pre>
  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">state</span><span class="operator">;</span>
</pre>
<p>Oracle hasn't supported SQLSTATE since the early versions OCI. It will return empty when the command succeeds and
'S1000' (General Error) for all other errors.</p>
<p>While this method can be called as either <a href="../../lib/pods/perlfunc.html#state"><code>$sth-&gt;state</code></a> or <a href="../../lib/pods/perlfunc.html#state"><code>$dbh-&gt;state</code></a>, it
is usually clearer to always use <a href="../../lib/pods/perlfunc.html#state"><code>$dbh-&gt;state</code></a>.</p>
<p>
</p>
<h3><a name="trace"><strong>trace</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="trace_msg"><strong>trace_msg</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="parse_trace_flag_and_parse_trace_flags"><strong>parse_trace_flag</strong> and <strong>parse_trace_flags</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="func"><strong>func</strong></a></h3>
<p>DBD::Oracle uses the <code>func</code> method to support a variety of functions.</p>
<p>
</p>
<h3><a name="private_database_handle_functions"><strong>Private database handle functions</strong></a></h3>
<p>Some of these functions are called through the method <code>func()</code>
which is described in the DBI documentation. Any function that begins with ora_
can be called directly.</p>
<p>
</p>
<h3><a name="plsql_errstr"><strong>plsql_errstr</strong></a></h3>
<p>This function returns a string which describes the errors
from the most recent PL/SQL function, procedure, package,
or package body compile in a format similar to the output
of the SQL*Plus command 'show errors'.</p>
<p>The function returns undef if the error string could not
be retrieved due to a database error.
Look in $dbh-&gt;errstr for the cause of the failure.</p>
<p>If there are no compile errors, an empty string is returned.</p>
<p>Example:</p>
<pre>
    <span class="comment"># Show the errors if CREATE PROCEDURE fails</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span> <span class="string">q{
        CREATE OR REPLACE PROCEDURE perl_dbd_oracle_test as
        BEGIN
            PROCEDURE filltab( stuff OUT TAB ); asdf
        END; }</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{}</span> <span class="comment"># Statement succeeded</span>
    <span class="operator">}</span>
    <span class="keyword">elsif</span> <span class="operator">(</span> <span class="number">6550</span> <span class="operator">!=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">err</span> <span class="operator">)</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span> <span class="operator">}</span> <span class="comment"># Utter failure</span>
    <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$msg</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'plsql_errstr'</span> <span class="operator">);</span>
        <span class="keyword">die</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span> <span class="keyword">if</span> <span class="operator">!</span> <span class="keyword">defined</span> <span class="variable">$msg</span><span class="operator">;</span>
        <span class="keyword">die</span> <span class="variable">$msg</span> <span class="keyword">if</span> <span class="variable">$msg</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="dbms_output_enable___dbms_output_put___dbms_output_get"><strong>dbms_output_enable / dbms_output_put / dbms_output_get</strong></a></h3>
<p>These functions use the PL/SQL DBMS_OUTPUT package to store and
retrieve text using the DBMS_OUTPUT buffer.  Text stored in this buffer
by dbms_output_put or any PL/SQL block can be retrieved by
dbms_output_get or any PL/SQL block connected to the same database
session.</p>
<p>Stored text is not available until after dbms_output_put or the PL/SQL
block that saved it completes its execution.  This means you <strong>CAN NOT</strong>
use these functions to monitor long running PL/SQL procedures.</p>
<p>Example 1:</p>
<pre>
  <span class="comment"># Enable DBMS_OUTPUT and set the buffer size</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="number">1000000</span><span class="operator">,</span> <span class="string">'dbms_output_enable'</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># Put text in the buffer . . .</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="variable">@text</span><span class="operator">,</span> <span class="string">'dbms_output_put'</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># . . . and retrieve it later</span>
  <span class="variable">@text</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'dbms_output_get'</span> <span class="operator">);</span>
</pre>
<p>Example 2:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
    DECLARE tmp VARCHAR2(50);
    BEGIN
      SELECT SYSDATE INTO tmp FROM DUAL;
      dbms_output.put_line('The date is '||tmp);
    END;
  }</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># retrieve the string</span>
  <span class="variable">$date_string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'dbms_output_get'</span> <span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="dbms_output_enable_____buffer_size____"><strong>dbms_output_enable ( [ buffer_size ] )</strong></a></h3>
<p>This function calls DBMS_OUTPUT.ENABLE to enable calls to package
DBMS_OUTPUT procedures GET, GET_LINE, PUT, and PUT_LINE.  Calls to
these procedures are ignored unless DBMS_OUTPUT.ENABLE is called
first.</p>
<p>The buffer_size is the maximum amount of text that can be saved in the
buffer and must be between 2000 and 1,000,000.  If buffer_size is not
given, the default is 20,000 bytes.</p>
<p>
</p>
<h3><a name="dbms_output_put______lines____"><strong>dbms_output_put ( [ @lines ] )</strong></a></h3>
<p>This function calls DBMS_OUTPUT.PUT_LINE to add lines to the buffer.</p>
<p>If all lines were saved successfully the function returns 1.  Depending
on the context, an empty list or undef is returned for failure.</p>
<p>If any line causes buffer_size to be exceeded, a buffer overflow error
is raised and the function call fails.  Some of the text might be in
the buffer.</p>
<p>
</p>
<h3><a name="dbms_output_get"><strong>dbms_output_get</strong></a></h3>
<p>This function calls DBMS_OUTPUT.GET_LINE to retrieve lines of text from
the buffer.</p>
<p>In an array context, all complete lines are removed from the buffer and
returned as a list.  If there are no complete lines, an empty list is
returned.</p>
<p>In a scalar context, the first complete line is removed from the buffer
and returned.  If there are no complete lines, undef is returned.</p>
<p>Any text in the buffer after a call to DBMS_OUTPUT.GET_LINE or
DBMS_OUTPUT.GET is discarded by the next call to DBMS_OUTPUT.PUT_LINE,
DBMS_OUTPUT.PUT, or DBMS_OUTPUT.NEW_LINE.</p>
<p>
</p>
<h3><a name="reauthenticate____username___password__"><strong>reauthenticate ( $username, $password )</strong></a></h3>
<p>Starts a new session against the current database using the credentials
supplied.</p>
<p>
</p>
<h3><a name="private_attribute_info"><strong>private_attribute_info</strong></a></h3>
<pre>
  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
</pre>
<p>Returns a hash of all private attributes used by DBD::Oracle, for either
a database or a statement handle. Currently, all the hash values are undef.</p>
<p>
</p>
<h2><a name="attributes_common_to_all_handles">Attributes Common To All Handles</a></h2>
<p>
</p>
<h3><a name="inactivedestroy__boolean_"><strong>InactiveDestroy</strong> (boolean)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="raiseerror__boolean__inherited_"><strong>RaiseError</strong> (boolean, inherited)</a></h3>
<p>Forces errors to always raise an exception. Although it defaults to off, it is recommended that this
be turned on, as the alternative is to check the return value of every method (prepare, execute, fetch, etc.)
manually, which is easy to forget to do.</p>
<p>
</p>
<h3><a name="printerror__boolean__inherited_"><strong>PrintError</strong> (boolean, inherited)</a></h3>
<p>Forces database errors to also generate warnings, which can then be filtered with methods such as
locally redefining <em>$SIG{__WARN__}</em> or using modules such as <code>CGI::Carp</code>. This attribute is on
by default.</p>
<p>
</p>
<h3><a name="showerrorstatement__boolean__inherited_"><strong>ShowErrorStatement</strong> (boolean, inherited)</a></h3>
<p>Appends information about the current statement to error messages. If placeholder information
is available, adds that as well. Defaults to true.</p>
<p>
</p>
<h3><a name="warn__boolean__inherited_"><strong>Warn</strong> (boolean, inherited)</a></h3>
<p>Enables warnings. This is on by default, and should only be turned off in a local block
for a short a time only when absolutely needed.</p>
<p>
</p>
<h3><a name="executed__boolean__read_only_"><strong>Executed</strong> (boolean, read-only)</a></h3>
<p>Indicates if a handle has been executed. For database handles, this value is true after the <a href="../../lib/pods/perlfunc.html#do">do</a> method has been called, or
when one of the child statement handles has issued an <a href="#execute">execute</a>. Issuing a <a href="#commit">commit</a> or <a href="#rollback">rollback</a> always resets the
attribute to false for database handles. For statement handles, any call to <a href="#execute">execute</a> or its variants will flip the value to
true for the lifetime of the statement handle.</p>
<p>
</p>
<h3><a name="tracelevel__integer__inherited_"><strong>TraceLevel</strong> (integer, inherited)</a></h3>
<p>Sets the trace level, similar to the <a href="#trace">trace</a> method. See the sections on
<a href="#trace">trace</a> and <a href="#parse_trace_flag">parse_trace_flag</a> for more details.</p>
<p>
</p>
<h3><a name="active__boolean__read_only_"><strong>Active</strong> (boolean, read-only)</a></h3>
<p>Indicates if a handle is active or not. For database handles, this indicates if the database has
been disconnected or not. For statement handles, it indicates if all the data has been fetched yet
or not. Use of this attribute is not encouraged.</p>
<p>
</p>
<h3><a name="kids__integer__read_only_"><strong>Kids</strong> (integer, read-only)</a></h3>
<p>Returns the number of child processes created for each handle type. For a driver handle, indicates the number
of database handles created. For a database handle, indicates the number of statement handles created. For
statement handles, it always returns zero, because statement handles do not create kids.</p>
<p>
</p>
<h3><a name="activekids__integer__read_only_"><strong>ActiveKids</strong> (integer, read-only)</a></h3>
<p>Same as <code>Kids</code>, but only returns those that are active.</p>
<p>
</p>
<h3><a name="cachedkids__hash_ref_"><strong>CachedKids</strong> (hash ref)</a></h3>
<p>Returns a hashref of handles. If called on a database handle, returns all statement handles created by use of the
<code>prepare_cached</code> method. If called on a driver handle, returns all database handles created by the <a href="#connect_cached">connect_cached</a>
method.</p>
<p>
</p>
<h3><a name="childhandles__array_ref_"><strong>ChildHandles</strong> (array ref)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="printwarn__boolean__inherited_"><strong>PrintWarn</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="handleerror__boolean__inherited_"><strong>HandleError</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="handleseterr__code_ref__inherited_"><strong>HandleSetErr</strong> (code ref, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="errcount__unsigned_integer_"><strong>ErrCount</strong> (unsigned integer)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="fetchhashkeyname__string__inherited_"><strong>FetchHashKeyName</strong> (string, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="chopblanks__boolean__inherited_"><strong>ChopBlanks</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="taint__boolean__inherited_"><strong>Taint</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="taintin__boolean__inherited_"><strong>TaintIn</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="taintout__boolean__inherited_"><strong>TaintOut</strong> (boolean, inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="profile__inherited_"><strong>Profile</strong> (inherited)</a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="type__scalar_"><strong>Type</strong> (scalar)</a></h3>
<p>Returns <code>dr</code> for a driver handle, <code>db</code> for a database handle, and <code>st</code> for a statement handle.
Should be rarely needed.</p>
<p>
</p>
<h3><a name="longreadlen"><strong>LongReadLen</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="longtruncok"><strong>LongTruncOk</strong></a></h3>
<p>Implemented by DBI, no driver-specific impact.</p>
<p>
</p>
<h3><a name="compatmode"><strong>CompatMode</strong></a></h3>
<p>Type: boolean, inherited</p>
<p>The CompatMode attribute is used by emulation layers (such as Oraperl) to enable compatible behaviour in the underlying driver (e.g., DBD::Oracle) for this handle. Not normally set by application code.</p>
<p>It also has the effect of disabling the 'quick FETCH' of attribute values from the handles attribute cache. So all attribute values are handled by the drivers own FETCH method. This makes them slightly slower but is useful for special-purpose drivers like DBD::Multiplex.</p>
<p>
</p>
<hr />
<h1><a name="dbi_database_handle_object">DBI Database Handle Object</a></h1>
<p>
</p>
<h2><a name="database_handle_methods">Database Handle Methods</a></h2>
<p>
</p>
<h3><a name="selectall_arrayref"><strong>selectall_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns a reference to an array containing the rows returned by preparing and executing the SQL string.
See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="selectall_hashref"><strong>selectall_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="variable">$key_field</span><span class="operator">);</span>
</pre>
<p>Returns a reference to a hash containing the rows returned by preparing and executing the SQL string.
See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="selectcol_arrayref"><strong>selectcol_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectcol_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns a reference to an array containing the first column
from each rows returned by preparing and executing the SQL string. It is possible to specify exactly
which columns to return. See the DBI documentation for full details.</p>
<p>
</p>
<h3><a name="prepare"><strong>prepare</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Prepares a statement for later execution by the database engine and returns a reference to a statement handle object.</p>
<p>
</p>
<h4><a name="prepare_attributes"><strong>Prepare Attributes</strong></a></h4>
<p>These attributes may be used in the <code>\%attr</code> parameter of the
<a href="../../lib/DBI/prepare.html">prepare in the DBI manpage</a> database handle method.</p>
<dl>
<dt><strong><a name="ora_placeholders" class="item">ora_placeholders</a></strong></dt>

<dd>
<p>Set to false to disable processing of placeholders. Used mainly for loading a
PL/SQL package that has been <em>wrapped</em> with Oracle's <code>wrap</code> utility.</p>
</dd>
<dt><strong><a name="ora_auto_lob" class="item">ora_auto_lob</a></strong></dt>

<dd>
<p>If true (the default), fetching retrieves the contents of the CLOB or
BLOB column in most circumstances.  If false, fetching retrieves the
Oracle &quot;LOB Locator&quot; of the CLOB or BLOB value.</p>
<p>See <a href="#lobs_and_longs">LOBs and LONGs</a> for more details.</p>
<p>See also the LOB tests in 05dbi.t of Oracle::OCI for examples
of how to use LOB Locators.</p>
</dd>
<dt><strong><a name="ora_pers_lob" class="item">ora_pers_lob</a></strong></dt>

<dd>
<p>If true the <a href="#simple_fetch_for_clobs_and_blobs">Simple Fetch for CLOBs and BLOBs</a> method for the <a href="#data_interface_for_persistent_lobs">Data Interface for Persistent LOBs</a> will be
used for LOBs rather than the default method <a href="#data_interface_for_lob_locators">Data Interface for LOB Locators</a>.</p>
</dd>
<dt><strong><a name="ora_clbk_lob" class="item">ora_clbk_lob</a></strong></dt>

<dd>
<p>If true the <a href="#piecewise_fetch_with_callback">Piecewise Fetch with Callback</a> method for the <a href="#data_interface_for_persistent_lobs">Data Interface for Persistent LOBs</a> will be used for LOBs.</p>
</dd>
<dt><strong><a name="ora_piece_lob" class="item">ora_piece_lob</a></strong></dt>

<dd>
<p>If true the <a href="#piecewise_fetch_with_polling">Piecewise Fetch with Polling</a> method for the <a href="#data_interface_for_persistent_lobs">Data Interface for Persistent LOBs</a> will be used for LOBs.</p>
</dd>
<dt><strong><a name="ora_piece_size" class="item">ora_piece_size</a></strong></dt>

<dd>
<p>This is the max piece size for the <a href="#piecewise_fetch_with_callback">Piecewise Fetch with Callback</a>
and <a href="#piecewise_fetch_with_polling">Piecewise Fetch with Polling</a> methods, in chars for CLOBS, and
bytes for BLOBS.</p>
</dd>
<dt><strong><a name="ora_check_sql" class="item">ora_check_sql</a></strong></dt>

<dd>
<p>If 1 (default), force SELECT statements to be described in <code>prepare()</code>.
If 0, allow SELECT statements to defer describe until <code>execute()</code>.</p>
<p>See <a href="#prepare_postponed_till_execute">Prepare Postponed Till Execute</a> for more information.</p>
</dd>
<dt><strong><a name="ora_exe_mode" class="item">ora_exe_mode</a></strong></dt>

<dd>
<p>This will set the execute mode of the current statement. Presently
only one mode is supported;</p>
<pre>
  OCI_STMT_SCROLLABLE_READONLY - make result set scrollable</pre>
<p>See <a href="#scrollable_cursors">Scrollable Cursors</a> for more details.</p>
</dd>
<dt><strong><a name="ora_prefetch_rows" class="item">ora_prefetch_rows</a></strong></dt>

<dd>
<p>Sets the number of rows to be prefetched. If it is not set, then the
default value is 1.  See <a href="#row_prefetching">Row Prefetching</a> for more details.</p>
</dd>
<dt><strong><a name="ora_prefetch_memory" class="item">ora_prefetch_memory</a></strong></dt>

<dd>
<p>Sets the memory level for rows to be prefetched. The application then
fetches as many rows as will fit into that much memory.  See <a href="#row_prefetching">Row Prefetching</a> for more details.</p>
</dd>
<dt><strong><a name="ora_row_cache_off" class="item">ora_row_cache_off</a></strong></dt>

<dd>
<p>By default DBD::Oracle will use a row cache when fetching to cut down
the number of round trips to the server. If you do not want to use an
array fetch set this value to any value other than 0;</p>
<p>See <a href="#row_prefetching">Row Prefetching</a> for more details.</p>
</dd>
</dl>
<p>
</p>
<h4><a name="placeholders"><strong>Placeholders</strong></a></h4>
<p>There are two types of placeholders that can be used in DBD::Oracle. The first is
the &quot;question mark&quot; type, in which each placeholder is represented by a single
question mark character. This is the method recommended by the DBI specs and is the most
portable. Each question mark is internally replaced by a &quot;dollar sign number&quot; in the order
in which they appear in the query (important when using <a href="#bind_param">bind_param</a>).</p>
<p>The other placeholder type is &quot;named parameters&quot; in the format &quot;:foo&quot; which is the one Oralce prefers.</p>
<pre>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>        <span class="comment"># save having to check each method call</span>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT name, age FROM people WHERE name LIKE :name"</span><span class="operator">);</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">':name'</span><span class="operator">,</span> <span class="string">"John%"</span><span class="operator">);</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
   <span class="variable">DBI::dump_results</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">);</span>
</pre>
<p>The different types of placeholders cannot be mixed within a statement, but you may
use different ones for each statement handle you have. This is confusing at best, so
stick to one style within your program.</p>
<p>
</p>
<h3><a name="prepare_cached"><strong>prepare_cached</strong></a></h3>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare_cached</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Implemented by DBI, no driver-specific impact. This method is most useful
if the same query is used over and over as it will cut down round trips to the server.</p>
<p>
</p>
<h3><a name="do"><strong>do</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Prepare and execute a single statement. Returns the number of rows affected if the
query was successful, returns undef if an error occurred, and returns -1 if the
number of rows is unknown or not available. Note that this method will return <strong>0E0</strong> instead
of 0 for 'no rows were affected', in order to always return a true value if no error occurred.</p>
<p>
</p>
<h3><a name="last_insert_id"><strong>last_insert_id</strong></a></h3>
<p>Oracle does not implement auto_increment of serial type columns it uses predefined
sequences where the id numbers are either selected before insert, at insert time with a trigger,
 or as part of the query.</p>
<p>Below is an example of you to use the latter with the SQL returning clause to get the ID number back
on insert with the bind_param_inout method.
.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'CREATE SEQUENCE lii_seq START 1'</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{CREATE TABLE lii (
    foobar INTEGER NOT NULL UNIQUE,
    baz VARCHAR)}</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"INSERT INTO lii (foobar,baz) VALUES (lii_seq.nextval,'XX') returning foobar into :p_new_id"</span><span class="operator">;</span><span class="string">";
  </span><span class="variable">$sth</span><span class="string"> = </span><span class="variable">$dbh</span><span class="string">-&gt;prepare(</span><span class="variable">$SQL</span><span class="string">);
  my </span><span class="variable">$p_new_id</span><span class="string">='-1';
  </span><span class="variable">$sth</span><span class="string">-&gt;bind_param_inout("</span><span class="operator">:</span><span class="variable">p_new_id</span><span class="string">",\$p_new_id,38);
  </span><span class="variable">$sth</span><span class="string">-&gt;execute();
  </span><span class="variable">$db</span><span class="string">-&gt;commit();
  </span>
</pre>
<p>
</p>
<h3><a name="commit"><strong>commit</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">;</span>
</pre>
<p>Issues a COMMIT to the server, indicating that the current transaction is finished and that
all changes made will be visible to other processes. If AutoCommit is enabled, then
a warning is given and no COMMIT is issued. Returns true on success, false on error.</p>
<p>
</p>
<h3><a name="rollback"><strong>rollback</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">rollback</span><span class="operator">;</span>
</pre>
<p>Issues a ROLLBACK to the server, which discards any changes made in the current transaction. If AutoCommit
is enabled, then a warning is given and no ROLLBACK is issued. Returns true on success, and
false on error.</p>
<p>
</p>
<h3><a name="begin_work"><strong>begin_work</strong></a></h3>
<p>This method turns on transactions until the next call to <a href="#commit">commit</a> or <a href="#rollback">rollback</a>, if <a href="#autocommit">AutoCommit</a> is
currently enabled. If it is not enabled, calling begin_work will issue an error. Note that the
transaction will not actually begin until the first statement after begin_work is called.</p>
<p>
</p>
<h3><a name="disconnect"><strong>disconnect</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">disconnect</span><span class="operator">;</span>
</pre>
<p>Disconnects from the Oracle database. Any uncommitted changes will be rolled back upon disconnection. It's
good policy to always explicitly call commit or rollback at some point before disconnecting, rather than
relying on the default rollback behavior.</p>
<p>If the script exits before disconnect is called (or, more precisely, if the database handle is no longer
referenced by anything), then the database handle's DESTROY method will call the <code>rollback()</code> and <code>disconnect()</code>
methods automatically. It is best to explicitly disconnect rather than rely on this behavior.</p>
<p>
</p>
<h3><a name="ping"><strong>ping</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ping</span><span class="operator">;</span>
</pre>
<p>This <code>ping</code> method is used to check the validity of a database handle. The value returned is
either 0, indicating that the connection is no longer valid, or 1, indicating the connection is valid.
This function does 1 round trip to the Oracle Server.</p>
<p>
</p>
<h3><a name="get_info__"><strong>get_info()</strong></a></h3>
<pre>
 <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">get_info</span><span class="operator">(</span><span class="variable">$info_type</span><span class="operator">);</span>
</pre>
<p>DBD::Oracle supports <code>get_info()</code>, but (currently) only a few info types.</p>
<p>
</p>
<h3><a name="table_info__"><strong>table_info()</strong></a></h3>
<p>DBD::Oracle supports attributes for <code>table_info()</code>.</p>
<p>In Oracle, the concept of <em>user</em> and <em>schema</em> is (currently) the
same. Because database objects are owned by an user, the owner names
in the data dictionary views correspond to schema names.
Oracle does not support catalogues so TABLE_CAT is ignored as
selection criterion.</p>
<p>Search patterns are supported for TABLE_SCHEM and TABLE_NAME.</p>
<p>TABLE_TYPE may contain a comma-separated list of table types.
The following table types are supported:</p>
<pre>
  TABLE
  VIEW
  SYNONYM
  SEQUENCE</pre>
<p>The result set is ordered by TABLE_TYPE, TABLE_SCHEM, TABLE_NAME.</p>
<p>The special enumerations of catalogues, schemas and table types are
supported. However, TABLE_CAT is always NULL.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
<code>table_info()</code> performs a case-sensitive search. So, a selection
criterion should respect upper and lower case.
Normally, an identifier is case-insensitive. Oracle stores and
returns it in upper case. Sometimes, database objects are created
with quoted identifiers (for reserved words, mixed case, special
characters, ...). Such an identifier is case-sensitive (if not all
upper case). Oracle stores and returns it as given.
<code>table_info()</code> has no special quote handling, neither adds nor
removes quotes.</p>
<p>
</p>
<h3><a name="primary_key_info__"><strong>primary_key_info()</strong></a></h3>
<p>Oracle does not support catalogues so TABLE_CAT is ignored as
selection criterion.
The TABLE_CAT field of a fetched row is always NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>If the primary key constraint was created without an identifier,
PK_NAME contains a system generated name with the form SYS_Cn.</p>
<p>The result set is ordered by TABLE_SCHEM, TABLE_NAME, KEY_SEQ.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>
</p>
<h3><a name="foreign_key_info__"><strong>foreign_key_info()</strong></a></h3>
<p>This method (currently) supports the extended behaviour of SQL/CLI, i.e. the
result set contains foreign keys that refer to primary <strong>and</strong> alternate keys.
The field UNIQUE_OR_PRIMARY distinguishes these keys.</p>
<p>Oracle does not support catalogues, so <code>$pk_catalog</code> and <code>$fk_catalog</code> are
ignored as selection criteria (in the new style interface).
The UK_TABLE_CAT and FK_TABLE_CAT fields of a fetched row are always
NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>If the primary or foreign key constraints were created without an identifier,
UK_NAME or FK_NAME contains a system generated name with the form SYS_Cn.</p>
<p>The UPDATE_RULE field is always 3 ('NO ACTION'), because Oracle (currently)
does not support other actions.</p>
<p>The DELETE_RULE field may contain wrong values. This is a known Bug (#1271663)
in Oracle's data dictionary views. Currently (as of 8.1.7), 'RESTRICT' and
'SET DEFAULT' are not supported, 'CASCADE' is mapped correctly and all other
actions (incl. 'SET NULL') appear as 'NO ACTION'.</p>
<p>The DEFERABILITY field is always NULL, because this columns is
not present in the ALL_CONSTRAINTS view of older Oracle releases.</p>
<p>The result set is ordered by UK_TABLE_SCHEM, UK_TABLE_NAME, FK_TABLE_SCHEM,
FK_TABLE_NAME, ORDINAL_POSITION.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>
</p>
<h3><a name="column_info__"><strong>column_info()</strong></a></h3>
<p>Oracle does not support catalogues so TABLE_CAT is ignored as
selection criterion.
The TABLE_CAT field of a fetched row is always NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>The CHAR_OCTET_LENGTH field is (currently) always NULL (undef).</p>
<p>Don't rely on the values of the BUFFER_LENGTH field!
Especially the length of FLOATs may be wrong.</p>
<p>Datatype codes for non-standard types are subject to change.</p>
<p>Attention! The DATA_DEFAULT (COLUMN_DEF) column is of type LONG.</p>
<p>The result set is ordered by TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>It is possible with Oracle to make the names of the various DB objects (table,column,index etc)
case sensitive.</p>
<pre>
  alter table bloggind add (&quot;Bla_BLA&quot; NUMBER)</pre>
<p>So in the example the exact case &quot;Bla_BLA&quot; must be used to get it info on the column. While this</p>
<pre>
 alter table bloggind add (Bla_BLA NUMBER)</pre>
<p>any case can be used to get info on the column.</p>
<p>
</p>
<h3><a name="selectrow_array"><strong>selectrow_array</strong></a></h3>
<pre>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Returns an array of row information after preparing and executing the provided SQL string. The rows are returned
by calling <a href="#fetchrow_array">fetchrow_array</a>. The string can also be a statement handle generated by a previous prepare. Note that
only the first row of data is returned. If called in a scalar context, only the first column of the first row is
returned. Because this is not portable, it is not recommended that you use this method in that way.</p>
<p>
</p>
<h3><a name="selectrow_arrayref"><strong>selectrow_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Exactly the same as <a href="#selectrow_array">selectrow_array</a>, except that it returns a reference to an array, by internal use of
the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method.</p>
<p>
</p>
<h3><a name="selectrow_hashref"><strong>selectrow_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Exactly the same as <a href="#selectrow_array">selectrow_array</a>, except that it returns a reference to an hash, by internal use of
the <a href="#fetchrow_hashref">fetchrow_hashref</a> method.</p>
<p>
</p>
<h3><a name="clone"><strong>clone</strong></a></h3>
<pre>
  <span class="variable">$other_dbh</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">();</span>
</pre>
<p>Creates a copy of the database handle by connecting with the same parameters as the original
handle, then trying to merge the attributes. See the DBI documentation for complete usage.</p>
<p>
</p>
<h2><a name="private_database_handle_methods">Private Database Handle Methods</a></h2>
<p>
</p>
<h3><a name="ora_can_unicode______refresh____"><strong>ora_can_unicode ( [ $refresh ] )</strong></a></h3>
<p>Returns a number indicating whether either of the database character sets
is a Unicode encoding. Calls <code>ora_nls_parameters()</code> and passes the optional
$refresh parameter to it.</p>
<p>0 = Neither character set is a Unicode encoding.</p>
<p>1 = National character set is a Unicode encoding.</p>
<p>2 = Database character set is a Unicode encoding.</p>
<p>3 = Both character sets are Unicode encodings.</p>
<p>
</p>
<h3><a name="ora_can_taf"><strong>ora_can_taf</strong></a></h3>
<p>Returns true if the current connection supports TAF events. False if otherise.</p>
<p>
</p>
<h3><a name="ora_nls_parameters______refresh____"><strong>ora_nls_parameters ( [ $refresh ] )</strong></a></h3>
<p>Returns a hash reference containing the current NLS parameters, as given
by the v$nls_parameters view. The values fetched are cached between calls.
To cause the latest values to be fetched, pass a true value to the function.</p>
<p>
</p>
<h2><a name="database_handle_attributes">Database Handle Attributes</a></h2>
<p>
</p>
<h3><a name="autocommit__boolean_"><strong>AutoCommit</strong> (boolean)</a></h3>
<p>Supported by DBD::Oracle as proposed by DBI.The default of AutoCommit is on, but this may change
in the future, so it is highly recommended that you explicitly set it when
calling <a href="../../lib/pods/perlfunc.html#connect">connect</a>.</p>
<p>
</p>
<h3><a name="readonly__boolean_"><strong>ReadOnly</strong> (boolean)</a></h3>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ReadOnly</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>Specifies if the current database connection should be in read-only mode or not.</p>
<p>Please not that this method is not foolproof: there are still ways to update the
database. Consider this a safety net to catch applications that should not be
issuing commands such as INSERT, UPDATE, or DELETE.</p>
<p>This method method requires DBI version 1.55 or better.</p>
<p>
</p>
<h3><a name="name__string__read_only_"><strong>Name</strong> (string, read-only)</a></h3>
<p>Returns the name of the current database. This is the same as the DSN, without the
&quot;dbi:Oracle:&quot; part.</p>
<p>
</p>
<h3><a name="username__string__read_only_"><strong>Username</strong> (string, read-only)</a></h3>
<p>Returns the name of the user connected to the database.</p>
<p>
</p>
<h3><a name="driver__handle__read_only_"><strong>Driver</strong> (handle, read-only)</a></h3>
<p>Holds the handle of the parent driver. The only recommended use for this is to find the name
of the driver using:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Driver</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span>
</pre>
<p>
</p>
<h3><a name="rowcachesize"><strong>RowCacheSize</strong></a></h3>
<p>DBD::Oracle supports both Server pre-fetch and Client side row caching. By default both
are turned on to give optimum performance. Most of the time one can just let DBD::Oracle
figure out the best optimization.</p>
<p>
</p>
<h4><a name="row_caching"><strong>Row Caching</strong></a></h4>
<p>Row caching occurs on the client side and the object of it is to cut down the number of round
trips made to the server when fetching rows. At each fetch a set number of rows will be retrieved
from the server and stored locally. Further calls the server are made only when the end of the
local buffer(cache) is reached.</p>
<p>Rows up to the specified top level row
count <code>RowCacheSize</code> are fetched if it occupies no more than the specified memory usage limit.
The default value is 0, which means that memory size is not included in computing the number of rows to prefetch. If
the <code>RowCacheSize</code> value is set to a negative number then the positive value of RowCacheSize is used
to compute the number of rows to prefetch.</p>
<p>By default <code>RowCacheSize</code> is automatically set. If you want to totally turn off prefetching set this to 1.</p>
<p>For any SQL statement that contains a LOB, Long or Object Type Row Caching will be turned off. However server side
caching still works.  If you are only selecting a LOB Locator then Row Caching will still work.</p>
<p>
</p>
<h4><a name="row_prefetching">Row Prefetching</a></h4>
<p>Row prefetching occurs on the server side and uses the DBI database handle attribute <code>RowCacheSize</code> and or the
Prepare Attribute 'ora_prefetch_memory'. Tweaking these values may yield improved performance.</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RowCacheSize</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">100</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_exe_mode</span><span class="operator">=&gt;</span><span class="variable">OCI_STMT_SCROLLABLE_READONLY</span><span class="operator">,</span><span class="string">ora_prefetch_memory</span><span class="operator">=&gt;</span><span class="number">10000</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>In the above example 10 rows will be prefetched up to a maximum of 10000 bytes of data.  The Oracle Call Interface Programmer's Guide,
suggests a good row cache value for a scrollable cursor is about 20% of expected size of the record set.</p>
<p>The prefetch settings tell the DBD::Oracle to grab x rows (or x-bytes) when it needs to get new rows. This happens on the first
fetch that sets the current_positon to any value other than 0. In the above example if we do a OCI_FETCH_FIRST the first 10 rows are
loaded into the buffer and DBD::Oracle will not have to go back to the server for more rows. When record 11 is fetched DBD::Oracle
fetches and returns this row and the next 9 rows are loaded into the buffer. In this case if you fetch backwards from 10 to 1
no server round trips are made.</p>
<p>With large record sets it is best not to attempt to go to the last record as this may take some time, A large buffer size might even slow down
the fetch. If you must get the number of rows in a large record set you might try using an few large OCI_FETCH_ABSOLUTEs and then an OCI_FETCH_LAST,
this might save some time. So if you had a record set of 10000 rows and you set the buffer to 5000 and did a OCI_FETCH_LAST one would fetch the first 5000 rows into the buffer then the next 5000 rows.
If one requires only the first few rows there is no need to set a large prefetch value.</p>
<p>If the ora_prefetch_memory less than 1 or not present then memory size is not included in computing the
number of rows to prefetch otherwise the number of rows will be limited to memory size. Likewise if the RowCacheSize is less than 1 it
is not included in the computing of the prefetch rows.</p>
<p>
</p>
<hr />
<h1><a name="dbi_statement_handle_object">DBI Statement Handle Object</a></h1>
<p>
</p>
<h2><a name="statement_handle_methods">Statement Handle Methods</a></h2>
<p>
</p>
<h3><a name="bind_param"><strong>bind_param</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="variable">$bind_type</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</pre>
<p>Allows the user to bind a value and/or a data type to a placeholder.</p>
<p>The value of <code>$param_num</code> is a number if using the '?' or if using &quot;:foo&quot; style placeholders, the complete name
(e.g. &quot;:foo&quot;) must be given.
The <code>$bind_value</code> argument is fairly self-explanatory. A value of <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> will
bind a <a href="#null"><code>NULL</code></a> to the placeholder. Using <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> is useful when you want
to change just the type and will be overwriting the value later.
(Any value is actually usable, but <a href="../../lib/pods/perlfunc.html#undef"><code>undef</code></a> is easy and efficient).</p>
<p>The <code>\%attr</code> hash is used to indicate the data type of the placeholder.
The default value is &quot;varchar&quot;. If you need something else, you must
use one of the values provided by DBI or by DBD::Pg. To use a SQL value,
modify your &quot;use DBI&quot; statement at the top of your script as follows:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
</pre>
<p>This will import some constants into your script. You can plug those
directly into the <a href="#bind_param">bind_param</a> call. Some common ones that you will
encounter are:</p>
<pre>
  SQL_INTEGER</pre>
<p>To use Oracle SQL data types, import the list of values like this:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>You can then set the data types by setting the value of the <a href="#ora_type"><code>ora_type</code></a>
key in the hash passed to <a href="#bind_param">bind_param</a>.
The current list of Oracle data types exported is:</p>
<pre>
  ORA_VARCHAR2 ORA_STRING ORA_NUMBER ORA_LONG ORA_ROWID ORA_DATE ORA_RAW
  ORA_LONGRAW ORA_CHAR ORA_CHARZ ORA_MLSLABEL ORA_XMLTYPE ORA_CLOB ORA_BLOB
  ORA_RSET ORA_VARCHAR2_TABLE ORA_NUMBER_TABLE SQLT_INT SQLT_FLT ORA_OCI
  SQLT_CHR SQLT_BIN</pre>
<p>Data types are &quot;sticky,&quot; in that once a data type is set to a certain placeholder,
it will remain for that placeholder, unless it is explicitly set to something
else afterwards. If the statement has already been prepared, and you switch the
data type to something else, DBD::Oracle will re-prepare the statement for you before
doing the next execute.</p>
<p>Examples:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"SELECT id FROM ptable WHERE size &gt; ? AND title = ?"</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Both arguments below are bound to placeholders as "varchar"</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Reset the datatype for the first placeholder to an integer</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">SQL_INTEGER</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## The "undef" bound above is not used, since we supply params to execute</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Set the first placeholder's value and data type</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_NUMBER</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## Set the second placeholder's value and data type.</span>
  <span class="comment">## We don't send a third argument, so the default "varchar" is used</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$2'</span><span class="operator">,</span> <span class="string">"Zool"</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## We realize that the wrong data type was set above, so we change it:</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$1'</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">SQL_INTEGER</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## We also got the wrong value, so we change that as well.</span>
  <span class="comment">## Because the data type is sticky, we don't need to change it</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">567</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment">## This executes the statement with 567 (integer) and "Zool" (varchar)</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<p>These attributes may be used in the <code>\%attr</code> parameter of the
<a href="../../lib/DBI/bind_param.html">bind_param in the DBI manpage</a> or <a href="../../lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a> statement handle methods.</p>
<dl>
<dt><strong><a name="ora_type" class="item">ora_type</a></strong></dt>

<dd>
<p>Specify the placeholder's datatype using an Oracle datatype.
A fatal error is raised if <a href="#ora_type"><code>ora_type</code></a> and the DBI <code>TYPE</code> attribute
are used for the same placeholder.
Some of these types are not supported by the current version of
DBD::Oracle and will cause a fatal error if used.
Constants for the Oracle datatypes may be imported using</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>Potentially useful values when DBD::Oracle was built using OCI 7 and later:</p>
<pre>
  ORA_VARCHAR2, ORA_STRING, ORA_LONG, ORA_RAW, ORA_LONGRAW,
  ORA_CHAR, ORA_MLSLABEL, ORA_RSET</pre>
<p>Additional values when DBD::Oracle was built using OCI 8 and later:</p>
<pre>
  ORA_CLOB, ORA_BLOB, ORA_XMLTYPE, ORA_VARCHAR2_TABLE, ORA_NUMBER_TABLE</pre>
<p>Additional values when DBD::Oracle was built using OCI 9.2 and later:</p>
<pre>
  SQLT_CHR, SQLT_BIN</pre>
<p>See <a href="#binding_cursors">Binding Cursors</a> for the correct way to use ORA_RSET.</p>
<p>See <a href="#lobs_and_longs">LOBs and LONGs</a> for how to use ORA_CLOB and ORA_BLOB.</p>
<p>See <a href="#sys_dbms_sql_datatypes">SYS.DBMS_SQL datatypes</a> for ORA_VARCHAR2_TABLE, ORA_NUMBER_TABLE.</p>
<p>See <a href="#data_interface_for_persistent_lobs">Data Interface for Persistent LOBs</a> for the correct way to use SQLT_CHR and SQLT_BIN.</p>
<p>See <a href="#other_data_types">Other Data Types</a> for more information.</p>
<p>See also <a href="../../lib/DBI/placeholders_and_bind_values.html">Placeholders and Bind Values in the DBI manpage</a>.</p>
</dd>
<dt><strong><a name="ora_csform" class="item">ora_csform</a></strong></dt>

<dd>
<p>Specify the OCI_ATTR_CHARSET_FORM for the bind value. Valid values
are SQLCS_IMPLICIT (1) and SQLCS_NCHAR (2). Both those constants can
be imported from the DBD::Oracle module. Rarely needed.</p>
</dd>
<dt><strong><a name="ora_csid" class="item">ora_csid</a></strong></dt>

<dd>
<p>Specify the <em>integer</em> OCI_ATTR_CHARSET_ID for the bind value.
Character set names can't be used currently.</p>
</dd>
<dt><strong><a name="ora_maxdata_size" class="item">ora_maxdata_size</a></strong></dt>

<dd>
<p>Specify the integer OCI_ATTR_MAXDATA_SIZE for the bind value.
May be needed if a character set conversion from client to server
causes the data to use more space and so fail with a truncation error.</p>
</dd>
<dt><strong><a name="ora_maxarray_numentries" class="item">ora_maxarray_numentries</a></strong></dt>

<dd>
<p>Specify the maximum number of array entries to allocate. Used with
ORA_VARCHAR2_TABLE, ORA_NUMBER_TABLE. Define the maximum number of
array entries Oracle can pass back to you in OUT variable of type
TABLE OF ... .</p>
</dd>
<dt><strong><a name="ora_internal_type" class="item">ora_internal_type</a></strong></dt>

<dd>
<p>Specify internal data representation. Currently is supported only for
ORA_NUMBER_TABLE.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="optimizing_results">Optimizing Results</a></h3>
<p>
</p>
<h4><a name="prepare_postponed_till_execute">Prepare Postponed Till Execute</a></h4>
<p>The DBD::Oracle module can avoid an explicit 'describe' operation
prior to the execution of the statement unless the application requests
information about the results (such as $sth-&gt;{NAME}). This reduces
communication with the server and increases performance (reducing the
number of PARSE_CALLS inside the server).</p>
<p>However, it also means that SQL errors are not detected until
<code>execute()</code> (or $sth-&gt;{NAME} etc) is called instead of when
<code>prepare()</code> is called. Note that if the describe is triggered by the
use of $sth-&gt;{NAME} or a similar attribute and the describe fails then
<em>an exception is thrown</em> even if <code>RaiseError</code> is false!</p>
<p>Set <a href="#ora_check_sql">ora_check_sql</a> to 0 in <code>prepare()</code> to enable this behaviour.</p>
<p>
</p>
<h3><a name="spaces___padding">Spaces &amp; Padding</a></h3>
<p>
</p>
<h4><a name="trailing_spaces">Trailing Spaces</a></h4>
<p>Please note that only the Oracle OCI 8 strips trailing spaces from VARCHAR placeholder
values and uses Nonpadded Comparison Semantics with the result.
This causes trouble if the spaces are needed for
comparison with a CHAR value or to prevent the value from
becoming '' which Oracle treats as NULL.
Look for Blank-padded Comparison Semantics and Nonpadded
Comparison Semantics in Oracle's SQL Reference or Server
SQL Reference for more details.</p>
<p>To preserve trailing spaces in placeholder values for Oracle clients that use OCI 8,
either change the default placeholder type with <a href="#ora_ph_type">ora_ph_type</a> or the placeholder
type for a particular call to <a href="../../lib/DBI/bind.html">bind in the DBI manpage</a> or <a href="../../lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a>
with <a href="#ora_type">ora_type</a> or <code>TYPE</code>.
Using <a href="#ora_char">ORA_CHAR</a> with <a href="#ora_type">ora_type</a> or <code>SQL_CHAR</code> with <code>TYPE</code>
allows the placeholder to be used with Padded Comparison Semantics
if the value it is being compared to is a CHAR, NCHAR, or literal.</p>
<p>Please remember that using spaces as a value or at the end of
a value makes visually distinguishing values with different
numbers of spaces difficult and should be avoided.</p>
<p>Oracle Clients that use OCI 9.2 do not strip trailing spaces.</p>
<p>
</p>
<h4><a name="padded_char_fields">Padded Char Fields</a></h4>
<p>Oracle Clients after OCI 9.2 will automatically pad CHAR placeholder values to the size of the CHAR.
As the default placeholder type value in DBD::Oracle is ORA_VARCHAR2 to access this behaviour you will
have to change the default placeholder type with <a href="#ora_ph_type">ora_ph_type</a> or placeholder
type for a particular call with <a href="../../lib/DBI/bind.html">bind in the DBI manpage</a> or <a href="../../lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a>
with <a href="#ora_char">ORA_CHAR</a>.</p>
<p>
</p>
<h4><a name="unicode">Unicode</a></h4>
<p>DBD::Oracle now supports Unicode UTF-8. There are, however, a number
of issues you should be aware of, so please read all this section
carefully.</p>
<p>In this section we'll discuss &quot;Perl and Unicode&quot;, then &quot;Oracle and
Unicode&quot;, and finally &quot;DBD::Oracle and Unicode&quot;.</p>
<p>Information about Unicode in general can be found at:
<a href="http://www.unicode.org/">http://www.unicode.org/</a>. It is well worth reading because there are
many misconceptions about Unicode and you may be holding some of them.</p>
<p>
</p>
<h4><a name="perl_and_unicode">Perl and Unicode</a></h4>
<p>Perl began implementing Unicode with version 5.6, but the implementation
did not mature until version 5.8 and later. If you plan to use Unicode
you are <em>strongly</em> urged to use Perl 5.8.2 or later and to <em>carefully</em> read
the Perl documentation on Unicode:</p>
<pre>
   <a href="../../lib/pods/perldoc.html">perldoc</a> <a href="../../lib/pods/perluniintro.html">perluniintro</a>    # in Perl 5.8 or later
   <a href="../../lib/pods/perldoc.html">perldoc</a> <a href="../../lib/pods/perlunicode.html">perlunicode</a></pre>
<p>And then read it again.</p>
<p>Perl's internal Unicode format is UTF-8
which corresponds to the Oracle character set called AL32UTF8.</p>
<p>
</p>
<h4><a name="oracle_and_unicode">Oracle and Unicode</a></h4>
<p>Oracle supports many characters sets, including several different forms
of Unicode.  These include:</p>
<pre>
  AL16UTF16  =&gt;  valid for NCHAR columns (CSID=2000)
  UTF8       =&gt;  valid for NCHAR columns (CSID=871), deprecated
  AL32UTF8   =&gt;  valid for NCHAR and CHAR columns (CSID=873)</pre>
<p>When you create an Oracle database, you must specify the DATABASE
character set (used for DDL, DML and CHAR datatypes) and the NATIONAL
character set (used for NCHAR and NCLOB types).
The character sets used in your database can be found using:</p>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_nls_parameters</span><span class="operator">()</span>
  <span class="variable">$database_charset</span> <span class="operator">=</span> <span class="variable">$hash_ref</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">NLS_CHARACTERSET</span><span class="operator">}</span><span class="operator">;</span>
  <span class="variable">$national_charset</span> <span class="operator">=</span> <span class="variable">$hash_ref</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">NLS_NCHAR_CHARACTERSET</span><span class="operator">}</span><span class="operator">;</span>
</pre>
<p>The Oracle 9.2 and later default for the national character set is AL16UTF16.
The default for the database character set is often US7ASCII.
Although many experienced DBAs will consider an 8bit character set like
WE8ISO8859P1 or WE8MSWIN1252.  To use any character set with Oracle
other than US7ASCII, requires that the NLS_LANG environment variable be set.
See the <a href="#oracle_utf8_is_not_utf_8">Oracle UTF8 is not UTF-8</a> section below.</p>
<p>You are strongly urged to read the Oracle Internationalization documentation
specifically with respect the choices and trade offs for creating
a databases for use with international character sets.</p>
<p>Oracle uses the NLS_LANG environment variable to indicate what
character set is being used on the client.  When fetching data Oracle
will convert from whatever the database character set is to the client
character set specified by NLS_LANG. Similarly, when sending data to
the database Oracle will convert from the character set specified by
NLS_LANG to the database character set.</p>
<p>The NLS_NCHAR environment variable can be used to define a different
character set for 'national' (NCHAR) character types.</p>
<p>Both UTF8 and AL32UTF8 can be used in NLS_LANG and NLS_NCHAR.
For example:</p>
<pre>
   NLS_LANG=AMERICAN_AMERICA.UTF8
   NLS_LANG=AMERICAN_AMERICA.AL32UTF8
   NLS_NCHAR=UTF8
   NLS_NCHAR=AL32UTF8</pre>
<p>
</p>
<h4><a name="oracle_utf8_is_not_utf_8">Oracle UTF8 is not UTF-8</a></h4>
<p>AL32UTF8 should be used in preference to UTF8 if it works for you,
which it should for Oracle 9.2 or later. If you're using an old
version of Oracle that doesn't support AL32UTF8 then you should
avoid using any Unicode characters that require surrogates, in other
words characters beyond the Unicode BMP (Basic Multilingual Plane).</p>
<p>That's because the character set that Oracle calls &quot;UTF8&quot; doesn't
conform to the UTF-8 standard in its handling of surrogate characters.
Technically the encoding that Oracle calls &quot;UTF8&quot; is known as &quot;CESU-8&quot;.
Here are a couple of extracts from <a href="http://www.unicode.org/reports/tr26/">http://www.unicode.org/reports/tr26/</a>:</p>
<pre>
  CESU-8 is useful in 8-bit processing environments where binary
  collation with UTF-16 is required. It is designed and recommended
  for use only within products requiring this UTF-16 binary collation
  equivalence. It is not intended nor recommended for open interchange.</pre>
<pre>
  As a very small percentage of characters in a typical data stream
  are expected to be supplementary characters, there is a strong
  possibility that CESU-8 data may be misinterpreted as UTF-8.
  Therefore, all use of CESU-8 outside closed implementations is
  strongly discouraged, such as the emittance of CESU-8 in output
  files, markup language or other open transmission forms.</pre>
<p>Oracle uses this internally because it collates (sorts) in the same order
as UTF16, which is the basis of Oracle's internal collation definitions.</p>
<p>Rather than change UTF8 for clients Oracle chose to define a new character
set called &quot;AL32UTF8&quot; which does conform to the UTF-8 standard.
(The AL32UTF8 character set can't be used on the server because it
would break collation.)</p>
<p>Because of that, for the rest of this document we'll use &quot;AL32UTF8&quot;.
If you're using an Oracle version below 9.2 you'll need to use &quot;UTF8&quot;
until you upgrade.</p>
<p>
</p>
<h4><a name="dbd__oracle_and_unicode">DBD::Oracle and Unicode</a></h4>
<p>DBD::Oracle Unicode support has been implemented for Oracle versions 9
or greater, and Perl version 5.6 or greater (though we <em>strongly</em>
suggest that you use Perl 5.8.2 or later).</p>
<p>You can check which Oracle version your DBD::Oracle was built with by
importing the <a href="#ora_oci"><code>ORA_OCI</code></a> constant from DBD::Oracle.</p>
<p><strong>Fetching Data</strong></p>
<p>Any data returned from Oracle to DBD::Oracle in the AL32UTF8
character set will be marked as UTF-8 to ensure correct handling by Perl.</p>
<p>For Oracle to return data in the AL32UTF8 character set the
NLS_LANG or NLS_NCHAR environment variable <em>must</em> be set as described
in the previous section.</p>
<p>When fetching NCHAR, NVARCHAR, or NCLOB data from Oracle, DBD::Oracle
will set the Perl UTF-8 flag on the returned data if either NLS_NCHAR
is AL32UTF8, or NLS_NCHAR is not set and NLS_LANG is AL32UTF8.</p>
<p>When fetching other character data from Oracle, DBD::Oracle
will set the Perl UTF-8 flag on the returned data if NLS_LANG is AL32UTF8.</p>
<p><strong>Sending Data using Placeholders</strong></p>
<p>Data bound to a placeholder is assumed to be in the default client
character set (specified by NLS_LANG) except for a few special
cases. These are listed here with the highest precedence first:</p>
<p>If the <a href="#ora_csid"><code>ora_csid</code></a> attribute is given to <code>bind_param()</code> then that
is passed to Oracle and takes precedence.</p>
<p>If the value is a Perl Unicode string (UTF-8) then DBD::Oracle
ensures that Oracle uses the Unicode character set, regardless of
the NLS_LANG and NLS_NCHAR settings.</p>
<p>If the placeholder is for inserting an NCLOB then the client NLS_NCHAR
character set is used. (That's useful but inconsistent with the other behaviour
so may change. Best to be explicit by using the <a href="#ora_csform"><code>ora_csform</code></a>
attribute.)</p>
<p>If the <a href="#ora_csform"><code>ora_csform</code></a> attribute is given to <code>bind_param()</code> then that
determines if the value should be assumed to be in the default
(NLS_LANG) or NCHAR (NLS_NCHAR) client character set.</p>
<pre>
   <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw( SQLCS_IMPLICIT SQLCS_NCHAR )</span><span class="operator">;</span>
   <span class="operator">...</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_csform</span> <span class="operator">=&gt;</span> <span class="variable">SQLCS_NCHAR</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>or</p>
<pre>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_ph_csform</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">SQLCS_NCHAR</span><span class="operator">;</span> <span class="comment"># default for all future placeholders</span>
</pre>
<p>Binding with bind_param_array and execute_array is also UTF-8 compatible in the same way.  If you attempt to
insert UTF-8 data into a non UTF-8 Oracle instance or with an non UTF-8 NCHAR or NVARCHAR the insert
will still happen but a error code of 0 will be returned with the following warning;</p>
<pre>
  DBD Oracle Warning: You have mixed utf8 and non-utf8 in an array bind in parameter#1. This may result in corrupt data.
  The Query charset id=1, name=US7ASCII</pre>
<p>The warning will report the parameter number and the NCHAR setting that the query is running.</p>
<p><strong>Sending Data using SQL</strong></p>
<p>Oracle assumes the SQL statement is in the default client character
set (as specified by NLS_LANG). So Unicode strings containing
non-ASCII characters should not be used unless the default client
character set is AL32UTF8.</p>
<p>
</p>
<h4><a name="dbd__oracle_and_other_character_sets_and_encodings">DBD::Oracle and Other Character Sets and Encodings</a></h4>
<p>The only multi-byte Oracle character set supported by DBD::Oracle is
&quot;AL32UTF8&quot; (and &quot;UTF8&quot;). Single-byte character sets should work well.</p>
<p>
</p>
<h4><a name="other_data_types">Other Data Types</a></h4>
<p>DBD::Oracle does not <em>explicitly</em> support most Oracle datatypes.
It simply asks Oracle to return them as strings and Oracle does so.
Mostly.  Similarly when binding placeholder values DBD::Oracle binds
them as strings and Oracle converts them to the appropriate type,
such as DATE, when used.</p>
<p>Some of these automatic conversions to and from strings use NLS
settings to control the formatting for output and the parsing for
input. The most common example is the DATE type. The default NLS
format for DATE might be DD-MON-YYYY and so when a DATE type is
fetched that's how Oracle will format the date. NLS settings also
control the default parsing of strings into DATE values. An error
will be generated if the contents of the string don't match the
NLS format. If you're dealing in dates which don't match the default
NLS format then you can either change the default NLS format or, more
commonly, use TO_CHAR(field, &quot;format&quot;) and TO_DATE(?, &quot;format&quot;)
to explicitly specify formats for converting to and from strings.</p>
<p>A slightly more subtle problem can occur with NUMBER types. The
default NLS settings might format numbers with a fullstop (&quot;<code>.</code>&quot;)
to separate thousands and a comma (&quot;<code>,</code>&quot;) as the decimal point.
Perl will generate warnings and use incorrect values when numbers,
returned and formatted as strings in this way by Oracle, are used
in a numeric context.  You could explicitly convert each numeric
value using the TO_CHAR(...) function but that gets tedious very
quickly. The best fix is to change the NLS settings. That can be
done for an individual connection by doing:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,'"</span><span class="operator">);</span>
</pre>
<p>There are some types, like BOOLEAN, that Oracle does not automatically
convert to or from strings (pity).  These need to be converted
explicitly using SQL or PL/SQL functions.</p>
<p>Examples:</p>
<pre>
  <span class="comment"># DATE values</span>
  <span class="keyword">my</span> <span class="variable">$sth0</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">SQL_END</span> <span class="operator">);</span><span class="string">
  SELECT username, TO_CHAR( created, ? )
      FROM all_users
      WHERE created &gt;= TO_DATE( ?, ? )
   SQL_END
  $sth0-&gt;execute( 'YYYY-MM-DD HH24:MI:SS', "2003", 'YYYY' );
  </span>
</pre>
<pre>
  <span class="comment"># BOOLEAN values</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">PLSQL_END</span> <span class="operator">);</span><span class="string">
  DECLARE
      b0 BOOLEAN;
      b1 BOOLEAN;
      o0 VARCHAR2(32);
      o1 VARCHAR2(32);
  </span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="variable">i</span> <span class="variable">VARCHAR2</span> <span class="operator">)</span> <span class="variable">RETURN</span> <span class="variable">BOOLEAN</span> <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
         <span class="variable">IF</span>    <span class="variable">i</span> <span class="variable">IS</span> <span class="variable">NULL</span>          <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="variable">NULL</span><span class="operator">;</span>
         <span class="variable">ELSIF</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">'F'</span> <span class="variable">OR</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">'0'</span> <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="variable">FALSE</span><span class="operator">;</span>
         <span class="variable">ELSE</span>                          <span class="variable">RETURN</span> <span class="variable">TRUE</span><span class="operator">;</span>
         <span class="keyword">END</span> <span class="variable">IF</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
      <span class="variable">FUNCTION</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">i</span> <span class="variable">BOOLEAN</span> <span class="operator">)</span> <span class="variable">RETURN</span> <span class="variable">NUMBER</span> <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
         <span class="variable">IF</span>    <span class="variable">i</span> <span class="variable">IS</span> <span class="variable">NULL</span> <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="variable">NULL</span><span class="operator">;</span>
         <span class="variable">ELSIF</span> <span class="variable">i</span>         <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="number">1</span><span class="operator">;</span>
         <span class="variable">ELSE</span>                 <span class="variable">RETURN</span> <span class="number">0</span><span class="operator">;</span>
         <span class="keyword">END</span> <span class="variable">IF</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
        <span class="keyword">BEGIN</span>
      <span class="operator">--</span> <span class="variable">Converting</span> <span class="keyword">values</span> <span class="variable">to</span> <span class="variable">BOOLEAN</span>
      <span class="variable">b0</span> <span class="operator">:=</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="operator">:</span><span class="variable">i0</span> <span class="operator">);</span>
      <span class="variable">b1</span> <span class="operator">:=</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="operator">:</span><span class="variable">i1</span> <span class="operator">);</span>
</pre>
<pre>
      <span class="operator">--</span> <span class="variable">Converting</span> <span class="keyword">values</span> <span class="variable">from</span> <span class="variable">BOOLEAN</span>
      <span class="operator">:</span><span class="variable">o0</span> <span class="operator">:=</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">b0</span> <span class="operator">);</span>
      <span class="operator">:</span><span class="variable">o1</span> <span class="operator">:=</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">b1</span> <span class="operator">);</span>
        <span class="keyword">END</span><span class="operator">;</span>
        <span class="variable">PLSQL_END</span>
        <span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$i0</span><span class="operator">,</span> <span class="variable">$i1</span><span class="operator">,</span> <span class="variable">$o0</span><span class="operator">,</span> <span class="variable">$o1</span> <span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"Something else"</span> <span class="operator">);</span>
        <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">":i0"</span><span class="operator">,</span> <span class="variable">$i0</span> <span class="operator">);</span>
        <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">":i1"</span><span class="operator">,</span> <span class="variable">$i1</span> <span class="operator">);</span>
        <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">":o0"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$o0</span><span class="operator">,</span> <span class="number">32</span> <span class="operator">);</span>
        <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">":o1"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$o1</span><span class="operator">,</span> <span class="number">32</span> <span class="operator">);</span>
        <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
        <span class="keyword">foreach</span> <span class="operator">(</span> <span class="variable">$i0</span><span class="operator">,</span> <span class="variable">$b0</span><span class="operator">,</span> <span class="variable">$o0</span><span class="operator">,</span> <span class="variable">$i1</span><span class="operator">,</span> <span class="variable">$b1</span><span class="operator">,</span> <span class="variable">$o1</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"(undef)"</span> <span class="keyword">if</span> <span class="operator">!</span> <span class="keyword">defined</span> <span class="variable">$_</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">print</span> <span class="string">"</span><span class="variable">$i0</span><span class="string"> to </span><span class="variable">$o0</span><span class="string">, </span><span class="variable">$i1</span><span class="string"> to </span><span class="variable">$o1</span><span class="string">\n"</span><span class="operator">;</span>
        <span class="comment"># Result is : "'' to '(undef)', 'Something else' to '1'"</span>
</pre>
<p>
</p>
<h4><a name="object___collection_data_types">Object &amp; Collection Data Types</a></h4>
<p>Oracle databases allow for the creation of object oriented like user-defined types.
There are two types of objects, Embedded--an object stored in a column of a regular table
and REF--an object that uses the REF retrieval mechanism.</p>
<p>DBD::Oracle supports only the 'selection' of embedded objects of the following types OBJECT, VARRAY
and TABLE in any combination. Support is seamless and recursive, meaning you
need only supply a simple SQL statement to get all the values in an embedded object.
You can either get the values as an array of scalars or they can be returned into a DBD::Oracle::Object.</p>
<p>Array example, given this type and table;</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span>  <span class="string">"PHONE_NUMBERS"</span> <span class="variable">as</span> <span class="variable">varray</span><span class="operator">(</span><span class="number">10</span><span class="operator">)</span> <span class="variable">of</span> <span class="variable">varchar</span><span class="operator">(</span><span class="number">30</span><span class="operator">);</span>
</pre>
<pre>
  CREATE TABLE  &quot;CONTACT&quot;
     (  &quot;COMPANYNAME&quot; VARCHAR2(40),
        &quot;ADDRESS&quot; VARCHAR2(100),
        &quot;PHONE_NUMBERS&quot;  &quot;PHONE_NUMBERS&quot;
   )</pre>
<p>The code to access all the data in the table could be something like this;</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'SELECT * FROM CONTACT'</span><span class="operator">);</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
   <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$company</span><span class="operator">,</span> <span class="variable">$address</span><span class="operator">,</span> <span class="variable">$phone</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">())</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"Company: "</span><span class="operator">.</span><span class="variable">$company</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"Address: "</span><span class="operator">.</span><span class="variable">$address</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"Phone #: "</span><span class="operator">;</span>
</pre>
<pre>
        <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$items</span> <span class="operator">(</span><span class="variable">@$phone</span><span class="operator">){</span>
           <span class="keyword">print</span> <span class="variable">$items</span><span class="operator">.</span><span class="string">", "</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">print</span> <span class="string">"\n"</span><span class="operator">;</span>
           <span class="operator">}</span>
</pre>
<p>Note that values in PHONE_NUMBERS are returned as an array reference '@$phone'.</p>
<p>As stated before DBD::Oracle will automatically drill into the embedded object and extract
all of the data as reference arrays of scalars. The example below has OBJECT type embedded in a TABLE type embedded in an
SQL TABLE;</p>
<pre>
   <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">GRADELIST</span> <span class="variable">AS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">NUMBER</span><span class="operator">;</span>
</pre>
<pre>
   <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">STUDENT</span> <span class="variable">AS</span> <span class="variable">OBJECT</span><span class="operator">(</span>
       <span class="variable">NAME</span>          <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">60</span><span class="operator">),</span>
       <span class="variable">SOME_GRADES</span>   <span class="variable">GRADELIST</span><span class="operator">);</span>
</pre>
<pre>
   <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">STUDENTS_T</span> <span class="variable">AS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">STUDENT</span><span class="operator">;</span>
</pre>
<pre>
   <span class="variable">CREATE</span> <span class="variable">TABLE</span> <span class="variable">GROUPS</span><span class="operator">(</span>
       <span class="variable">GRP_ID</span>        <span class="variable">NUMBER</span><span class="operator">(</span><span class="number">4</span><span class="operator">),</span>
       <span class="variable">GRP_NAME</span>      <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
       <span class="variable">STUDENTS</span>      <span class="variable">STUDENTS_T</span><span class="operator">)</span>
     <span class="variable">NESTED</span> <span class="variable">TABLE</span> <span class="variable">STUDENTS</span> <span class="variable">STORE</span> <span class="variable">AS</span> <span class="variable">GROUP_STUDENTS_TAB</span>
      <span class="operator">(</span><span class="variable">NESTED</span> <span class="variable">TABLE</span> <span class="variable">SOME_GRADES</span> <span class="variable">STORE</span> <span class="variable">AS</span> <span class="variable">GROUP_STUDENT_GRADES_TAB</span><span class="operator">);</span>
</pre>
<p>The following code will access all of the embedded data;</p>
<pre>
   <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select grp_id,grp_name,students as my_students_test from groups'</span><span class="operator">;</span>
   <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
   <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span><span class="variable">$grp_id</span><span class="operator">,</span><span class="variable">$grp_name</span><span class="operator">,</span><span class="variable">$students</span><span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
      <span class="keyword">print</span> <span class="string">"Group ID#"</span><span class="operator">.</span><span class="variable">$grp_id</span><span class="operator">.</span><span class="string">" Group Name ="</span><span class="operator">.</span><span class="variable">$grp_name</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
      <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$student</span> <span class="operator">(</span><span class="variable">@$students</span><span class="operator">){</span>
         <span class="keyword">print</span> <span class="string">"Name:"</span><span class="operator">.</span><span class="variable">$student</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
         <span class="keyword">print</span> <span class="string">"Marks:"</span><span class="operator">;</span>
         <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$grades</span> <span class="operator">(</span><span class="variable">@$student</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">){</span>
            <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$marks</span> <span class="operator">(</span><span class="variable">@$grades</span><span class="operator">){</span>
               <span class="keyword">print</span> <span class="variable">$marks</span><span class="operator">.</span><span class="string">","</span><span class="operator">;</span>
            <span class="operator">}</span>
         <span class="operator">}</span>
         <span class="keyword">print</span> <span class="string">"\n"</span><span class="operator">;</span>
      <span class="operator">}</span>
      <span class="keyword">print</span> <span class="string">"\n"</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>Object example, given this object and table;</p>
<pre>
   <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">Person</span> <span class="variable">AS</span> <span class="variable">OBJECT</span> <span class="operator">(</span>
     <span class="variable">name</span>    <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">20</span><span class="operator">),</span>
     <span class="variable">age</span>     <span class="variable">INTEGER</span><span class="operator">)</span>
   <span class="operator">)</span> <span class="variable">NOT</span> <span class="variable">FINAL</span><span class="operator">;</span>
</pre>
<pre>
   <span class="variable">CREATE</span> <span class="variable">TYPE</span> <span class="variable">Employee</span> <span class="variable">UNDER</span> <span class="variable">Person</span> <span class="operator">(</span>
     <span class="variable">salary</span>  <span class="variable">NUMERIC</span><span class="operator">(</span><span class="number">8</span><span class="operator">,</span><span class="number">2</span><span class="operator">)</span>
   <span class="operator">);</span>
</pre>
<pre>
   <span class="variable">CREATE</span> <span class="variable">TABLE</span> <span class="variable">people</span> <span class="operator">(</span><span class="variable">id</span> <span class="variable">INTEGER</span><span class="operator">,</span> <span class="variable">obj</span> <span class="variable">Person</span><span class="operator">);</span>
</pre>
<pre>
   <span class="variable">INSERT</span> <span class="variable">INTO</span> <span class="variable">people</span> <span class="variable">VALUES</span> <span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="variable">Person</span><span class="operator">(</span><span class="string">'Black'</span><span class="operator">,</span> <span class="number">25</span><span class="operator">));</span>
   <span class="variable">INSERT</span> <span class="variable">INTO</span> <span class="variable">people</span> <span class="variable">VALUES</span> <span class="operator">(</span><span class="number">2</span><span class="operator">,</span> <span class="variable">Employee</span><span class="operator">(</span><span class="string">'Smith'</span><span class="operator">,</span> <span class="number">44</span><span class="operator">,</span> <span class="number">5000</span><span class="operator">));</span>
</pre>
<p>The following code will access the data;</p>
<pre>
   <span class="variable">$dbh</span><span class="operator">{</span><span class="string">'ora_objects'</span><span class="operator">}</span> <span class="operator">=&gt;</span><span class="number">1</span><span class="operator">;</span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"select * from people order by id"</span><span class="operator">);</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<pre>
   <span class="comment"># object are fetched as instance of DBD::Oracle::Object</span>
   <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$id1</span><span class="operator">,</span> <span class="variable">$obj1</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">();</span>
   <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$id2</span><span class="operator">,</span> <span class="variable">$obj2</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">();</span>
</pre>
<pre>
   <span class="comment"># get full type-name of object</span>
   <span class="keyword">print</span> <span class="variable">$obj1</span><span class="operator">-&gt;</span><span class="variable">type_name</span><span class="operator">.</span><span class="string">"44\n"</span><span class="operator">;</span>     <span class="comment"># 'TEST.PERSON' is printed</span>
   <span class="keyword">print</span> <span class="variable">$obj2</span><span class="operator">-&gt;</span><span class="variable">type_name</span><span class="operator">.</span><span class="string">"4\n"</span><span class="operator">;</span>      <span class="comment"># 'TEST.EMPLOYEE' is printed</span>
</pre>
<pre>
   <span class="comment"># get attribute NAME from object</span>
   <span class="keyword">print</span> <span class="variable">$obj1</span><span class="operator">-&gt;</span><span class="variable">attr</span><span class="operator">(</span><span class="string">'NAME'</span><span class="operator">).</span><span class="string">"3\n"</span><span class="operator">;</span>   <span class="comment"># 'Black' is printed</span>
   <span class="keyword">print</span> <span class="variable">$obj2</span><span class="operator">-&gt;</span><span class="variable">attr</span><span class="operator">(</span><span class="string">'NAME'</span><span class="operator">).</span><span class="string">"3\n"</span><span class="operator">;</span>   <span class="comment"># 'Smith' is printed</span>
</pre>
<pre>
   <span class="comment"># get all atributes as hash reference</span>
   <span class="keyword">my</span> <span class="variable">$h1</span> <span class="operator">=</span> <span class="variable">$obj1</span><span class="operator">-&gt;</span><span class="variable">attr</span><span class="operator">;</span>        <span class="comment"># returns {'NAME' =&gt; 'Black', 'AGE' =&gt; 25}</span>
   <span class="keyword">my</span> <span class="variable">$h2</span> <span class="operator">=</span> <span class="variable">$obj2</span><span class="operator">-&gt;</span><span class="variable">attr</span><span class="operator">;</span>        <span class="comment"># returns {'NAME' =&gt; 'Smith', 'AGE' =&gt; 44,</span>
                                <span class="comment">#          'SALARY' =&gt; 5000 }</span>
</pre>
<pre>
   <span class="comment"># get all attributes (names and values) as array</span>
   <span class="keyword">my</span> <span class="variable">@a1</span> <span class="operator">=</span> <span class="variable">$obj1</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">;</span>  <span class="comment"># returns ('NAME', 'Black', 'AGE', 25)</span>
   <span class="keyword">my</span> <span class="variable">@a2</span> <span class="operator">=</span> <span class="variable">$obj2</span><span class="operator">-&gt;</span><span class="variable">attributes</span><span class="operator">;</span>  <span class="comment"># returns ('NAME', 'Smith', 'AGE', 44,</span>
                                <span class="comment">#          'SALARY', 5000 )</span>
</pre>
<p>So far DBD::Oracle has been tested on a table with 20 embedded Objects, Varrays and Tables
nested to 10 levels.</p>
<p>Any NULL values found in the embedded object will be returned as 'undef'.</p>
<p>
</p>
<h4><a name="support_for_insert_of_xmltype__ora_xmltype_">Support for Insert of XMLType (ORA_XMLTYPE)</a></h4>
<p>Inserting large XML data sets into tables with XMLType fields is now supported by DBD::Oracle. The only special
requirement is the use of <code>bind_param()</code> with an attribute hash parameter that specifies ora_type as ORA_XMLTYPE. For
example with a table like this;</p>
<pre>
   <span class="variable">create</span> <span class="variable">table</span> <span class="variable">books</span> <span class="operator">(</span><span class="variable">book_id</span> <span class="variable">number</span><span class="operator">,</span> <span class="variable">book_xml</span> <span class="variable">XMLType</span><span class="operator">);</span>
</pre>
<p>one can insert data using this code</p>
<pre>
   <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'insert into books values (1,:p_xml)'</span><span class="operator">;</span>
   <span class="variable">$xml</span><span class="operator">=</span> <span class="string">'&lt;Books&gt;
                &lt;Book id=1&gt;
                        &lt;Title&gt;Programming the Perl DBI&lt;/Title&gt;
                        &lt;Subtitle&gt;The Cheetah Book&lt;/Subtitle&gt;
                        &lt;Authors&gt;
                                &lt;Author&gt;T. Bunce&lt;/Author&gt;
                                &lt;Author&gt;Alligator Descartes&lt;/Author&gt;
                        &lt;/Authors&gt;
   </span>
</pre>
<pre>
                &lt;/Book&gt;
                &lt;Book id=10000&gt;...
            &lt;/Books&gt;';
   my $sth =$dbh-&gt; prepare($SQL);
   $sth-&gt; bind_param(&quot;p_xml&quot;, $xml, { ora_type =&gt; ORA_XMLTYPE });
   $sth-&gt; execute();</pre>
<p>In the above case we will assume that $xml has 10000 Book nodes and is over 32k in size and is well formed XML.
This will also work for XML that is smaller than 32k as well. Attempting to insert malformed XML will cause an error.</p>
<p>
</p>
<h4><a name="binding_cursors">Binding Cursors</a></h4>
<p>Cursors can be returned from PL/SQL blocks, either from stored
functions (or procedures with OUT parameters) or
from direct <code>OPEN</code> statements, as shown below:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(...);</span>
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
      BEGIN OPEN :cursor FOR
          SELECT table_name, tablespace_name
          FROM user_tables WHERE tablespace_name = :space;
      END;
  }</span><span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":space"</span><span class="operator">,</span> <span class="string">"USERS"</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span><span class="operator">;</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$sth2</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="comment"># $sth2 is now a valid DBI statement handle for the cursor</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>The only special requirement is the use of <code>bind_param_inout()</code> with an
attribute hash parameter that specifies <a href="#ora_type"><code>ora_type</code></a> as <code>ORA_RSET</code>.
If you don't do that you'll get an error from the <code>execute()</code> like:
&quot;ORA-06550: line X, column Y: PLS-00306: wrong number or types of
arguments in call to ...&quot;.</p>
<p>Here's an alternative form using a function that returns a cursor.
This example uses the pre-defined weak (or generic) REF CURSOR type
SYS_REFCURSOR. This is an Oracle 9 feature.</p>
<pre>
  <span class="comment"># Create the function that returns a cursor</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{
      CREATE OR REPLACE FUNCTION sp_ListEmp RETURN SYS_REFCURSOR
      AS l_cursor SYS_REFCURSOR;
      BEGIN
          OPEN l_cursor FOR select ename, empno from emp
              ORDER BY ename;
          RETURN l_cursor;
      END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># Use the function that returns a cursor</span>
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{BEGIN :cursor := sp_ListEmp; END;}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span><span class="operator">;</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$sth2</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="comment"># $sth2 is now a valid DBI statement handle for the cursor</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>A cursor obtained from PL/SQL as above may be passed back to PL/SQL
by binding for input, as shown in this example, which explicitly
closes a cursor:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$sth3</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"BEGIN CLOSE :cursor; END;"</span><span class="operator">);</span>
  <span class="variable">$sth3</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="variable">$sth2</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth3</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>It is not normally necessary to close a cursor
explicitly in this way. Oracle will close the cursor automatically
at the first client-server interaction after the cursor statement handle is
destroyed. An explicit close may be desirable if the reference to
the cursor handle from the PL/SQL statement handle delays the destruction
of the cursor handle for too long. This reference remains until the
PL/SQL handle is re-bound, re-executed or destroyed.</p>
<p>See the <code>curref.pl</code> script in the Oracle.ex directory in the DBD::Oracle
source distribution for a complete working example.</p>
<p>
</p>
<h4><a name="fetching_nested_cursors">Fetching Nested Cursors</a></h4>
<p>Oracle supports the use of select list expressions of type REF CURSOR.
These may be explicit cursor expressions - <code>CURSOR(SELECT ...)</code>, or
calls to PL/SQL functions which return REF CURSOR values. The values
of these expressions are known as nested cursors.</p>
<p>The value returned to a Perl program when a nested cursor is fetched
is a statement handle. This statement handle is ready to be fetched from.
It should not (indeed, must not) be executed.</p>
<p>Oracle imposes a restriction on the order of fetching when nested
cursors are used. Suppose <code>$sth1</code> is a handle for a select statement
involving nested cursors, and <code>$sth2</code> is a nested cursor handle fetched
from <code>$sth1</code>. <code>$sth2</code> can only be fetched from while <code>$sth1</code> is
still active, and the row containing <code>$sth2</code> is still current in <code>$sth1</code>.
Any attempt to fetch another row from <code>$sth1</code> renders all nested cursor
handles previously fetched from <code>$sth1</code> defunct.</p>
<p>Fetching from such a defunct handle results in an error with the message
<code>ERROR nested cursor is defunct (parent row is no longer current)</code>.</p>
<p>This means that the <code>fetchall...</code> or <code>selectall...</code> methods are not useful
for queries returning nested cursors. By the time such a method returns,
all the nested cursor handles it has fetched will be defunct.</p>
<p>It is necessary to use an explicit fetch loop, and to do all the
fetching of nested cursors within the loop, as the following example
shows:</p>
<pre>
    <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(...);</span>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        SELECT dname, CURSOR(
            SELECT ename FROM emp
                WHERE emp.deptno = dept.deptno
                ORDER BY ename
        ) FROM dept ORDER BY dname
    }</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dname</span><span class="operator">,</span> <span class="variable">$nested</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"</span><span class="variable">$dname</span><span class="string">\n"</span><span class="operator">;</span>
        <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$ename</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$nested</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="string">"        </span><span class="variable">$ename</span><span class="string">\n"</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>The cursor returned by the function <code>sp_ListEmp</code> defined in the
previous section can be fetched as a nested cursor as follows:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT sp_ListEmp FROM dual}</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$nested</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$nested</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>
</p>
<h4><a name="pre_fetching_nested_cursors">Pre-fetching Nested Cursors</a></h4>
<p>By default, DBD::Oracle pre-fetches rows in order to reduce the number of
round trips to the server. For queries which do not involve nested cursors,
the number of pre-fetched rows is controlled by the DBI database handle
attribute <code>RowCacheSize</code> (q.v.).</p>
<p>In Oracle, server side open cursors are a controlled resource, limited in
number, on a per session basis, to the value of the initialization
parameter <code>OPEN_CURSORS</code>. Nested cursors count towards this limit.
Each nested cursor in the current row counts 1, as does
each nested cursor in a pre-fetched row. Defunct nested cursors do not count.</p>
<p>An Oracle specific database handle attribute, <code>ora_max_nested_cursors</code>,
further controls pre-fetching for queries involving nested cursors. For
each statement handle, the total number of nested cursors in pre-fetched
rows is limited to the value of this parameter. The default value
is 0, which disables pre-fetching for queries involving nested cursors.</p>
<p>
</p>
<h3><a name="bind_param_inout"><strong>bind_param_inout</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$scalar</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</pre>
<p>DBD::Oracle fully supports bind_param_inout below are some uses for this method.</p>
<p>
</p>
<h4><a name="returning_a_value_from_an_insert"><strong>Returning A Value from an INSERT</strong></a></h4>
<p>Oracle supports an extended SQL insert syntax which will return one
or more of the values inserted. This can be particularly useful for
single-pass insertion of values with re-used sequence values
(avoiding a separate &quot;select seq.nextval from dual&quot; step).</p>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">qq{
      INSERT INTO foo (id, bar)
      VALUES (foo_id_seq.nextval, :bar)
      RETURNING id INTO :id
  }</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":bar"</span><span class="operator">,</span> <span class="number">42</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":id"</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$new_id</span><span class="operator">,</span> <span class="number">99</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"The id of the new record is </span><span class="variable">$new_id</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
<p>If you have many columns to bind you can use code like this:</p>
<pre>
  <span class="variable">@params</span> <span class="operator">=</span> <span class="operator">(...</span> <span class="variable">column</span> <span class="keyword">values</span> <span class="keyword">for</span> <span class="variable">record</span> <span class="variable">to</span> <span class="variable">be</span> <span class="variable">inserted</span> <span class="operator">...);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span> <span class="variable">$params</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">-</span><span class="number">1</span><span class="operator">]</span><span class="operator">)</span> <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="variable">@params</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="variable">@params</span><span class="operator">+</span><span class="number">1</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$new_id</span><span class="operator">,</span> <span class="number">99</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>If you have many rows to insert you can take advantage of Oracle's built in execute array feature
with code like this:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">@in_values</span><span class="operator">=(</span><span class="string">'1'</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="string">'3'</span><span class="operator">,</span><span class="string">'4'</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="string">'6'</span><span class="operator">,</span><span class="number">7</span><span class="operator">,</span><span class="string">'8'</span><span class="operator">,</span><span class="number">9</span><span class="operator">,</span><span class="string">'10'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@out_values</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">@status</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">qq{
        INSERT INTO foo (id, bar)
        VALUES (foo_id_seq.nextval, ?)
        RETURNING id INTO ?
  }</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_array</span><span class="operator">(</span><span class="number">1</span><span class="operator">,\</span><span class="variable">@in_values</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout_array</span><span class="operator">(</span><span class="number">2</span><span class="operator">,\</span><span class="variable">@out_values</span><span class="operator">,</span><span class="number">0</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_VARCHAR2</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(</span><span class="operator">{</span><span class="string">ArrayTupleStatus</span><span class="operator">=&gt;\</span><span class="variable">@status</span><span class="operator">}</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"error inserting"</span><span class="operator">;</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$id</span> <span class="operator">(</span><span class="variable">@out_values</span><span class="operator">){</span>
        <span class="keyword">print</span> <span class="string">'returned id='</span><span class="operator">.</span><span class="variable">$id</span><span class="operator">.</span><span class="string">'\n'</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Which will return all the ids into @out_values.</p>
<dl>
<dt><strong><a name="note" class="item"><strong>Note:</strong></a></strong></dt>

<dt><strong><a name="numbered" class="item">This will only work for numbered (?) placeholders,</a></strong></dt>

<dt><strong><a name="the_third_parameter_of_bind_param_inout_array_0_in_the_example_maxlen_is_required_by_dbi_but_not_used_by_dbd_oracle" class="item">The third parameter of bind_param_inout_array, (0 in the example), &quot;maxlen&quot; is required by DBI but not used by DBD::Oracle</a></strong></dt>

<dt><strong><a name="the_ora_type_attribute_is_not_needed_but_only_ora_varchar2_will_work" class="item">The &quot;ora_type&quot; attribute is not needed but only ORA_VARCHAR2 will work.</a></strong></dt>

</dl>
<p>
</p>
<h4><a name="returning_a_recordset">Returning A Recordset</a></h4>
<p>DBD::Oracle does not currently support binding a PL/SQL table (aka array)
as an IN OUT parameter to any Perl data structure.  You cannot therefore call
a PL/SQL function or procedure from DBI that uses a non-atomic datatype as
either a parameter, or a return value.  However, if you are using Oracle 9.0.1
or later, you can make use of table (or pipelined) functions.</p>
<p>For example, assume you have the existing PL/SQL Package :</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">Array_Example</span> <span class="variable">AS</span>
    <span class="operator">--</span>
    <span class="variable">TYPE</span> <span class="variable">tRec</span> <span class="variable">IS</span> <span class="variable">RECORD</span> <span class="operator">(</span>
        <span class="variable">Col1</span>    <span class="variable">NUMBER</span><span class="operator">,</span>
        <span class="variable">Col2</span>    <span class="variable">VARCHAR2</span> <span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
        <span class="variable">Col3</span>    <span class="variable">DATE</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="operator">--</span>
    <span class="variable">TYPE</span> <span class="variable">taRec</span> <span class="variable">IS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">tRec</span> <span class="variable">INDEX</span> <span class="variable">BY</span> <span class="variable">BINARY_INTEGER</span> <span class="operator">;</span>
    <span class="operator">--</span>
    <span class="variable">FUNCTION</span> <span class="variable">Array_Func</span> <span class="variable">RETURN</span> <span class="variable">taRec</span> <span class="operator">;</span>
    <span class="operator">--</span>
  <span class="keyword">END</span> <span class="variable">Array_Example</span> <span class="operator">;</span>
</pre>
<pre>
  CREATE OR REPLACE PACKAGE BODY Array_Example AS
  --
  FUNCTION Array_Func RETURN taRec AS
  --
    l_Ret       taRec ;
  --
  BEGIN
    FOR i IN 1 .. 5 LOOP
        l_Ret (i).Col1 := i ;
        l_Ret (i).Col2 := 'Row : ' || i ;
        l_Ret (i).Col3 := TRUNC (SYSDATE) + i ;
    END LOOP ;
    RETURN l_Ret ;
  END ;
  --
  END Array_Example ;
  /</pre>
<p>Currently, there is no way to directly call the function
Array_Example.Array_Func from DBI.  However, by making the following relatively
painless additions, its not only possible, but extremely efficient.</p>
<p>First, you need to create database object types that correspond to the record
and table types in the package.  From the above example, these would be :</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">tArray_Example__taRec</span>
  <span class="variable">AS</span> <span class="variable">OBJECT</span> <span class="operator">(</span>
      <span class="variable">Col1</span>    <span class="variable">NUMBER</span><span class="operator">,</span>
      <span class="variable">Col2</span>    <span class="variable">VARCHAR2</span> <span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
      <span class="variable">Col3</span>    <span class="variable">DATE</span>
  <span class="operator">)</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">taArray_Example__taRec</span>
  <span class="variable">AS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">tArray_Example__taRec</span> <span class="operator">;</span>
</pre>
<p>Now, assuming the existing function needs to remain unchanged (it is probably
being called from other PL/SQL code), we need to add a new function to the
package.  Here's the new package specification and body :</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">Array_Example</span> <span class="variable">AS</span>
      <span class="operator">--</span>
      <span class="variable">TYPE</span> <span class="variable">tRec</span> <span class="variable">IS</span> <span class="variable">RECORD</span> <span class="operator">(</span>
          <span class="variable">Col1</span>    <span class="variable">NUMBER</span><span class="operator">,</span>
          <span class="variable">Col2</span>    <span class="variable">VARCHAR2</span> <span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
          <span class="variable">Col3</span>    <span class="variable">DATE</span><span class="operator">)</span> <span class="operator">;</span>
      <span class="operator">--</span>
      <span class="variable">TYPE</span> <span class="variable">taRec</span> <span class="variable">IS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">tRec</span> <span class="variable">INDEX</span> <span class="variable">BY</span> <span class="variable">BINARY_INTEGER</span> <span class="operator">;</span>
      <span class="operator">--</span>
      <span class="variable">FUNCTION</span> <span class="variable">Array_Func</span> <span class="variable">RETURN</span> <span class="variable">taRec</span> <span class="operator">;</span>
      <span class="variable">FUNCTION</span> <span class="variable">Array_Func_DBI</span> <span class="variable">RETURN</span> <span class="variable">taArray_Example__taRec</span> <span class="variable">PIPELINED</span> <span class="operator">;</span>
      <span class="operator">--</span>
  <span class="keyword">END</span> <span class="variable">Array_Example</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">BODY</span> <span class="variable">Array_Example</span> <span class="variable">AS</span>
  <span class="operator">--</span>
  <span class="variable">FUNCTION</span> <span class="variable">Array_Func</span> <span class="variable">RETURN</span> <span class="variable">taRec</span> <span class="variable">AS</span>
      <span class="variable">l_Ret</span>  <span class="variable">taRec</span> <span class="operator">;</span>
  <span class="keyword">BEGIN</span>
      <span class="variable">FOR</span> <span class="variable">i</span> <span class="variable">IN</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">5</span> <span class="variable">LOOP</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col1</span> <span class="operator">:=</span> <span class="variable">i</span> <span class="operator">;</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col2</span> <span class="operator">:=</span> <span class="string">'Row : '</span> <span class="operator">||</span> <span class="variable">i</span> <span class="operator">;</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col3</span> <span class="operator">:=</span> <span class="variable">TRUNC</span> <span class="operator">(</span><span class="variable">SYSDATE</span><span class="operator">)</span> <span class="operator">+</span> <span class="variable">i</span> <span class="operator">;</span>
      <span class="keyword">END</span> <span class="variable">LOOP</span> <span class="operator">;</span>
      <span class="variable">RETURN</span> <span class="variable">l_Ret</span> <span class="operator">;</span>
  <span class="keyword">END</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">FUNCTION</span> <span class="variable">Array_Func_DBI</span> <span class="variable">RETURN</span> <span class="variable">taArray_Example__taRec</span> <span class="variable">PIPELINED</span> <span class="variable">AS</span>
      <span class="variable">l_Set</span>  <span class="variable">taRec</span> <span class="operator">;</span>
  <span class="keyword">BEGIN</span>
      <span class="variable">l_Set</span> <span class="operator">:=</span> <span class="variable">Array_Func</span> <span class="operator">;</span>
      <span class="variable">FOR</span> <span class="variable">i</span> <span class="variable">IN</span> <span class="variable">l_Set</span><span class="operator">.</span><span class="variable">FIRST</span> <span class="operator">..</span> <span class="variable">l_Set</span><span class="operator">.</span><span class="variable">LAST</span> <span class="variable">LOOP</span>
          <span class="variable">PIPE</span> <span class="variable">ROW</span> <span class="operator">(</span>
              <span class="variable">tArray_Example__taRec</span> <span class="operator">(</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col1</span><span class="operator">,</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col2</span><span class="operator">,</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col3</span>
              <span class="operator">)</span>
          <span class="operator">)</span> <span class="operator">;</span>
      <span class="keyword">END</span> <span class="variable">LOOP</span> <span class="operator">;</span>
      <span class="variable">RETURN</span> <span class="operator">;</span>
  <span class="keyword">END</span> <span class="operator">;</span>
  <span class="operator">--</span>
  <span class="keyword">END</span> <span class="variable">Array_Example</span> <span class="operator">;</span>
</pre>
<p>As you can see, the new function is very simple.  Now, it is a simple matter
of calling the function as a straight-forward SELECT from your DBI code.  From
the above example, the code would look something like this :</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'SELECT * FROM TABLE(Array_Example.Array_Func_DBI)'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$col1</span><span class="operator">,</span> <span class="variable">$col2</span><span class="operator">,</span> <span class="variable">$col3</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">{</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<h4><a name="sys_dbms_sql_datatypes"><strong>SYS.DBMS_SQL datatypes</strong></a></h4>
<p>DBD::Oracle has built-in support for <strong>SYS.DBMS_SQL.VARCHAR2_TABLE</strong>
and <strong>SYS.DBMS_SQL.NUMBER_TABLE</strong> datatypes. The simple example is here:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$statement</span><span class="operator">=</span><span class="string">'
    DECLARE
        tbl     SYS.DBMS_SQL.VARCHAR2_TABLE;
    BEGIN
        tbl := :mytable;
        :cc := tbl.count();
        tbl(1) := \'def\';
        tbl(2) := \'ijk\';
        :mytable := tbl;
    END;
    '</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">my</span> <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="variable">$statement</span> <span class="operator">);</span>
</pre>
<pre>
    <span class="keyword">my</span> <span class="variable">@arr</span><span class="operator">=(</span> <span class="string">"abc"</span><span class="operator">,</span><span class="string">"efg"</span><span class="operator">,</span><span class="string">"hij"</span> <span class="operator">);</span>
</pre>
<pre>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":mytable"</span><span class="operator">,</span> <span class="operator">\\</span><span class="variable">@arr</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> <span class="operator">{</span>
            <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_VARCHAR2_TABLE</span><span class="operator">,</span>
            <span class="string">ora_maxarray_numentries</span> <span class="operator">=&gt;</span> <span class="number">100</span>
    <span class="operator">}</span> <span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cc"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$cc</span><span class="operator">,</span> <span class="number">100</span>  <span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
    <span class="keyword">print</span>       <span class="string">"Result: cc="</span><span class="operator">,</span><span class="variable">$cc</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">,</span>
        <span class="string">"\tarr="</span><span class="operator">,</span><span class="variable">Data::Dumper::Dumper</span><span class="operator">(\</span><span class="variable">@arr</span><span class="operator">),</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<dl>
<dt><strong><a name="note2" class="item"><strong>Note:</strong></a></strong></dt>

<dt><strong><a name="take_careful_note_that_we_use_arr_here_because_the_bind_param_inout_will_only_take_a_reference_to_a_scalar" class="item">Take careful note that we use '\\@arr' here because  the 'bind_param_inout'
   will only take a reference to a scalar.</a></strong></dt>

</dl>
<p>
</p>
<h4><a name="ora_varchar2_table"><strong>ORA_VARCHAR2_TABLE</strong></a></h4>
<p>SYS.DBMS_SQL.VARCHAR2_TABLE object is always bound to array reference.
( in <code>bind_param()</code> and <code>bind_param_inout()</code> ). When you bind array, you need
to specify full buffer size for OUT data. So, there are two parameters:
<em>max_len</em> (specified as 3rd argument of <code>bind_param_inout()</code> ),
and <em>ora_maxarray_numentries</em>. They define maximum array entry length and
maximum rows, that can be passed to Oracle and back to you. In this
example we send array with 1 element with length=3, but allocate space for 100
Oracle array entries with maximum length 10 of each. So, you can get no more
than 100 array entries with length &lt;= 10.</p>
<p>If you set <em>max_len</em> to zero, maximum array entry length is calculated
as maximum length of entry of array bound. If 0 &lt; <em>max_len</em> &lt; length( $some_element ),
truncation occur.</p>
<p>If you set <em>ora_maxarray_numentries</em> to zero, current (at bind time) bound
array length is used as maximum. If 0 &lt; <em>ora_maxarray_numentries</em> &lt; <a href="../../lib/pods/perlfunc.html#scalar"><code>scalar(@array)</code></a>,
not all array entries are bound.</p>
<p>
</p>
<h4><a name="ora_number_table"><strong>ORA_NUMBER_TABLE</strong></a></h4>
<p>SYS.DBMS_SQL.NUMBER_TABLE object handling is much alike ORA_VARCHAR2_TABLE.
The main difference is internal data representation. Currently 2 types of
bind is allowed : as C-integer, or as C-double type. To select one of them,
you may specify additional bind parameter <em>ora_internal_type</em> as either
<strong>SQLT_INT</strong> or <strong>SQLT_FLT</strong> for C-integer and C-double types.
Integer size is architecture-specific and is usually 32 or 64 bit.
Double is standard IEEE 754 type.</p>
<p><em>ora_internal_type</em> defaults to double (SQLT_FLT).</p>
<p><em>max_len</em> is ignored for OCI_NUMBER_TABLE.</p>
<p>Currently, you cannot bind full native Oracle NUMBER(38). If you really need,
send request to dbi-dev list.</p>
<p>The usage example is here:</p>
<pre>
    <span class="variable">$statement</span><span class="operator">=</span><span class="string">'
    DECLARE
            tbl     SYS.DBMS_SQL.NUMBER_TABLE;
    BEGIN
            tbl := :mytable;
            :cc := tbl(2);
            tbl(4) := -1;
            tbl(5) := -2;
            :mytable := tbl;
    END;
    '</span><span class="operator">;</span>
</pre>
<pre>
    <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="variable">$statement</span> <span class="operator">);</span>
</pre>
<pre>
    <span class="keyword">if</span><span class="operator">(</span> <span class="operator">!</span> <span class="keyword">defined</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">)</span> <span class="operator">){</span>
            <span class="keyword">die</span> <span class="string">"Prepare error: "</span><span class="operator">,</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="variable">@arr</span><span class="operator">=(</span> <span class="number">1</span><span class="operator">,</span><span class="string">"2E0"</span><span class="operator">,</span><span class="string">"3.5"</span> <span class="operator">);</span>
</pre>
<pre>
    <span class="comment"># note, that ora_internal_type defaults to SQLT_FLT for ORA_NUMBER_TABLE .</span>
    <span class="keyword">if</span><span class="operator">(</span> <span class="keyword">not</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":mytable"</span><span class="operator">,</span> <span class="operator">\\</span><span class="variable">@arr</span><span class="operator">,</span> <span class="number">10</span><span class="operator">,</span> <span class="operator">{</span>
                    <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_NUMBER_TABLE</span><span class="operator">,</span>
                    <span class="string">ora_maxarray_numentries</span> <span class="operator">=&gt;</span> <span class="operator">(</span><span class="keyword">scalar</span><span class="operator">(</span><span class="variable">@arr</span><span class="operator">)+</span><span class="number">2</span><span class="operator">),</span>
                    <span class="string">ora_internal_type</span> <span class="operator">=&gt;</span> <span class="variable">SQLT_FLT</span>
              <span class="operator">}</span> <span class="operator">)</span> <span class="operator">){</span>
            <span class="keyword">die</span> <span class="string">"bind :mytable error: "</span><span class="operator">,</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">$cc</span><span class="operator">=</span><span class="keyword">undef</span><span class="operator">;</span>
    <span class="keyword">if</span><span class="operator">(</span> <span class="keyword">not</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cc"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$cc</span><span class="operator">,</span> <span class="number">100</span> <span class="operator">)</span> <span class="operator">){</span>
            <span class="keyword">die</span> <span class="string">"bind :cc error: "</span><span class="operator">,</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="keyword">if</span><span class="operator">(</span> <span class="keyword">not</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">()</span> <span class="operator">){</span>
            <span class="keyword">die</span> <span class="string">"Execute failed: "</span><span class="operator">,</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">print</span>   <span class="string">"Result: cc="</span><span class="operator">,</span><span class="variable">$cc</span><span class="operator">,</span><span class="string">"\n"</span><span class="operator">,</span>
            <span class="string">"\tarr="</span><span class="operator">,</span><span class="variable">Data::Dumper::Dumper</span><span class="operator">(\</span><span class="variable">@arr</span><span class="operator">),</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The result is like:</p>
<pre>
    <span class="variable">Result</span><span class="operator">:</span> <span class="variable">cc</span><span class="operator">=</span><span class="number">2</span>
            <span class="variable">arr</span><span class="operator">=</span><span class="variable">$VAR1</span> <span class="operator">=</span> <span class="operator">[</span>
              <span class="string">'1'</span><span class="operator">,</span>
              <span class="string">'2'</span><span class="operator">,</span>
              <span class="string">'3.5'</span><span class="operator">,</span>
              <span class="string">'-1'</span><span class="operator">,</span>
              <span class="string">'-2'</span>
            <span class="operator">]</span><span class="operator">;</span>
</pre>
<p>If you change bind type to <strong>SQLT_INT</strong>, like:</p>
<pre>
    ora_internal_type =&gt; SQLT_INT</pre>
<p>you get:</p>
<pre>
    <span class="variable">Result</span><span class="operator">:</span> <span class="variable">cc</span><span class="operator">=</span><span class="number">2</span>
            <span class="variable">arr</span><span class="operator">=</span><span class="variable">$VAR1</span> <span class="operator">=</span> <span class="operator">[</span>
              <span class="number">1</span><span class="operator">,</span>
              <span class="number">2</span><span class="operator">,</span>
              <span class="number">3</span><span class="operator">,</span>
              <span class="operator">-</span><span class="number">1</span><span class="operator">,</span>
              <span class="operator">-</span><span class="number">2</span>
            <span class="operator">]</span><span class="operator">;</span>
</pre>
<p>
</p>
<h3><a name="bind_param_inout_array"><strong>bind_param_inout_array</strong></a></h3>
<p>DBD::Oracle supports this undocumented feature of DBI. See <a href="#returning_a_value_from_an_insert">Returning A Value from an INSERT</a> for an example.</p>
<p>
</p>
<h3><a name="bind_param_array"><strong>bind_param_array</strong></a></h3>
<pre>
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, $bind_type)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, \%attr)</pre>
<p>Binds an array of values to a placeholder, so that each is used in turn by a call
to the <a href="#execute_array">execute_array</a> method.</p>
<p>
</p>
<h3><a name="execute"><strong>execute</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">@bind_values</span><span class="operator">);</span>
</pre>
<p>Perform whatever processing is necessary to execute the prepared statement.</p>
<p>
</p>
<h3><a name="execute_array"><strong>execute_array</strong></a></h3>
<pre>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<pre>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</pre>
<p>Execute a prepared statement once for each item in a passed-in hashref, or items that
were previously bound via the <a href="#bind_param_array">bind_param_array</a> method. See the DBI documentation
for more details.</p>
<p>DBD::Oracle takes full advantage of OCI's array interface so inserts and updates using this interface will run very
quickly.</p>
<p>
</p>
<h3><a name="execute_for_fetch"><strong>execute_for_fetch</strong></a></h3>
<pre>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
</pre>
<pre>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
</pre>
<p>Used internally by the <a href="#execute_array">execute_array</a> method, and rarely used directly. See the
DBI documentation for more details.</p>
<p>
</p>
<h3><a name="fetchrow_arrayref"><strong>fetchrow_arrayref</strong></a></h3>
<pre>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_arrayref</span><span class="operator">;</span>
</pre>
<p>Fetches the next row of data from the statement handle, and returns a reference to an array
holding the column values. Any columns that are NULL are returned as undef within the array.</p>
<p>If there are no more rows or if an error occurs, the this method return undef. You should
check <code>$sth-&gt;err</code> afterwards (or use the <a href="#raiseerror">RaiseError</a> attribute) to discover if the undef returned
was due to an error.</p>
<p>Note that the same array reference is returned for each fetch, so don't store the reference and
then use it after a later fetch. Also, the elements of the array are also reused for each row,
so take care if you want to take a reference to an element. See also <a href="#bind_columns">bind_columns</a>.</p>
<p>
</p>
<h3><a name="fetchrow_array"><strong>fetchrow_array</strong></a></h3>
<pre>
  <span class="variable">@ary</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">;</span>
</pre>
<p>Similar to the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method, but returns a list of column information rather than
a reference to a list. Do not use this in a scalar context.</p>
<p>
</p>
<h3><a name="fetchrow_hashref"><strong>fetchrow_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">;</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">);</span>
</pre>
<p>Fetches the next row of data and returns a hashref containing the name of the columns as the keys
and the data itself as the values. Any NULL value is returned as as undef value.</p>
<p>If there are no more rows or if an error occurs, the this method return undef. You should
check <code>$sth-&gt;err</code> afterwards (or use the <a href="#raiseerror">RaiseError</a> attribute) to discover if the undef returned
was due to an error.</p>
<p>The optional <code>$name</code> argument should be either <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a>, <code>NAME_lc</code> or <code>NAME_uc</code>, and indicates
what sort of transformation to make to the keys in the hash. By default Oracle uses upper case.</p>
<p>
</p>
<h3><a name="fetchall_arrayref"><strong>fetchall_arrayref</strong></a></h3>
<pre>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">();</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span> <span class="operator">);</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span><span class="operator">,</span> <span class="variable">$max_rows</span> <span class="operator">);</span>
</pre>
<p>Returns a reference to an array of arrays that contains all the remaining rows to be fetched from the
statement handle. If there are no more rows, an empty arrayref will be returned. If an error occurs,
the data read in so far will be returned. Because of this, you should always check <code>$sth-&gt;err</code> after
calling this method, unless <a href="#raiseerror">RaiseError</a> has been enabled.</p>
<p>If <code>$slice</code> is an array reference, fetchall_arrayref uses the <a href="#fetchrow_arrayref">fetchrow_arrayref</a> method to fetch each
row as an array ref. If the <code>$slice</code> array is not empty then it is used as a slice to select individual
columns by perl array index number (starting at 0, unlike column and parameter numbers which start at 1).</p>
<p>With no parameters, or if $slice is undefined, fetchall_arrayref acts as if passed an empty array ref.</p>
<p>If <code>$slice</code> is a hash reference, fetchall_arrayref uses <a href="#fetchrow_hashref">fetchrow_hashref</a> to fetch each row as a hash reference.</p>
<p>See the DBI documentation for a complete discussion.</p>
<p>
</p>
<h3><a name="fetchall_hashref"><strong>fetchall_hashref</strong></a></h3>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_hashref</span><span class="operator">(</span> <span class="variable">$key_field</span> <span class="operator">);</span>
</pre>
<p>Returns a hashref containing all rows to be fetched from the statement handle. See the DBI documentation for
a full discussion.</p>
<p>
</p>
<h3><a name="finish"><strong>finish</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">;</span>
</pre>
<p>Indicates to DBI that you are finished with the statement handle and are not going to use it again. Only needed
when you have not fetched all the possible rows.</p>
<p>
</p>
<h3><a name="rows"><strong>rows</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">;</span>
</pre>
<p>Returns the number of rows affected for updates, deletes and inserts and -1 for selects.</p>
<p>
</p>
<h3><a name="bind_col"><strong>bind_col</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="variable">$bind_type</span> <span class="operator">);</span>
</pre>
<p>Binds a Perl variable and/or some attributes to an output column of a SELECT statement.
Column numbers count up from 1. You do not need to bind output columns in order to fetch data.</p>
<p>See the DBI documentation for a discussion of the optional parameters <code>\%attr</code> and <code>$bind_type</code></p>
<p>
</p>
<h3><a name="bind_columns"><strong>bind_columns</strong></a></h3>
<pre>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_columns</span><span class="operator">(</span><span class="variable">@list_of_refs_to_vars_to_bind</span><span class="operator">);</span>
</pre>
<p>Calls the <a href="#bind_col">bind_col</a> method for each column in the SELECT statement, using the supplied list.</p>
<p>
</p>
<h3><a name="dump_results"><strong>dump_results</strong></a></h3>
<pre>
  <span class="variable">$rows</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">dump_results</span><span class="operator">(</span><span class="variable">$maxlen</span><span class="operator">,</span> <span class="variable">$lsep</span><span class="operator">,</span> <span class="variable">$fsep</span><span class="operator">,</span> <span class="variable">$fh</span><span class="operator">);</span>
</pre>
<p>Fetches all the rows from the statement handle, calls <code>DBI::neat_list</code> for each row, and
prints the results to <code>$fh</code> (which defaults to <em class="file">STDOUT</em>). Rows are separated by <code>$lsep</code> (which defaults
to a newline). Columns are separated by <code>$fsep</code> (which defaults to a comma). The <code>$maxlen</code> controls
how wide the output can be, and defaults to 35.</p>
<p>This method is designed as a handy utility for prototyping and testing queries. Since it uses
&quot;neat_list&quot; to format and edit the string for reading by humans, it is not recommended
for data transfer applications.</p>
<p>
</p>
<h2><a name="private_statement_handle_methods">Private Statement Handle Methods</a></h2>
<p>
</p>
<h3><a name="ora_stmt_type"><strong>ora_stmt_type</strong></a></h3>
<p>Returns the OCI Statement Type number for the SQL of a statement handle.</p>
<p>
</p>
<h3><a name="ora_stmt_type_name"><strong>ora_stmt_type_name</strong></a></h3>
<p>Returns the OCI Statement Type name for the SQL of a statement handle.</p>
<p>
</p>
<h2><a name="statement_handle_attributes">Statement Handle Attributes</a></h2>
<p>
</p>
<h3><a name="num_of_fields__integer__read_only_"><strong>NUM_OF_FIELDS</strong> (integer, read-only)</a></h3>
<p>Returns the number of columns returned by the current statement. A number will only be returned for
SELECT statements for INSERT,
UPDATE, and DELETE statements which contain a RETURNING clause.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="num_of_params__integer__read_only_"><strong>NUM_OF_PARAMS</strong> (integer, read-only)</a></h3>
<p>Returns the number of placeholders in the current statement.</p>
<p>
</p>
<h3><a name="name__arrayref__read_only_"><strong>NAME</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of column names for the current statement. This
method will only work for SELECT statements, for SHOW statements, and for
INSERT, UPDATE, and DELETE statements which contain a RETURNING clause.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="name_lc__arrayref__read_only_"><strong>NAME_lc</strong> (arrayref, read-only)</a></h3>
<p>The same as the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="name_uc__arrayref__read_only_"><strong>NAME_uc</strong>  (arrayref, read-only)</a></h3>
<p>The same as the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, except that all column names are forced to upper case.</p>
<p>
</p>
<h3><a name="name_hash__hashref__read_only_"><strong>NAME_hash</strong> (hashref, read-only)</a></h3>
<p>Similar to the <a href="../../lib/pods/perlfunc.html#name"><code>NAME</code></a> attribute, but returns a hashref of column names instead of an arrayref. The names of the columns
are the keys of the hash, and the values represent the order in which the columns are returned, starting at 0.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="name_lc_hash__hashref__read_only_"><strong>NAME_lc_hash</strong> (hashref, read-only)</a></h3>
<p>The same as the <code>NAME_hash</code> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="name_uc_hash__hashref__read_only_"><strong>NAME_uc_hash</strong> (hashref, read-only)</a></h3>
<p>The same as the <code>NAME_hash</code> attribute, except that all column names are forced to lower case.</p>
<p>
</p>
<h3><a name="type__arrayref__read_only_"><strong>TYPE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref indicating the data type for each column in the statement.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="precision__arrayref__read_only_"><strong>PRECISION</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement.
The number indicates the precision for <code>NUMERIC</code> columns, the size in number of
characters for <code>CHAR</code> and <code>VARCHAR</code> columns, and for all other types of columns
it returns the number of <em>bytes</em>.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="scale__arrayref__read_only_"><strong>SCALE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement. The number
indicates the scale of the that column. The only type that will return a value is <code>NUMERIC</code>.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="nullable__arrayref__read_only_"><strong>NULLABLE</strong> (arrayref, read-only)</a></h3>
<p>Returns an arrayref of integer values for each column returned by the statement. The number
indicates if the column is nullable or not. 0 = not nullable, 1 = nullable, 2 = unknown.
This method returns undef if called before <code>execute()</code>.</p>
<p>
</p>
<h3><a name="database__dbh__read_only_"><strong>Database</strong> (dbh, read-only)</a></h3>
<p>Returns the database handle this statement handle was created from.</p>
<p>
</p>
<h3><a name="paramvalues__hash_ref__read_only_"><strong>ParamValues</strong> (hash ref, read-only)</a></h3>
<p>Returns a reference to a hash containing the values currently bound to placeholders. If the &quot;named parameters&quot;
type of placeholders are being used (such as &quot;:foo&quot;), then the keys of the hash will be the names of the
placeholders (without the colon). If the &quot;dollar sign numbers&quot; type of placeholders are being used, the keys of the hash will
be the numbers, without the dollar signs. If the &quot;question mark&quot; type is used, integer numbers will be returned,
starting at one and increasing for every placeholder.</p>
<p>If this method is called before <a href="#execute">execute</a>, the literal values passed in are returned. If called after
<a href="#execute">execute</a>, then the quoted versions of the values are returned.</p>
<p>
</p>
<h3><a name="paramtypes__hash_ref__read_only_"><strong>ParamTypes</strong> (hash ref, read-only)</a></h3>
<p>Returns a reference to a hash containing the type names currently bound to placeholders. The keys
are the same as returned by the ParamValues method. The values are hashrefs containing a single key value
pair, in which the key is either 'TYPE' if the type has a generic SQL equivalent, and 'pg_type' if the type can
only be expressed by a Postgres type. The value is the internal number corresponding to the type originally
passed in. (Placeholders that have not yet been bound will return undef as the value). This allows the output of
ParamTypes to be passed back to the <a href="#bind_param">bind_param</a> method.</p>
<p>
</p>
<h3><a name="statement__string__read_only_"><strong>Statement</strong> (string, read-only)</a></h3>
<p>Returns the statement string passed to the most recent &quot;prepare&quot; method called in this database handle, even if that method
failed. This is especially useful where &quot;RaiseError&quot; is enabled and the exception handler checks $@ and sees that a <code>prepare</code>
method call failed.</p>
<p>
</p>
<h3><a name="rowsincache"><strong>RowsInCache</strong></a></h3>
<p>Returns the number of un-fetched rows in the cache for selects.</p>
<p>
</p>
<h2><a name="scrollable_cursors">Scrollable Cursors</a></h2>
<p>Oracle supports the concept of a 'Scrollable Cursor' which is defined as a 'Result Set' where
the rows can be fetched either sequentially or non-sequentially. One can fetch rows forward,
backwards, from any given position or the n-th row from the current position in the result set.</p>
<p>Rows are numbered sequentially starting at one and client-side caching of the partial or entire result set
can improve performance by limiting round trips to the server.</p>
<p>Oracle does not support DML type operations with scrollable cursors so you are limited
to simple 'Select' operations only. As well you can not use this functionality with remote
mapped queries or if the LONG datatype is part of the select list.</p>
<p>However, LOBSs, CLOBSs, and BLOBs do work as do all the regular bind, and fetch methods.</p>
<p>Only use scrollable cursors if you really have a good reason to. They do use up considerable
more server and client resources and have poorer response times than non-scrolling cursors.</p>
<p>
</p>
<h3><a name="enabling_scrollable_cursors"><strong>Enabling Scrollable Cursors</strong></a></h3>
<p>To enable this functionality you must first import the 'Fetch Orientation' and the 'Execution Mode' constants by using;</p>
<pre>
   <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_fetch_orient :ora_exe_modes)</span><span class="operator">;</span>
</pre>
<p>Next you will have to tell DBD::Oracle that you will be using scrolling by setting the ora_exe_mode attribute on the
statement handle to 'OCI_STMT_SCROLLABLE_READONLY' with the prepare method;</p>
<pre>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_exe_mode</span><span class="operator">=&gt;</span><span class="variable">OCI_STMT_SCROLLABLE_READONLY</span><span class="operator">}</span><span class="operator">);</span>
</pre>
<p>When the statement is executed you will then be able to use 'ora_fetch_scroll' method to get a row
or you can still use any of the other fetch methods but with a poorer response time than if you used a
non-scrolling cursor. As well scrollable cursors are compatible with any applicable bind methods.</p>
<p>
</p>
<h3><a name="scrollable_cursor_methods"><strong>Scrollable Cursor Methods</strong></a></h3>
<p>The following driver-specific methods are used with scrollable cursors.</p>
<dl>
<dt><strong><a name="ora_scroll_position" class="item">ora_scroll_position</a></strong></dt>

<dd>
<pre>
  <span class="variable">$position</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">();</span>
</pre>
<p>This method returns the current position (row number) attribute of the result set. Prior to the first fetch this value is 0. This is the only time
this value will be 0 after the first fetch the value will be set, so you can use this value to test if any rows have been fetched.
The minimum value will always be 1 after the first fetch. The maximum value will always be the total number of rows in the record set.</p>
</dd>
<dt><strong><a name="ora_fetch_scroll" class="item">ora_fetch_scroll</a></strong></dt>

<dd>
<pre>
  <span class="variable">@ary</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">$fetch_orient</span><span class="operator">,</span><span class="variable">$fetch_offset</span><span class="operator">);</span>
</pre>
<p>Works the same as fetchrow_array method however, one passes in a 'Fetch Orientation' constant and a fetch_offset
value which will then determine the row that will be fetched. It returns the row as a list containing the field values.
Null fields are returned as undef values in the list.</p>
<p>The valid orientation constant and fetch offset values combination are detailed below</p>
<pre>
  OCI_FETCH_CURRENT,  fetches the current row, the fetch offset value is ignored.
  OCI_FETCH_NEXT,     fetches the next row from the current position, the fetch offset value
                      is ignored.
  OCI_FETCH_FIRST,    fetches the first row, the fetch offset value is ignored.
  OCI_FETCH_LAST,     fetches the last row, the fetch offset value is ignored.
  OCI_FETCH_PRIOR,    fetches the previous row from the current position, the fetch offset
                      value is ignored.
  OCI_FETCH_ABSOLUTE, fetches the row that is specified by the fetch offset value.
  OCI_FETCH_RELATIVE, fetches the row relative from the current position as specified by the
                      fetch offset value.</pre>
<pre>
  OCI_FETCH_ABSOLUTE, and a fetch offset value of 1 is equivalent to a OCI_FETCH_FIRST.
  OCI_FETCH_ABSOLUTE, and a fetch offset value of 0 is equivalent to a OCI_FETCH_CURRENT.</pre>
<pre>
  OCI_FETCH_RELATIVE, and a fetch offset value of 0 is equivalent to a OCI_FETCH_CURRENT.
  OCI_FETCH_RELATIVE, and a fetch offset value of 1 is equivalent to a OCI_FETCH_NEXT.
  OCI_FETCH_RELATIVE, and a fetch offset value of -1 is equivalent to a OCI_FETCH_PRIOR.</pre>
<p>The effect that a ora_fetch_scroll method call has on the current_positon attribute is detailed below.</p>
<pre>
  OCI_FETCH_CURRENT, has no effect on the current_positon attribute.
  OCI_FETCH_NEXT,    increments current_positon attribute by 1
  OCI_FETCH_NEXT,    when at the last row in the record set does not change current_positon
                     attribute, it is equivalent to a OCI_FETCH_CURRENT
  OCI_FETCH_FIRST,   sets the current_positon attribute to 1.
  OCI_FETCH_LAST,    sets the current_positon attribute to the total number of rows in the
                     record set.
  OCI_FETCH_PRIOR,   decrements current_positon attribute by 1.
  OCI_FETCH_PRIOR,   when at the first row in the record set does not change current_positon
                     attribute, it is equivalent to a OCI_FETCH_CURRENT.</pre>
<pre>
  OCI_FETCH_ABSOLUTE, sets the current_positon attribute to the fetch offset value.
  OCI_FETCH_ABSOLUTE, and a fetch offset value that is less than 1 does not change
                      current_positon attribute, it is equivalent to a OCI_FETCH_CURRENT.
  OCI_FETCH_ABSOLUTE, and a fetch offset value that is greater than the number of records in
                      the record set, does not change current_positon attribute, it is
                      equivalent to a OCI_FETCH_CURRENT.
  OCI_FETCH_RELATIVE, sets the current_positon attribute to (current_positon attribute +
                      fetch offset value).
  OCI_FETCH_RELATIVE, and a fetch offset value that makes the current position less than 1,
                      does not change fetch offset value so it is equivalent to a OCI_FETCH_CURRENT.
  OCI_FETCH_RELATIVE, and a fetch offset value that makes it greater than the number of records
                      in the record set, does not change fetch offset value so it is equivalent
                      to a OCI_FETCH_CURRENT.</pre>
<p>The effects of the differing orientation constants on the first fetch (current_postion attribute at 0) are as follows.</p>
<pre>
  OCI_FETCH_CURRENT, dose not fetch a row or change the current_positon attribute.
  OCI_FETCH_FIRST,   fetches row 1 and sets the current_positon attribute to 1.
  OCI_FETCH_LAST,    fetches the last row in the record set and sets the current_positon
                     attribute to the total number of rows in the record set.
  OCI_FETCH_NEXT,    equivalent to a OCI_FETCH_FIRST.
  OCI_FETCH_PRIOR,   equivalent to a OCI_FETCH_CURRENT.</pre>
<pre>
  OCI_FETCH_ABSOLUTE, and a fetch offset value that is less than 1 is equivalent to a
                      OCI_FETCH_CURRENT.
  OCI_FETCH_ABSOLUTE, and a fetch offset value that is greater than the number of
                      records in the record set is equivalent to a OCI_FETCH_CURRENT.
  OCI_FETCH_RELATIVE, and a fetch offset value that is less than 1 is equivalent
                      to a OCI_FETCH_CURRENT.
  OCI_FETCH_RELATIVE, and a fetch offset value that makes it greater than the number
                      of records in the record set, is equivalent to a OCI_FETCH_CURRENT.</pre>
</dd>
</dl>
<p>
</p>
<h3><a name="scrollable_cursor_usage"><strong>Scrollable Cursor Usage</strong></a></h3>
<p>Given a simple code like this:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types :ora_fetch_orient :ora_exe_modes)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$dbuser</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"select id,
                     first_name,
                     last_name
                from employee"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_exe_mode</span><span class="operator">=&gt;</span><span class="variable">OCI_STMT_SCROLLABLE_READONLY</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">my</span> <span class="variable">$value</span><span class="operator">;</span>
</pre>
<p>and one assumes that the number of rows returned from the query is 20, the code snippets below will illustrate the use of ora_fetch_scroll
method;</p>
<dl>
<dt><strong><a name="fetching_the_last_row" class="item">Fetching the Last Row</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_LAST</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute to will be 20 after this snippet.  This is also a way to get the number of rows in the record set, however,
if the record set is large this could take some time.</p>
</dd>
<dt><strong><a name="fetching_the_current_row" class="item">Fetching the Current Row</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_CURRENT</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will still be 20 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_first_row" class="item">Fetching the First Row</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_FIRST</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 1 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_next_row" class="item">Fetching the Next Row</a></strong></dt>

<dd>
<pre>
  <span class="keyword">for</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">&lt;=</span><span class="number">3</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">++){</span>
     <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_NEXT</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
     <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 5 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_prior_row" class="item">Fetching the Prior Row</a></strong></dt>

<dd>
<pre>
  <span class="keyword">for</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">&lt;=</span><span class="number">3</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">++){</span>
     <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_PRIOR</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
     <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 1 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_10th_row" class="item">Fetching the 10th Row</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_ABSOLUTE</span><span class="operator">,</span><span class="number">10</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 10 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_10th_to_14th_row" class="item">Fetching the 10th to 14th Row</a></strong></dt>

<dd>
<pre>
  <span class="keyword">for</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span><span class="operator">=</span><span class="number">10</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">&lt;</span><span class="number">15</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">++){</span>
      <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_ABSOLUTE</span><span class="operator">,</span><span class="variable">$i</span><span class="operator">);</span>
      <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 14 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_14th_to_10th_row" class="item">Fetching the 14th to 10th Row</a></strong></dt>

<dd>
<pre>
  <span class="keyword">for</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span><span class="operator">=</span><span class="number">14</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">&gt;</span><span class="number">9</span><span class="operator">;</span><span class="variable">$i</span><span class="operator">--){</span>
    <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_ABSOLUTE</span><span class="operator">,</span><span class="variable">$i</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 10 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_5th_row_from_the_present_position" class="item">Fetching the 5th Row From the Present Position.</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_RELATIVE</span><span class="operator">,</span><span class="number">5</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 15 after this snippet.</p>
</dd>
<dt><strong><a name="fetching_the_9th_row_prior_from_the_present_position" class="item">Fetching the 9th Row Prior From the Present Position</a></strong></dt>

<dd>
<pre>
  <span class="variable">$value</span> <span class="operator">=</span>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_fetch_scroll</span><span class="operator">(</span><span class="variable">OCI_FETCH_RELATIVE</span><span class="operator">,-</span><span class="number">9</span><span class="operator">);</span>
  <span class="keyword">print</span> <span class="string">"id="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">.</span><span class="string">", First Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">.</span><span class="string">", Last Name="</span><span class="operator">.</span><span class="variable">$value</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"current scroll position="</span><span class="operator">.</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">ora_scroll_position</span><span class="operator">().</span><span class="string">"\n"</span><span class="operator">;</span>
</pre>
<p>The current_positon attribute will be 6 after this snippet.</p>
</dd>
<dt><strong><a name="use_finish" class="item">Use Finish</a></strong></dt>

<dd>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">();</span>
</pre>
<p>When using scrollable cursors it is required that you use the $sth-&gt;<code>finish()</code> method when you are done with the cursor as this type of
cursor has to be explicitly cancelled on the server. If you do not do this you may cause resource problems on your database.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="lobs_and_longs">LOBs and LONGs</a></h2>
<p>The key to working with LOBs (CLOB, BLOBs) is to remember the value of an Oracle LOB column is not the content of the LOB. It's a
'LOB Locator' which, after being selected or inserted needs extra processing to read or write the content of the LOB. There are also legacy LONG types (LONG, LONG RAW, VARCHAR2)
which are presently deprecated by Oracle but are still in use.  These LONG types do not utilize a 'LOB Locator' and also are more limited in
functionality than CLOB or BLOB fields.</p>
<p>DBD::Oracle now offers three interfaces to LOB and LONG data,</p>
<dl>
<dt><strong><a name="data_interface_for_persistent_lobs" class="item"><a href="#data_interface_for_persistent_lobs">Data Interface for Persistent LOBs</a></a></strong></dt>

<dd>
<p>With this interface DBD::Oracle handles your data directly utilizing regular OCI calls, Oracle itself takes care of the LOB Locator operations in the case of
BLOBs and CLOBs treating them exactly as if they were the same as the legacy LONG or LONG RAW types.</p>
</dd>
<dt><strong><a name="data_interface_for_lob_locators" class="item"><a href="#data_interface_for_lob_locators">Data Interface for LOB Locators</a></a></strong></dt>

<dd>
<p>With this interface DBD::Oracle handles your data utilizing LOB Locator OCI calls so it only works with CLOB and BLOB datatypes. With this interface DBD::Oracle takes care of the LOB Locator operations for you.</p>
</dd>
<dt><strong><a name="lob_locator_method_interface" class="item"><a href="#lob_locator_method_interface">LOB Locator Method Interface</a></a></strong></dt>

<dd>
<p>This allows the user direct access to the LOB Locator methods, so you have to take case of the LOB Locator operations yourself.</p>
</dd>
</dl>
<p>Generally speaking the interface that you will chose will be dependent on what end you are trying to achieve. All have their benefits and
drawbacks.</p>
<p>One point to remember when working with LOBs (CLOBs, BLOBs) is if your LOB column can be in one of three states;</p>
<dl>
<dt><strong><a name="null" class="item">NULL</a></strong></dt>

<dd>
<p>The table cell is created, but the cell holds no locator or value.
If your LOB field is in this state then there is no LOB Locator that DBD::Oracle can work so if your encounter a</p>
<pre>
  DBD::Oracle::db::ora_lob_read: locator is not of type OCILobLocatorPtr</pre>
<p>error when working with a LOB.</p>
<p>You can correct this by using an SQL UPDATE statement to reset the LOB column to a non-NULL (or empty LOB) value with either EMPTY_BLOB or EMPTY_CLOB as in this example;</p>
<pre>
  UPDATE lob_example
     SET bindata=EMPTY_BLOB()
   WHERE bindata IS NULL.</pre>
</dd>
<dt><strong><a name="empty" class="item">Empty</a></strong></dt>

<dd>
<p>A LOB instance with a locator exists in the cell, but it has no value. The length of the LOB is zero. In this case DBD::Oracle will return 'undef' for the field.</p>
</dd>
<dt><strong><a name="populated" class="item">Populated</a></strong></dt>

<dd>
<p>A LOB instance with a locator and a value exists in the cell. You actually get the LOB value.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="data_interface_for_persistent_lobs"><strong>Data Interface for Persistent LOBs</strong></a></h3>
<p>This is the original interface for LONG and LONG RAW datatypes and from Oracle 9iR1 and later the OCI API was extended to work directly with the other LOB datatypes.
In other words you can treat all LOB type data (BLOB, CLOB) as if it was a LONG, LONG RAW, or VARCHAR2. So you can perform INSERT, UPDATE, fetch, bind, and define operations on LOBs using the same techniques
you would use on other datatypes that store character or binary data. In some cases there are fewer round trips to the server as no 'LOB Locators' are
used, normally one can get an entire LOB is a single round trip.</p>
<p>
</p>
<h4><a name="simple_fetch_for_longs_and_long_raws">Simple Fetch for LONGs and LONG RAWs</a></h4>
<p>As the name implies this is the simplest way to use this interface. DBD::Oracle just attempts to get your LONG datatypes as a single large piece.
There are no special settings, simply set the database handle's 'LongReadLen' attribute to a value that will be the larger than the expected size of the LONG or LONG RAW.
If the size of the LONG or LONG RAW exceeds  the 'LongReadLen' DBD::Oracle will return a 'ORA-24345: A Truncation' error.  To stop this set the database handle's 'LongTruncOk' attribute to '1'.
The maximum value of 'LongReadLen' seems to be dependent on the physical memory limits of the box that Oracle is running on.  You have most likely reached this limit if you run into
an 'ORA-01062: unable to allocate memory for define buffer' error.  One solution is to set the size of 'LongReadLen' to a lower value.</p>
<p>For example give this table;</p>
<pre>
  CREATE TABLE test_long (
            id NUMBER,
            long1 long)</pre>
<p>this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#2 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,long1 from test_long'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$long</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"long="</span><span class="operator">.</span><span class="variable">$long</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select out all of the long1 fields in the table as long as they are all under 2MB in length. A value in long1 longer than this will throw an error. Adding this line;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongTruncOk</span><span class="operator">}</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span>
</pre>
<p>before the execute will return all the long1 fields but they will be truncated at 2MBs.</p>
<p>
</p>
<h4><a name="using_ora_ncs_buff_mtpl">Using ora_ncs_buff_mtpl</a></h4>
<p>When getting CLOBs and NCLOBs in or out of Oracle, the Server will translate from the Server's NCharSet to the
Client's. If they happen to be the same or at least compatible then all of these actions are a 1 char to 1 char bases.
Thus if you set your LongReadLen buffer to 10_000_000 you will get up to 10_000_000 char.</p>
<p>However if the Server has to translate from one NCharSet to another it will use bytes for conversion. The buffer
value is set to 4 * LONG_READ_LEN which was very wasteful as you might only be asking for 10_000_000 bytes
but you were actually using 40_000_000 bytes of buffer under the hood.  You would still get 10_000_000 bytes
(maybe less characters though) but you are using allot more memory that you need.</p>
<p>You can now customize the size of the buffer by setting the 'ora_ncs_buff_mtpl' either on the connection or statement handle. You can
also set this as 'ORA_DBD_NCS_BUFFER' OS environment variable so you will have to go back and change all your code if you are getting into trouble.</p>
<p>The default value is still set to 4 for backward compatibility. You can lower this value and thus increase the amount of data you can retrieve. If the
ora_ncs_buff_mtpl is too small DBD::Oracle will throw and error telling you to increase this buffer by one.</p>
<p>If the error is not captured then you may get at some random point later on, usually at a <code>finish()</code> or <code>disconnect()</code> or even a <code>fetch()</code> this error;</p>
<pre>
  ORA-03127: no new operations allowed until the active operation ends</pre>
<p>This is one of the more obscure ORA errors (have some fun and report it to Meta-Link they will scratch their heads for hours)</p>
<p>If you get this, simply increment the ora_ncs_buff_mtpl by one until it goes away.</p>
<p>This should greatly increase your ability to select very large CLOBs or NCLOBs, by freeing up a large block of memory.</p>
<p>You can tune this value by setting ora_oci_success_warn which will display the following</p>
<pre>
  OCILobRead field 2 of 3 SUCCESS: csform 1 (SQLCS_IMPLICIT), LOBlen 10240(characters), LongReadLen
  20(characters), BufLen 80(characters), Got 28(characters)</pre>
<p>In the case above the query Got 28 characters (well really only 20 characters of 28 bytes) so we could use ora_ncs_buff_mtpl=&gt;2 (20*2=40) thus saving 40bytes of memory.</p>
<p>
</p>
<h4><a name="simple_fetch_for_clobs_and_blobs">Simple Fetch for CLOBs and BLOBs</a></h4>
<p>To use this interface for CLOBs and LOBs datatypes set the 'ora_pers_lob' attribute of the statement handle to '1' with the prepare method, as well
set the database handle's 'LongReadLen' attribute to a value that will be the larger than the expected size of the LOB. If the size of the LOB exceeds
the 'LongReadLen' DBD::Oracle will return a 'ORA-24345: A Truncation' error.  To stop this set the database handle's 'LongTruncOk' attribute to '1'.
The maximum value of 'LongReadLen' seems to be dependent on the physical memory limits of the box that Oracle is running on in the same way that LONGs and LONG RAWs are.</p>
<p>For CLOBs and NCLOBs the limit is 64k chars if there is no truncation, this is an internal OCI limit complain to them if you want it changed.  However if you CLOB is longer than this
and also larger than the 'LongReadLen' than the 'LongReadLen' in chars is returned.</p>
<p>It seems with BLOBs you are not limited by the 64k.</p>
<p>For example give this table;</p>
<pre>
  CREATE TABLE test_lob (id NUMBER,
               clob1 CLOB,
               clob2 CLOB,
               blob1 BLOB,
               blob2 BLOB)</pre>
<p>this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#2 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,lob_1,lob_2,blob_2 from test_lobs'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_pers_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$log</span><span class="operator">,</span><span class="variable">$log2</span><span class="operator">,</span><span class="variable">$log3</span><span class="operator">,</span><span class="variable">$log4</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob1="</span><span class="operator">.</span><span class="variable">$clob1</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob2="</span><span class="operator">.</span><span class="variable">$clob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob1="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob2="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select out all of the LOBs in the table as long as they are all under 2MB in length. Longer lobs will throw an error. Adding this line;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongTruncOk</span><span class="operator">}</span><span class="operator">=</span><span class="number">1</span><span class="operator">;</span>
</pre>
<p>before the execute will return all the lobs but they will be truncated at 2MBs.</p>
<p>
</p>
<h4><a name="piecewise_fetch_with_callback">Piecewise Fetch with Callback</a></h4>
<p>With a piecewise callback fetch DBD::Oracle sets up a function that will 'callback' to the DB during the fetch and gets your LOB (LONG, LONG RAW, CLOB, BLOB) piece by piece.
To use this interface set the 'ora_clbk_lob' attribute of the statement handle to '1' with the prepare method. Next set the 'ora_piece_size' to the size of the piece that
you want to return on the callback. Finally set the database handle's 'LongReadLen' attribute to a value that will be the larger than the expected
size of the LOB. Like the <a href="#simple_fetch_for_longs_and_long_raws">Simple Fetch for LONGs and LONG RAWs</a> and <a href="#simple_fetch_for_clobs_and_blobs">Simple Fetch for CLOBs and BLOBs</a> the if the size of the LOB exceeds the is 'LongReadLen' you can use the 'LongTruncOk' attribute to truncate the LOB
or set the 'LongReadLen' to a higher value.  With this interface the value of 'ora_piece_size' seems to be constrained by the same memory limit as found on
the Simple Fetch interface. If you encounter an 'ORA-01062' error try setting the value of 'ora_piece_size' to a smaller value.   The value for 'LongReadLen' is
dependent on the version and settings of the Oracle DB you are using. In theory it ranges from 8GBs
in 9iR1 up to 128 terabytes with 11g but you will also be limited by the physical memory of your PERL instance.</p>
<p>Using the table from the last example this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">20</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#20 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,lob_1,lob_2,blob_2 from test_lobs'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_clbk_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">ora_piece_size</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$log</span><span class="operator">,</span><span class="variable">$log2</span><span class="operator">,</span><span class="variable">$log3</span><span class="operator">,</span><span class="variable">$log4</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob1="</span><span class="operator">.</span><span class="variable">$clob1</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob2="</span><span class="operator">.</span><span class="variable">$clob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob1="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob2="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select out all of the LOBs in the table as long as they are all under 20MB in length. If the LOB is longer than 5MB (ora_piece_size) DBD::Oracle will fetch it in at least 2 pieces to a
maximum of 4 pieces (4*5MB=20MB). Like the Simple Fetch examples Lobs longer than 20MB will throw an error.</p>
<p>Using the table from the first example (LONG) this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">20</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#2 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,long1 from test_long'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_clbk_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">ora_piece_size</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$long</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"long="</span><span class="operator">.</span><span class="variable">$long</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select all of the long1 fields from table as long as they are is under 20MB in length. If the long1 filed is longer than 5MB (ora_piece_size) DBD::Oracle will fetch it in at least 2 pieces to a
maximum of 4 pieces (4*5MB=20MB). Like the other examples long1 fields longer than 20MB will throw an error.</p>
<p>
</p>
<h4><a name="piecewise_fetch_with_polling">Piecewise Fetch with Polling</a></h4>
<p>With a polling piecewise fetch DBD::Oracle iterates (Polls) over the LOB during the fetch getting your LOB (LONG, LONG RAW, CLOB, BLOB) piece by piece. To use this interface set the 'ora_piece_lob'
attribute of the statement handle to '1' with the prepare method. Next set the 'ora_piece_size' to the size of the piece that
you want to return on the callback. Finally set the database handle's 'LongReadLen' attribute to a value that will be the larger than the expected
size of the LOB. Like the <a href="#piecewise_fetch_with_callback">Piecewise Fetch with Callback</a> and Simple Fetches if the size of the LOB exceeds the is 'LongReadLen' you can use the 'LongTruncOk' attribute to truncate the LOB
or set the 'LongReadLen' to a higher value.  With this interface the value of 'ora_piece_size' seems to be constrained by the same memory limit as found on
the <a href="#piecewise_fetch_with_callback">Piecewise Fetch with Callback</a>.</p>
<p>Using the table from the example above this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">20</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#20 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,lob_1,lob_2,blob_2 from test_lobs'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_piece_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">ora_piece_size</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$log</span><span class="operator">,</span><span class="variable">$log2</span><span class="operator">,</span><span class="variable">$log3</span><span class="operator">,</span><span class="variable">$log4</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob1="</span><span class="operator">.</span><span class="variable">$clob1</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"clob2="</span><span class="operator">.</span><span class="variable">$clob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob1="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"blob2="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select out all of the LOBs in the table as long as they are all under 20MB in length. If the LOB is longer than 5MB (ora_piece_size) DBD::Oracle will fetch it in at least 2 pieces to a
maximum of 4 pieces (4*5MB=20MB). Like the other fetch methods LOBs longer than 20MB will throw an error.</p>
<p>Finally with this code;</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">20</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#2 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,long1 from test_long'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_piece_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span><span class="string">ora_piece_size</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$long</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
    <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"long="</span><span class="operator">.</span><span class="variable">$long</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Will select all of the long1 fields from table as long as they are is under 20MB in length. If the long1 field is longer than 5MB (ora_piece_size) DBD::Oracle will fetch it in at least 2 pieces to a
maximum of 4 pieces (4*5MB=20MB). Like the other examples long1 fields longer than 20MB will throw an error.</p>
<p>
</p>
<h4><a name="binding_for_updates_and_inserts_for_clobs_and_blobs">Binding for Updates and Inserts for CLOBs and  BLOBs</a></h4>
<p>To bind for updates and inserts all that is required to use this interface is to set the statement handle's prepare method
'ora_type' attribute to 'SQLT_CHR' in the case of CLOBs and NCLOBs or 'SQLT_BIN' in the case of BLOBs as in this example for an insert;</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$in_clob</span> <span class="operator">=</span> <span class="string">"&lt;document&gt;\n"</span><span class="operator">;</span>
  <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"  &lt;value&gt;</span><span class="variable">$_</span><span class="string">&lt;/value&gt;\n"</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">10_000</span><span class="operator">;</span>
  <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"&lt;/document&gt;\n"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$in_blob</span> <span class="operator">=</span><span class="string">"0101"</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">10_000</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'insert into test_lob3@tpgtest (id,clob1,clob2, blob1,blob2) values(?,?,?,?,?)'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span> <span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">3</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span><span class="variable">$in_clob</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">SQLT_CHR</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="variable">$in_clob</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">SQLT_CHR</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">4</span><span class="operator">,</span><span class="variable">$in_blob</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">SQLT_BIN</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">5</span><span class="operator">,</span><span class="variable">$in_blob</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">SQLT_BIN</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</pre>
<p>So far the only limit reached with this form of insert is the LOBs must be under 2GB in size.</p>
<p>
</p>
<h4><a name="support_for_remote_lobs_">Support for Remote LOBs;</a></h4>
<p>Starting with Oracle 10gR2 the interface for Persistent LOBs was expanded to support remote LOBs (access over a dblink). Given a database called 'lob_test' that has a 'LINK' defined like this;</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">DATABASE</span> <span class="variable">LINK</span> <span class="variable">link_test</span> <span class="variable">CONNECT</span> <span class="variable">TO</span> <span class="variable">test_lobs</span> <span class="variable">IDENTIFIED</span> <span class="variable">BY</span> <span class="variable">tester</span> <span class="variable">USING</span> <span class="string">'lob_test'</span><span class="operator">;</span>
</pre>
<p>to a remote database called 'test_lobs', the following code will work;</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'test@lob_test'</span><span class="operator">,</span><span class="string">'test'</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">*</span><span class="number">1024</span><span class="operator">*</span><span class="number">1024</span><span class="operator">;</span> <span class="comment">#2 meg</span>
  <span class="variable">$SQL</span><span class="operator">=</span><span class="string">'select p_id,lob_1,lob_2,blob_2 from test_lobs@link_test'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span><span class="operator">{</span><span class="string">ora_pers_lob</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$p_id</span><span class="operator">,</span><span class="variable">$log</span><span class="operator">,</span><span class="variable">$log2</span><span class="operator">,</span><span class="variable">$log3</span><span class="operator">,</span><span class="variable">$log4</span> <span class="operator">)=</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow</span><span class="operator">()){</span>
     <span class="keyword">print</span> <span class="string">"p_id="</span><span class="operator">.</span><span class="variable">$p_id</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
     <span class="keyword">print</span> <span class="string">"clob1="</span><span class="operator">.</span><span class="variable">$clob1</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
     <span class="keyword">print</span> <span class="string">"clob2="</span><span class="operator">.</span><span class="variable">$clob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
     <span class="keyword">print</span> <span class="string">"blob1="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
     <span class="keyword">print</span> <span class="string">"blob2="</span><span class="operator">.</span><span class="variable">$blob2</span><span class="operator">.</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>Below are the limitations of Remote LOBs;</p>
<dl>
<dt><strong><a name="queries_involving_more_than_one_database_are_not_supported" class="item">Queries involving more than one database are not supported;</a></strong></dt>

<dd>
<p>so the following returns an error:</p>
<pre>
  <span class="variable">SELECT</span> <span class="variable">t1</span><span class="operator">.</span><span class="variable">lobcol</span><span class="operator">,</span>
         <span class="variable">a2</span><span class="operator">.</span><span class="variable">lobcol</span>
    <span class="variable">FROM</span> <span class="variable">t1</span><span class="operator">,</span>
         <span class="variable">t2</span><span class="operator">.</span><span class="variable">lobcol</span><span class="variable">@dbs2</span> <span class="variable">a2</span> <span class="variable">W</span>
   <span class="variable">WHERE</span> <span class="variable">LENGTH</span><span class="operator">(</span><span class="variable">t1</span><span class="operator">.</span><span class="variable">lobcol</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">LENGTH</span><span class="operator">(</span><span class="variable">a2</span><span class="operator">.</span><span class="variable">lobcol</span><span class="operator">);</span>
</pre>
<p>as does:</p>
<pre>
     <span class="variable">SELECT</span> <span class="variable">t1</span><span class="operator">.</span><span class="variable">lobcol</span>
       <span class="variable">FROM</span> <span class="variable">t1</span><span class="variable">@dbs1</span>
       <span class="variable">UNION</span> <span class="variable">ALL</span>
     <span class="variable">SELECT</span> <span class="variable">t2</span><span class="operator">.</span><span class="variable">lobcol</span>
       <span class="variable">FROM</span> <span class="variable">t2</span><span class="variable">@dbs2</span><span class="operator">;</span>
</pre>
</dd>
<dt><strong><a name="ddl_commands_are_not_supported" class="item">DDL commands are not supported;</a></strong></dt>

<dd>
<p>so the following returns an error:</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">VIEW</span> <span class="variable">v</span> <span class="variable">AS</span> <span class="variable">SELECT</span> <span class="variable">lob_col</span> <span class="variable">FROM</span> <span class="variable">tab</span><span class="variable">@dbs</span><span class="operator">;</span>
</pre>
</dd>
<dt><strong><a name="only_binds_and_defines_for_data_going_into_remote_persistent_lobs_are_supported" class="item">Only binds and defines for data going into remote persistent LOBs are supported.</a></strong></dt>

<dd>
<p>so that parameter passing in PL/SQL where CHAR data is bound or defined for remote LOBs is not allowed .</p>
<p>These statements all produce errors:</p>
<pre>
  <span class="variable">SELECT</span> <span class="variable">foo</span><span class="operator">()</span> <span class="variable">FROM</span> <span class="variable">table1</span><span class="variable">@dbs2</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">SELECT</span> <span class="variable">foo</span><span class="operator">()</span><span class="variable">@dbs</span> <span class="variable">INTO</span> <span class="variable">char_val</span> <span class="variable">FROM</span> <span class="variable">DUAL</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">SELECT</span> <span class="variable">XMLType</span><span class="operator">().</span><span class="variable">getclobval</span> <span class="variable">FROM</span> <span class="variable">table1</span><span class="variable">@dbs2</span><span class="operator">;</span>
</pre>
</dd>
<dt><strong><a name="if_the_remote_object_is_a_view_such_as" class="item">If the remote object is a view such as</a></strong></dt>

<dd>
<pre>
  CREATE VIEW v AS SELECT foo() FROM ...</pre>
<p>the following would not work:</p>
<pre>
  <span class="variable">SELECT</span> <span class="operator">*</span> <span class="variable">FROM</span> <span class="variable">v</span><span class="variable">@dbs2</span><span class="operator">;</span>
</pre>
</dd>
<dt><strong><a name="limited_pl_sql_parameter_passing" class="item">Limited PL/SQL parameter passing</a></strong></dt>

<dd>
<p>PL/SQL parameter passing is not allowed where the actual argument is a LOB type
and the remote argument is one of VARCHAR2, NVARCHAR2, CHAR, NCHAR, or RAW.</p>
</dd>
<dt><strong><a name="returning_into_does_not_support_implicit_conversions_between_char_and_clob" class="item">RETURNING INTO does not support implicit conversions between CHAR and CLOB.</a></strong></dt>

<dd>
<p>so the following returns an error:</p>
<pre>
  SELECT t1.lobcol as test, a2.lobcol FROM t1, t2.lobcol@dbs2 a2 RETURNING test</pre>
</dd>
</dl>
<p>
</p>
<h3><a name="locator_data_interface"><strong>Locator Data Interface</strong></a></h3>
<p>
</p>
<h4><a name="simple_usage">Simple Usage</a></h4>
<p>When fetching LOBs with this interface a 'LOB Locator' is created then used to get the lob with the LongReadLen and LongTruncOk attributes.
The value for 'LongReadLen' is dependent on the version and settings of the Oracle DB you are using. In theory it ranges from 8GBs
in 9iR1 up to 128 terabytes with 11g but you will also be limited by the physical memory of your PERL instance.</p>
<p>When inserting or updating LOBs some <em>major</em> magic has to be performed
behind the scenes to make it transparent.  Basically the driver has to
insert a 'LOB Locator' and then refetch the newly inserted LOB
Locator before being able to write the data into it.  However, it works
well most of the time, and I've made it as fast as possible, just one
extra server-round-trip per insert or update after the first.  For the
time being, only single-row LOB updates are supported.</p>
<p>To insert or update a large LOB using a placeholder, DBD::Oracle has to
know in advance that it is a LOB type. So you need to say:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$field_num</span><span class="operator">,</span> <span class="variable">$lob_value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>The ORA_CLOB and ORA_BLOB constants can be imported using</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>or use the corresponding integer values (112 and 113).</p>
<p>One further wrinkle: for inserts and updates of LOBs, DBD::Oracle has
to be able to tell which parameters relate to which table fields.
In all cases where it can possibly work it out for itself, it does,
however, if there are multiple LOB fields of the same type in the table
then you need to tell it which field each LOB param relates to:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$idx</span><span class="operator">,</span> <span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">ORA_CLOB</span><span class="operator">,</span> <span class="string">ora_field</span><span class="operator">=&gt;</span><span class="string">'foo'</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>There are some limitations inherent in the way DBD::Oracle makes typical
LOB operations simple by hiding the LOB Locator processing:</p>
<pre>
 - Can't read/write LOBs in chunks (except via DBMS_LOB.WRITEAPPEND in PL/SQL)
 - To INSERT a LOB, you need UPDATE privilege.</pre>
<p>The alternative is to disable the automatic LOB Locator processing.
If <a href="#ora_auto_lob">ora_auto_lob</a> is 0 in <code>prepare()</code>, you can fetch the LOB Locators and
do all the work yourself using the ora_lob_*() methods.
See the <a href="#data_interface_for_lob_locators">Data Interface for LOB Locators</a> section below.</p>
<p>
</p>
<h4><a name="lob_support_in_pl_sql">LOB support in PL/SQL</a></h4>
<p>LOB Locators can be passed to PL/SQL calls by binding them to placeholders
with the proper <a href="#ora_type"><code>ora_type</code></a>.  If <a href="#ora_auto_lob">ora_auto_lob</a> is true, output LOB
parameters will be automatically returned as strings.</p>
<p>If the Oracle driver has support for temporary LOBs (Oracle 9i and higher),
strings can be bound to input LOB placeholders and will be automatically
converted to LOBs.</p>
<p>Example:
     # Build a large XML document, bind it as a CLOB,
     # extract elements through PL/SQL and return as a CLOB</p>
<pre>
     <span class="comment"># $dbh is a connected database handle</span>
     <span class="comment"># output will be large</span>
</pre>
<pre>
     <span class="keyword">local</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1_000_000</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">my</span> <span class="variable">$in_clob</span> <span class="operator">=</span> <span class="string">"&lt;document&gt;\n"</span><span class="operator">;</span>
     <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"  &lt;value&gt;</span><span class="variable">$_</span><span class="string">&lt;/value&gt;\n"</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">10_000</span><span class="operator">;</span>
     <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"&lt;/document&gt;\n"</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">my</span> <span class="variable">$out_clob</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(&lt;&lt;</span><span class="default">PLSQL_END</span><span class="operator">);</span><span class="string">
     -- extract 'value' nodes
     DECLARE
       x XMLTYPE := XMLTYPE(:in);
     BEGIN
       :out := x.extract('/document/value').getClobVal();
     END;
     </span>
</pre>
<pre>
     PLSQL_END</pre>
<pre>
     <span class="comment"># :in param will be converted to a temp lob</span>
     <span class="comment"># :out parameter will be returned as a string.</span>
</pre>
<pre>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">':in'</span><span class="operator">,</span> <span class="variable">$in_clob</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span> <span class="operator">);</span>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">':out'</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$out_clob</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span> <span class="operator">);</span>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>If you ever get an</p>
<pre>
  ORA-01691 unable to extend lob segment sss.ggg by nnn in tablespace ttt</pre>
<p>error, while attempting to insert a LOB, this means the Oracle user has insufficient space for LOB you are trying to insert.
One solution it to use &quot;alter database datafile 'sss.ggg' resize Mnnn&quot; to increase the available memory for LOBs.</p>
<p>
</p>
<h3><a name="persistent___locator_interface_caveats"><strong>Persistent &amp; Locator Interface Caveats</strong></a></h3>
<p>Now that one has the option of using the Persistent or the Locator interface for LOBs the questions arises
which one to use. For starters, if you want to access LOBs over a dblink you will have to use the Persistent
interface so that choice is simple.  The question of which one to use after that is a little more tricky.
It basically boils down to a choice between LOB size and speed.</p>
<p>The Callback and Polling piecewise fetches are very very slow
when compared to the Simple and the Locator fetches but they can handle very large blocks of data. Given a situation where a
large LOB is to be read the Locator fetch may time out while either of the piecewise fetches may not.</p>
<p>With the Simple fetch you are limited by physical memory of your server but it runs a little faster than the Locator, as there are fewer round trips
to the server. So if you have small LOBs and need to save a little bandwidth this is the one to use. It you are going after large LOBs then the Locator interface is the one to use.</p>
<p>If you need to update more than a single row of with LOB data then the Persistent interface can do it while the Locator can't.</p>
<p>If you encounter a situation where you have to access the legacy LOBs (LONG, LONG RAW) and the values are to large for you system then you can use
the Callback or Polling piecewise fetches to  get all of the data.</p>
<p>Not all of the Persistent interface has been implemented yet, the following are not supported;</p>
<pre>
  1) Piecewise, polling and callback binds for INSERT and UPDATE operations.
  2) Piecewise array binds for SELECT, INSERT and UPDATE operations.</pre>
<p>Most of the time you should just use the <a href="#locator_data_interface">Locator Data Interface</a> as this is in one that has the best combination of speed and size.</p>
<p>All this being said if you are doing some critical programming I would use the <a href="#data_interface_for_lob_locators">Data Interface for LOB Locators</a> as this gives you very
fine grain control of your LOBs, of course the code for this will be somewhat more involved.</p>
<p>
</p>
<h3><a name="data_interface_for_lob_locators"><strong>Data Interface for LOB Locators</strong></a></h3>
<p>The following driver-specific methods let you manipulate &quot;LOB Locators&quot; directly.
To select a LOB locator directly set the if the <a href="#ora_auto_lob"><code>ora_auto_lob</code></a>
attribute to false, or alternatively they can be returned via PL/SQL procedure calls.</p>
<p>(If using a DBI version earlier than 1.36 they must be called via the
<code>func()</code> method. Note that methods called via <code>func()</code> don't honour
RaiseError etc, and so it's important to check $dbh-&gt;err after each call.
It's recommended that you upgrade to DBI 1.38 or later.)</p>
<p>Note that LOB locators are only valid while the statement handle that
created them is valid.  When all references to the original statement
handle are lost, the handle is destroyed and the locators are freed.</p>
<dl>
<dt><strong><a name="ora_lob_read" class="item">ora_lob_read</a></strong></dt>

<dd>
<pre>
  <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_read</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">);</span>
</pre>
<p>Read a portion of the LOB. $offset starts at 1.
Uses the Oracle OCILobRead function.</p>
</dd>
<dt><strong><a name="ora_lob_write" class="item">ora_lob_write</a></strong></dt>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">);</span>
</pre>
<p>Write/overwrite a portion of the LOB. $offset starts at 1.
Uses the Oracle OCILobWrite function.</p>
</dd>
<dt><strong><a name="ora_lob_append" class="item">ora_lob_append</a></strong></dt>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_append</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">);</span>
</pre>
<p>Append $data to the LOB.  Uses the Oracle OCILobWriteAppend function.</p>
</dd>
<dt><strong><a name="ora_lob_trim" class="item">ora_lob_trim</a></strong></dt>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_trim</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">);</span>
</pre>
<p>Trims the length of the LOB to $length.
Uses the Oracle OCILobTrim function.</p>
</dd>
<dt><strong><a name="ora_lob_length" class="item">ora_lob_length</a></strong></dt>

<dd>
<pre>
  <span class="variable">$length</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_length</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">);</span>
</pre>
<p>Returns the length of the LOB.
Uses the Oracle OCILobGetLength function.</p>
</dd>
<dt><strong><a name="ora_lob_is_init" class="item">ora_lob_is_init</a></strong></dt>

<dd>
<pre>
  <span class="variable">$is_init</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_is_init</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">);</span>
</pre>
<p>Returns <code>true(1)</code> if the Lob Locator is initialized <code>false(0)</code> if it is not, or 'undef'
if there is an error.
Uses the Oracle OCILobLocatorIsInit function.</p>
</dd>
<dt><strong><a name="ora_lob_chunk_size" class="item">ora_lob_chunk_size</a></strong></dt>

<dd>
<pre>
  <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_chunk_size</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">);</span>
</pre>
<p>Returns the chunk size of the LOB.
Uses the Oracle OCILobGetChunkSize function.</p>
<p>For optimal performance, Oracle recommends reading from and
writing to a LOB in batches using a multiple of the LOB chunk size.
In Oracle 10g and before, when all defaults are in place, this
chunk size defaults to 8k (8192).</p>
</dd>
</dl>
<p>
</p>
<h4><a name="lob_locator_method_examples">LOB Locator Method Examples</a></h4>
<p><em>Note:</em> Make sure you first read the note in the section above about
multi-byte character set issues with these methods.</p>
<p>The following examples demonstrate the usage of LOB Locators
to read, write, and append data, and to query the size of
large data.</p>
<p>The following examples assume a table containing two large
object columns, one binary and one character, with a primary
key column, defined as follows:</p>
<pre>
   CREATE TABLE lob_example (
      lob_id      INTEGER PRIMARY KEY,
      bindata     BLOB,
      chardata    CLOB
   )</pre>
<p>It also assumes a sequence for use in generating unique
lob_id field values, defined as follows:</p>
<pre>
   CREATE SEQUENCE lob_example_seq</pre>
<p>
</p>
<h4><a name="example__inserting_a_new_row_with_large_data">Example: Inserting a new row with large data</a></h4>
<p>Unless enough memory is available to store and bind the
entire LOB data for insert all at once, the LOB columns must
be written interactively, piece by piece.  In the case of a new row,
this is performed by first inserting a row, with empty values in
the LOB columns, then modifying the row by writing the large data
interactively to the LOB columns using their LOB locators as handles.</p>
<p>The insert statement must create token values in the LOB
columns.  Here, we use the empty string for both the binary
and character large object columns 'bindata' and 'chardata'.</p>
<p>After the INSERT statement, a SELECT statement is used to
acquire LOB locators to the 'bindata' and 'chardata' fields
of the newly inserted row.  Because these LOB locators are
subsequently written, they must be acquired from a select
statement containing the clause 'FOR UPDATE' (LOB locators
are only valid within the transaction that fetched them, so
can't be used effectively if AutoCommit is enabled).</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span> <span class="operator">);</span><span class="string">
      SELECT lob_example_seq.nextval FROM DUAL
   SQL
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span> <span class="operator">);</span><span class="string">
      INSERT INTO lob_example
      ( lob_id, bindata, chardata )
      VALUES ( ?, EMPTY_BLOB(),EMPTY_CLOB() )
   SQL
   $sth-&gt;execute( $lob_id );
   </span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="string">
      SELECT bindata, chardata
      FROM lob_example
      WHERE lob_id = ?
      FOR UPDATE
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $bin_locator, $char_locator ) = $sth-&gt;fetchrow_array();
   $sth-&gt;finish();
   </span>
</pre>
<pre>
   <span class="keyword">open</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="string">"/binary/data/source"</span> <span class="keyword">or</span> <span class="keyword">die</span><span class="operator">;</span>
   <span class="keyword">open</span> <span class="variable">CHAR_FH</span><span class="operator">,</span> <span class="string">"/character/data/source"</span> <span class="keyword">or</span> <span class="keyword">die</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_chunk_size</span><span class="operator">(</span> <span class="variable">$bin_locator</span> <span class="operator">);</span>
</pre>
<pre>
   <span class="comment"># BEGIN WRITING BIN_DATA COLUMN</span>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="keyword">my</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$length</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<pre>
   <span class="comment"># BEGIN WRITING CHAR_DATA COLUMN</span>
   <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_chunk_size</span><span class="operator">(</span> <span class="variable">$char_locator</span> <span class="operator">);</span>
   <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="variable">$length</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
   <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">CHAR_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$char_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$length</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>In this example we demonstrate the use of <a href="#ora_lob_write"><code>ora_lob_write()</code></a>
interactively to append data to the columns 'bin_data' and
'char_data'.  Had we used <a href="#ora_lob_append"><code>ora_lob_append()</code></a>, we could have
saved ourselves the trouble of keeping track of the offset
into the lobs.  The snippet of code beneath the comment
'BEGIN WRITING BIN_DATA COLUMN' could look as follows:</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_append</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
   <span class="operator">}</span>
</pre>
<p>The scalar variables $offset and $length are no longer
needed, because <a href="#ora_lob_append"><code>ora_lob_append()</code></a> keeps track of the offset
for us.</p>
<p>
</p>
<h4><a name="example__updating_an_existing_row_with_large_data">Example: Updating an existing row with large data</a></h4>
<p>In this example, we demonstrate a technique for overwriting
a portion of a blob field with new binary data.  The blob
data before and after the section overwritten remains
unchanged.  Hence, this technique could be used for updating
fixed length subfields embedded in a binary field.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>   <span class="comment"># Arbitrary row identifier, for example</span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="string">
      SELECT bindata
      FROM lob_example
      WHERE lob_id = ?
      FOR UPDATE
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $bin_locator ) = $sth-&gt;fetchrow_array();
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">100234</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="string">"This string will overwrite a portion of the blob"</span><span class="operator">;</span>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$data</span> <span class="operator">);</span>
</pre>
<p>After running this code, the row where lob_id = 5 will
contain, starting at position 100234 in the bin_data column,
the string &quot;This string will overwrite a portion of the blob&quot;.</p>
<p>
</p>
<h4><a name="example__streaming_character_data_from_the_database">Example: Streaming character data from the database</a></h4>
<p>In this example, we demonstrate a technique for streaming
data from the database to a file handle, in this case
STDOUT.  This allows more data to be read in and written out
than could be stored in memory at a given time.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="number">17</span><span class="operator">;</span>   <span class="comment"># Arbitrary row identifier, for example</span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="string">
      SELECT chardata
      FROM lob_example
      WHERE lob_id = ?
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $char_locator ) = $sth-&gt;fetchrow_array();
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="number">1034</span><span class="operator">;</span>   <span class="comment"># Arbitrary chunk size, for example</span>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="keyword">while</span><span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_read</span><span class="operator">(</span> <span class="variable">$char_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">);</span>
      <span class="keyword">last</span> <span class="keyword">unless</span> <span class="keyword">length</span> <span class="variable">$data</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="variable">STDOUT</span> <span class="variable">$data</span><span class="operator">;</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$chunk_size</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>Notice that the select statement does not contain the phrase
&quot;FOR UPDATE&quot;.  Because we are only reading from the LOB
Locator returned, and not modifying the LOB it refers to,
the select statement does not require the &quot;FOR UPDATE&quot;
clause.</p>
<p>A word of caution when using the data returned from an ora_lob_read in a conditional statement.
for example if the code below;</p>
<pre>
   <span class="keyword">while</span><span class="operator">(</span> <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_read</span><span class="operator">(</span> <span class="variable">$char_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">STDOUT</span> <span class="variable">$data</span><span class="operator">;</span>
        <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$chunk_size</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>was used with a chunk size of 4096 against a blob that requires more than 1 chunk to return
the data and the last chunk is one byte long and contains a zero (ASCII 48) you will miss this last byte
as $data will contain 0 which PERL will see as false and not print it out.</p>
<p>
</p>
<h4><a name="example__truncating_existing_large_data">Example: Truncating existing large data</a></h4>
<p>In this example, we truncate the data already present in a
large object column in the database.  Specifically, for each
row in the table, we truncate the 'bindata' value to half
its previous length.</p>
<p>After acquiring a LOB Locator for the column, we query its
length, then we trim the length by half.  Because we modify
the large objects with the call to <a href="#ora_lob_trim"><code>ora_lob_trim()</code></a>, we must
select the LOB locators 'FOR UPDATE'.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span> <span class="operator">&lt;&lt;</span><span class="default">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="string">
      SELECT bindata
      FROM lob_example
      FOR UPATE
   SQL
   $sth-&gt;execute();
   while( my ( $bin_locator ) = $sth-&gt;fetchrow_array() ) {
      my $binlength = $dbh-&gt;ora_lob_length( $bin_locator );
      if( $binlength &gt; 0 ) {
         $dbh-&gt;ora_lob_trim( $bin_locator, $binlength/2 );
      }
   }
   </span>
</pre>
<p>
</p>
<hr />
<h1><a name="pl_sql_examples">PL/SQL Examples</a></h1>
<p>Most of these PL/SQL examples come from: Eric Bartley &lt;<a href="mailto:bartley@cc.purdue.edu">bartley@cc.purdue.edu</a>&gt;.</p>
<pre>
   /*
    * PL/SQL to create package with stored procedures invoked by
    * Perl examples.  Execute using sqlplus.
    *
    * Use of &quot;... OR REPLACE&quot; prevents failure in the event that the
    * package already exists.
    */</pre>
<pre>
    <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">plsql_example</span>
    <span class="variable">IS</span>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_np</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in</span> <span class="operator">(</span>
          <span class="variable">err_code</span> <span class="variable">IN</span> <span class="variable">NUMBER</span>
      <span class="operator">);</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in_inout</span> <span class="operator">(</span>
          <span class="variable">test_num</span> <span class="variable">IN</span> <span class="variable">NUMBER</span><span class="operator">,</span>
          <span class="variable">is_odd</span> <span class="variable">IN</span> <span class="variable">OUT</span> <span class="variable">NUMBER</span>
      <span class="operator">);</span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">func_np</span>
        <span class="variable">RETURN</span> <span class="variable">VARCHAR2</span><span class="operator">;</span>
</pre>
<pre>
    END plsql_example;
  /</pre>
<pre>
    <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">BODY</span> <span class="variable">plsql_example</span>
    <span class="variable">IS</span>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_np</span>
      <span class="variable">IS</span>
        <span class="variable">whoami</span> <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">20</span><span class="operator">)</span> <span class="operator">:=</span> <span class="variable">NULL</span><span class="operator">;</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">SELECT</span> <span class="variable">USER</span> <span class="variable">INTO</span> <span class="variable">whoami</span> <span class="variable">FROM</span> <span class="variable">DUAL</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in</span> <span class="operator">(</span>
        <span class="variable">err_code</span> <span class="variable">IN</span> <span class="variable">NUMBER</span>
      <span class="operator">)</span>
      <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">RAISE_APPLICATION_ERROR</span><span class="operator">(</span><span class="variable">err_code</span><span class="operator">,</span> <span class="string">'This is a test.'</span><span class="operator">);</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in_inout</span> <span class="operator">(</span>
        <span class="variable">test_num</span> <span class="variable">IN</span> <span class="variable">NUMBER</span><span class="operator">,</span>
        <span class="variable">is_odd</span> <span class="variable">IN</span> <span class="variable">OUT</span> <span class="variable">NUMBER</span>
      <span class="operator">)</span>
      <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">is_odd</span> <span class="operator">:=</span> <span class="variable">MOD</span><span class="operator">(</span><span class="variable">test_num</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">func_np</span>
        <span class="variable">RETURN</span> <span class="variable">VARCHAR2</span>
      <span class="variable">IS</span>
        <span class="variable">ret_val</span> <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">20</span><span class="operator">);</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">SELECT</span> <span class="variable">USER</span> <span class="variable">INTO</span> <span class="variable">ret_val</span> <span class="variable">FROM</span> <span class="variable">DUAL</span><span class="operator">;</span>
        <span class="variable">RETURN</span> <span class="variable">ret_val</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
    END plsql_example;
  /
  /* End PL/SQL for example package creation. */</pre>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">my</span><span class="operator">(</span><span class="variable">$db</span><span class="operator">,</span> <span class="variable">$csr</span><span class="operator">,</span> <span class="variable">$ret_val</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:database'</span><span class="operator">,</span><span class="string">'user'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">)</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Unable to connect: </span><span class="variable">$DBI</span><span class="string">::errstr"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># So we don't have to check every DBI call we set RaiseError.</span>
  <span class="comment"># See the DBI docs now if you're not familiar with RaiseError.</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 1   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Calling a PLSQL procedure that takes no parameters. This shows you the</span>
  <span class="comment"># basic's of what you need to execute a PLSQL procedure. Just wrap your</span>
  <span class="comment"># procedure call in a BEGIN END; block just like you'd do in SQL*Plus.</span>
  <span class="comment">#</span>
  <span class="comment"># p.s. If you've used SQL*Plus's exec command all it does is wrap the</span>
  <span class="comment">#      command in a BEGIN END; block for you.</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
    BEGIN
      PLSQL_EXAMPLE.PROC_NP;
    END;
  }</span><span class="operator">);</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 2   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Now we call a procedure that has 1 IN parameter. Here we use bind_param</span>
  <span class="comment"># to bind out parameter to the prepared statement just like you might</span>
  <span class="comment"># do for an INSERT, UPDATE, DELETE, or SELECT statement.</span>
  <span class="comment">#</span>
  <span class="comment"># I could have used positional placeholders (e.g. :1, :2, etc.) or</span>
  <span class="comment"># ODBC style placeholders (e.g. ?), but I prefer Oracle's named</span>
  <span class="comment"># placeholders (but few DBI drivers support them so they're not portable).</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$err_code</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">20001</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            PLSQL_EXAMPLE.PROC_IN(:err_code);
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":err_code"</span><span class="operator">,</span> <span class="variable">$err_code</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># PROC_IN will RAISE_APPLICATION_ERROR which will cause the execute to 'fail'.</span>
  <span class="comment"># Because we set RaiseError, the DBI will croak (die) so we catch that with eval.</span>
  <span class="keyword">eval</span> <span class="operator">{</span>
    <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="operator">};</span>
  <span class="keyword">print</span> <span class="string">'After proc_in: $@='</span><span class="operator">,</span><span class="string">"'$@', errstr=</span><span class="variable">$DBI</span><span class="string">::errstr, ret_val=</span><span class="variable">$ret_val</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 3   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Building on the last example, I've added 1 IN OUT parameter. We still</span>
  <span class="comment"># use a placeholders in the call to prepare, the difference is that</span>
  <span class="comment"># we now call bind_param_inout to bind the value to the place holder.</span>
  <span class="comment">#</span>
  <span class="comment"># Note that the third parameter to bind_param_inout is the maximum size</span>
  <span class="comment"># of the variable. You normally make this slightly larger than necessary.</span>
  <span class="comment"># But note that the Perl variable will have that much memory assigned to</span>
  <span class="comment"># it even if the actual value returned is shorter.</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$test_num</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$is_odd</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            PLSQL_EXAMPLE.PROC_IN_INOUT(:test_num, :is_odd);
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># The value of $test_num is _copied_ here</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":test_num"</span><span class="operator">,</span> <span class="variable">$test_num</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":is_odd"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$is_odd</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># The execute will automagically update the value of $is_odd</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="string">"</span><span class="variable">$test_num</span><span class="string"> is "</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">$is_odd</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"odd - ok"</span> <span class="operator">:</span> <span class="string">"even - error!"</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 4   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># What about the return value of a PLSQL function? Well treat it the same</span>
  <span class="comment"># as you would a call to a function from SQL*Plus. We add a placeholder</span>
  <span class="comment"># for the return value and bind it with a call to bind_param_inout so</span>
  <span class="comment"># we can access it's value after execute.</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$whoami</span> <span class="operator">=</span> <span class="string">""</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            :whoami := PLSQL_EXAMPLE.FUNC_NP;
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":whoami"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$whoami</span><span class="operator">,</span> <span class="number">20</span><span class="operator">);</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"Your database user name is </span><span class="variable">$whoami</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">disconnect</span><span class="operator">;</span>
</pre>
<p>You can find more examples in the t/plsql.t file in the DBD::Oracle
source directory.</p>
<p>Oracle 9.2 appears to have a bug where a variable bound
with <code>bind_param_inout()</code> that isn't assigned to by the executed
PL/SQL block may contain garbage.
See <a href="http://www.mail-archive.com/dbi-users@perl.org/msg18835.html">http://www.mail-archive.com/dbi-users@perl.org/msg18835.html</a></p>
<p>
</p>
<h2><a name="avoid_using_sql_call">Avoid Using &quot;SQL Call&quot;</a></h2>
<p>Avoid using the &quot;SQL Call&quot; statement with DBD:Oracle as you might find that
DBD::Oracle will not raise an exception in some case.  Specifically if you use
&quot;SQL Call&quot; to run a procedure all &quot;No data found&quot; exceptions will be quietly
ignored and returned as null. According to Oracle support this is part of the same
mechanism where;</p>
<pre>
  select (select * from dual where 0=1) from dual</pre>
<p>returns a null value rather than an exception.</p>
<p>
</p>
<hr />
<h1><a name="contributing">CONTRIBUTING</a></h1>
<p>If you'd like DBD::Oracle to do something new or different the best way
to make that happen is to do it yourself and email to <a href="mailto:dbi-dev@perl.org">dbi-dev@perl.org</a> a
patch of the source code (using 'diff' - see below) that shows the changes.</p>
<p>
</p>
<h2><a name="how_to_create_a_patch_using_subversion">How to create a patch using Subversion</a></h2>
<p>The DBD::Oracle source code is maintained using Subversion (a replacement
for CVS, see <a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>). To access the source
you'll need to install a Subversion client. Then, to get the source
code, do:</p>
<pre>
  svn checkout <a href="http://svn.perl.org/modules/dbd-oracle/trunk">http://svn.perl.org/modules/dbd-oracle/trunk</a></pre>
<p>If it prompts for a username and password use your perl.org account
if you have one, else just 'guest' and 'guest'. The source code will
be in a new subdirectory called <code>trunk</code>.</p>
<p>To keep informed about changes to the source you can send an empty email
to <a href="mailto:dbd-oracle-changes-subscribe@perl.org">dbd-oracle-changes-subscribe@perl.org</a> after which you'll get an email with the
change log message and diff of each change checked-in to the source.</p>
<p>After making your changes you can generate a patch file, but before
you do, make sure your source is still upto date using:</p>
<pre>
  svn update</pre>
<p>If you get any conflicts reported you'll need to fix them first.
Then generate the patch file from within the <code>trunk</code> directory using:</p>
<pre>
  svn diff &gt; foo.patch</pre>
<p>Read the patch file, as a sanity check, and then email it to <a href="mailto:dbi-dev@perl.org.">dbi-dev@perl.org.</a></p>
<p>
</p>
<h2><a name="how_to_create_a_patch_without_subversion">How to create a patch without Subversion</a></h2>
<p>Unpack a fresh copy of the distribution:</p>
<pre>
  tar xfz DBD-Oracle-1.40.tar.gz</pre>
<p>Rename the newly created top level directory:</p>
<pre>
  mv DBD-Oracle-1.40 DBD-Oracle-1.40.your_foo</pre>
<p>Edit the contents of DBD-Oracle-1.40.your_foo/* till it does what you want.</p>
<p>Test your changes and then remove all temporary files:</p>
<pre>
  make test &amp;&amp; make distclean</pre>
<p>Go back to the directory you originally unpacked the distribution:</p>
<pre>
  cd ..</pre>
<p>Unpack <em>another</em> copy of the original distribution you started with:</p>
<pre>
  tar xfz DBD-Oracle-1.40.tar.gz</pre>
<p>Then create a patch file by performing a recursive <code>diff</code> on the two
top level directories:</p>
<pre>
  diff -r -u DBD-Oracle-1.40 DBD-Oracle-1.40.your_foo &gt; DBD-Oracle-1.40.your_foo.patch</pre>
<p>
</p>
<h2><a name="speak_before_you_patch">Speak before you patch</a></h2>
<p>For anything non-trivial or possibly controversial it's a good idea
to discuss (on <a href="mailto:dbi-dev@perl.org)">dbi-dev@perl.org)</a> the changes you propose before
actually spending time working on them. Otherwise you run the risk
of them being rejected because they don't fit into some larger plans
you may not be aware of.</p>
<p>
</p>
<hr />
<h1><a name="oracle_related_links">Oracle Related Links</a></h1>
<p>
</p>
<h2><a name="dbd__oracle_tutorial">DBD::Oracle Tutorial</a></h2>
<pre>
  <a href="http://www.pythian.com/blogs/wp-content/uploads/introduction-dbd-oracle.html">http://www.pythian.com/blogs/wp-content/uploads/introduction-dbd-oracle.html</a></pre>
<p>
</p>
<h2><a name="oracle_instant_client">Oracle Instant Client</a></h2>
<pre>
  <a href="http://www.oracle.com/technology/tech/oci/instantclient/index.html">http://www.oracle.com/technology/tech/oci/instantclient/index.html</a></pre>
<p>
</p>
<h2><a name="oracle_on_linux">Oracle on Linux</a></h2>
<pre>
  <a href="http://www.ixora.com.au/">http://www.ixora.com.au/</a></pre>
<p>
</p>
<h2><a name="free_oracle_tools_and_links">Free Oracle Tools and Links</a></h2>
<pre>
  ora_explain supplied and installed with DBD::Oracle.</pre>
<pre>
  <a href="http://www.orafaq.com/">http://www.orafaq.com/</a></pre>
<pre>
  <a href="http://vonnieda.org/oracletool/">http://vonnieda.org/oracletool/</a></pre>
<p>
</p>
<h2><a name="commercial_oracle_tools_and_links">Commercial Oracle Tools and Links</a></h2>
<p>Assorted tools and references for general information.
No recommendation implied.</p>
<pre>
  <a href="http://www.platinum.com">http://www.platinum.com</a>
  <a href="http://www.SoftTreeTech.com">http://www.SoftTreeTech.com</a></pre>
<p>Also PL/Vision from RevealNet and Steven Feuerstein, and
&quot;Q&quot; from Savant Corporation.</p>
<p>
</p>
<hr />
<h1><a name="bugs_and_limitations">BUGS AND LIMITATIONS</a></h1>
<p>There is a known problem with the 11.2g Oracle client and the 
<code>DBMS_LOB.GETLENGTH()</code> PL/SQL function.  
See <a href="https://rt.cpan.org/Public/Bug/Display.html?id=69350">https://rt.cpan.org/Public/Bug/Display.html?id=69350</a> for the details.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>DBI</p>
<p><a href="http://search.cpan.org/~timb/DBD-Oracle/MANIFEST">http://search.cpan.org/~timb/DBD-Oracle/MANIFEST</a> for all files in
the DBD::Oracle source distribution including the examples in the
Oracle.ex directory</p>
<pre>
  <a href="http://search.cpan.org/search?query=Oracle&amp;mode=dist">http://search.cpan.org/search?query=Oracle&amp;mode=dist</a></pre>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>DBD::Oracle by Tim Bunce. DBI by Tim Bunce.</p>
<p>
</p>
<hr />
<h1><a name="acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>A great many people have helped me with DBD::Oracle over the 17 years
between 1994 and 2011.  Far too many to name, but I thank them all.
Many are named in the Changes file.</p>
<p>See also <a href="../../lib/DBI/acknowledgements.html">ACKNOWLEDGEMENTS in the DBI manpage</a>.</p>
<p>
</p>
<hr />
<h1><a name="maintainer">MAINTAINER</a></h1>
<p>As of release 1.17 in February 2006 The Pythian Group, Inc. (<a href="http://www.pythian.com">http://www.pythian.com</a>)
are taking the lead in maintaining DBD::Oracle with my assistance and
gratitude. That frees more of my time to work on DBI for Perl 5 and Perl 6.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>The DBD::Oracle module is Copyright (c) 1994-2006 Tim Bunce. Ireland.
The DBD::Oracle module is Copyright (c) 2006-2011 John Scoles (The Pythian Group). Canada.
The DBD::Oracle module is Copyright (c) 2011 John Scoles. Canada.</p>
<p>The DBD::Oracle module is free open source software; you can
redistribute it and/or modify it under the same terms as Perl 5.</p>

</body>

</html>
