<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>Devel::NYTProf - Powerful fast feature-rich perl source code profiler</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>Devel::NYTProf - Powerful fast feature-rich perl source code profiler</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#statement_profiling">Statement Profiling</a></li>
		<li><a href="#subroutine_profiling">Subroutine Profiling</a></li>
		<ul>

			<li><a href="#subroutine_recursion">Subroutine Recursion</a></li>
			<li><a href="#goto__subroutine">Goto &amp;Subroutine</a></li>
			<li><a href="#accept__"><a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a></a></li>
		</ul>

		<li><a href="#application_profiling">Application Profiling</a></li>
		<li><a href="#fast_profiling">Fast Profiling</a></li>
		<li><a href="#apache_profiling">Apache Profiling</a></li>
	</ul>

	<li><a href="#profiling">PROFILING</a></li>
	<li><a href="#nytprof_environment_variable">NYTPROF ENVIRONMENT VARIABLE</a></li>
	<ul>

		<li><a href="#addpid_1">addpid=1</a></li>
		<li><a href="#trace_n">trace=N</a></li>
		<li><a href="#log_f">log=F</a></li>
		<li><a href="#start____">start=...</a></li>
		<li><a href="#optimize_0">optimize=0</a></li>
		<li><a href="#subs_0">subs=0</a></li>
		<li><a href="#blocks_0">blocks=0</a></li>
		<li><a href="#stmts_0">stmts=0</a></li>
		<li><a href="#leave_0">leave=0</a></li>
		<li><a href="#findcaller_1">findcaller=1</a></li>
		<li><a href="#use_db_sub_1">use_db_sub=1</a></li>
		<li><a href="#savesrc_0">savesrc=0</a></li>
		<li><a href="#slowops_n">slowops=N</a></li>
		<li><a href="#usecputime_1">usecputime=1</a></li>
		<li><a href="#file____">file=...</a></li>
		<li><a href="#compress____">compress=...</a></li>
		<li><a href="#clock_n">clock=N</a></li>
		<li><a href="#sigexit_1">sigexit=1</a></li>
		<li><a href="#posix_exit_1">posix_exit=1</a></li>
		<li><a href="#forkdepth_n">forkdepth=N</a></li>
		<li><a href="#nameevals_0">nameevals=0</a></li>
		<li><a href="#nameanonsubs_0">nameanonsubs=0</a></li>
	</ul>

	<li><a href="#run_time_control_of_profiling">RUN-TIME CONTROL OF PROFILING</a></li>
	<ul>

		<li><a href="#disable_profile">disable_profile</a></li>
		<li><a href="#enable_profile">enable_profile</a></li>
		<li><a href="#finish_profile">finish_profile</a></li>
	</ul>

	<li><a href="#data_collection_and_interpretation">DATA COLLECTION AND INTERPRETATION</a></li>
	<ul>

		<li><a href="#if_statement_and_subroutine_timings_don_t_match">If Statement and Subroutine Timings Don't Match</a></li>
		<li><a href="#if_headline_subroutine_timings_don_t_match_the_called_subs">If Headline Subroutine Timings Don't Match the Called Subs</a></li>
		<li><a href="#perl_5_10_1___or_else_5_8_9___is_recommended">Perl 5.10.1+ (or else 5.8.9+) is Recommended</a></li>
		<li><a href="#eval__string">eval $string</a></li>
		<ul>

			<li><a href="#merging_evals">Merging Evals</a></li>
			<li><a href="#merging_anonymous_subroutines">Merging Anonymous Subroutines</a></li>
			<li><a href="#timing">Timing</a></li>
		</ul>

		<li><a href="#calls_from_xsubs_and_opcodes">Calls from XSUBs and Opcodes</a></li>
	</ul>

	<li><a href="#making_nytprof_faster">MAKING NYTPROF FASTER</a></li>
	<li><a href="#reports">REPORTS</a></li>
	<ul>

		<li><a href="#nytprofhtml">nytprofhtml</a></li>
		<li><a href="#nytprofcsv">nytprofcsv</a></li>
		<li><a href="#nytprofcg">nytprofcg</a></li>
		<li><a href="#nytprofmerge">nytprofmerge</a></li>
	</ul>

	<li><a href="#limitations">LIMITATIONS</a></li>
	<ul>

		<li><a href="#threads_and_multiplicity">Threads and Multiplicity</a></li>
		<li><a href="#coro">Coro</a></li>
		<li><a href="#for_perl___5_8_8_it_may_change_what_caller___returns">For perl &lt; 5.8.8 it may change what <a href="../../lib/pods/perlfunc.html#caller"><code>caller()</code></a> returns</a></li>
		<li><a href="#for_perl___5_10_1_it_can_t_see_some_implicit_calls_and_callbacks">For perl &lt; 5.10.1 it can't see some implicit calls and callbacks</a></li>
		<li><a href="#_line_directives">#line directives</a></li>
		<li><a href="#freed_values_in____may_be_mutated">Freed values in @_ may be mutated</a></li>
		<li><a href="#lvalue_subroutines_aren_t_profiled_when_using_use_db_sub_1">Lvalue subroutines aren't profiled when using use_db_sub=1</a></li>
	</ul>

	<li><a href="#clocks">CLOCKS</a></li>
	<ul>

		<li><a href="#posix_clocks">POSIX Clocks</a></li>
		<ul>

			<li><a href="#clock_monotonic">CLOCK_MONOTONIC</a></li>
			<li><a href="#clock_realtime">CLOCK_REALTIME</a></li>
			<li><a href="#clock_virtual">CLOCK_VIRTUAL</a></li>
			<li><a href="#clock_prof">CLOCK_PROF</a></li>
			<li><a href="#clock_process_cputime_id">CLOCK_PROCESS_CPUTIME_ID</a></li>
			<li><a href="#clock_thread_cputime_id">CLOCK_THREAD_CPUTIME_ID</a></li>
			<li><a href="#finding_available_posix_clocks">Finding Available POSIX Clocks</a></li>
		</ul>

		<li><a href="#other_clocks">Other Clocks</a></li>
		<ul>

			<li><a href="#gettimeofday">gettimeofday</a></li>
			<li><a href="#mach_absolute_time">mach_absolute_time</a></li>
			<li><a href="#time__hires">Time::HiRes</a></li>
		</ul>

		<li><a href="#clock_references">Clock References</a></li>
	</ul>

	<li><a href="#caveats">CAVEATS</a></li>
	<ul>

		<li><a href="#smp_systems">SMP Systems</a></li>
		<ul>

			<li><a href="#processor_affinity">Processor Affinity</a></li>
			<li><a href="#windows">Windows</a></li>
		</ul>

		<li><a href="#virtual_machines">Virtual Machines</a></li>
	</ul>

	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#troubleshooting">TROUBLESHOOTING</a></li>
	<ul>

		<li><a href="#profile_data_incomplete_____">&quot;Profile data incomplete, ...&quot;</a></li>
		<li><a href="#some_files_don_t_have_profile_information">Some files don't have profile information</a></li>
	</ul>

	<li><a href="#authors_and_contributors">AUTHORS AND CONTRIBUTORS</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
	<li><a href="#history">HISTORY</a></li>
	<ul>

		<li><a href="#background">Background</a></li>
	</ul>

</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Devel::NYTProf - Powerful fast feature-rich perl source code profiler</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  # profile code and write database to ./nytprof.out
  perl -d:NYTProf some_perl.pl</pre>
<pre>
  # convert database into a set of html files, e.g., ./nytprof/index.html
  # and open a web browser on the nytprof/index.html file
  nytprofhtml --open</pre>
<pre>
  # or into comma separated files, e.g., ./nytprof/*.csv
  nytprofcsv</pre>
<p>A screencast about profiling perl code, including a detailed look at how to use
NYTProf and how to optimize your code, is available at <a href="http://timbunce.blip.tv/file/3913278/">http://timbunce.blip.tv/file/3913278/</a></p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Devel::NYTProf is a powerful, fast, feature-rich perl source code profiler.</p>
<ul>
<li>
<p>Performs per-line statement profiling for fine detail</p>
</li>
<li>
<p>Performs per-subroutine statement profiling for overview</p>
</li>
<li>
<p>Performs per-opcode profiling for slow perl builtins</p>
</li>
<li>
<p>Performs per-block statement profiling (the first profiler to do so)</p>
</li>
<li>
<p>Accounts correctly for time spent after calls return</p>
</li>
<li>
<p>Performs inclusive and exclusive timing of subroutines</p>
</li>
<li>
<p>Subroutine times are per calling location (a powerful feature)</p>
</li>
<li>
<p>Can profile compile-time activity, just run-time, or just END time</p>
</li>
<li>
<p>Uses novel techniques for efficient profiling</p>
</li>
<li>
<p>Sub-microsecond (100ns) resolution on supported systems</p>
</li>
<li>
<p>Very fast - the fastest statement and subroutine profilers for perl</p>
</li>
<li>
<p>Handles applications that fork, with no performance cost</p>
</li>
<li>
<p>Immune from noise caused by profiling overheads and I/O</p>
</li>
<li>
<p>Program being profiled can stop/start the profiler</p>
</li>
<li>
<p>Generates richly annotated and cross-linked html reports</p>
</li>
<li>
<p>Captures source code, including string evals, for stable results</p>
</li>
<li>
<p>Trivial to use with mod_perl - add one line to httpd.conf</p>
</li>
<li>
<p>Includes an extensive test suite</p>
</li>
<li>
<p>Tested on very large codebases</p>
</li>
</ul>
<p>NYTProf is effectively two profilers in one: a statement profiler, and a
subroutine profiler.</p>
<p>
</p>
<h2><a name="statement_profiling">Statement Profiling</a></h2>
<p>The statement profiler measures the time between entering one perl statement
and entering the next. Whenever execution reaches a new statement, the time
since entering the previous statement is calculated and added to the time
associated with the line of the source file that the previous statement starts on.</p>
<p>By default the statement profiler also determines the first line of the current
block and the first line of the current statement, and accumulates times
associated with those.</p>
<p>Another innovation unique to NYTProf is automatic compensation for a problem
inherent in simplistic statement-to-statement timing. Consider a statement that
calls a subroutine and then performs some other work that doesn't execute new
statements, for example:</p>
<pre>
  <span class="variable">foo</span><span class="operator">(...)</span> <span class="operator">+</span> <span class="keyword">mkdir</span><span class="operator">(...);</span>
</pre>
<p>In all other statement profilers the time spent in remainder of the expression
(mkdir in the example) will be recorded as having been spent <em>on the last
statement executed in foo()</em>! Here's another example:</p>
<pre>
  <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span> <span class="operator">{</span>
     <span class="operator">...</span>
     <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
</pre>
<p>After the first time around the loop, any further time spent evaluating the
condition (waiting for input in this example) would be be recorded as having
been spent <em>on the last statement executed in the loop</em>! (Until perl bug
#60954 is fixed this problem still applies to some loops. For more information
see <a href="http://rt.perl.org/rt3/Ticket/Display.html?id=60954">http://rt.perl.org/rt3/Ticket/Display.html</a>)</p>
<p>NYTProf avoids these problems by intercepting the opcodes which indicate that
control is returning into some previous statement and adjusting the profile
accordingly.</p>
<p>The statement profiler naturally generates a lot of data which is streamed out
to a file in a very compact format. NYTProf takes care to not include the
measurement and writing overheads in the profile times (some profilers produce
'noisy' data due to periodic stdio flushing).</p>
<p>
</p>
<h2><a name="subroutine_profiling">Subroutine Profiling</a></h2>
<p>The subroutine profiler measures the time between entering a subroutine and
leaving it. It then increments a call count and accumulates the duration.
For each subroutine called, separate counts and durations are stored <em>for each
location that called the subroutine</em>.</p>
<p>Subroutine entry is detected by intercepting the <code>entersub</code> opcode. Subroutine
exit is detected via perl's internal save stack. The result is both extremely
fast and very robust.</p>
<p>
</p>
<h3><a name="subroutine_recursion">Subroutine Recursion</a></h3>
<p>For subroutines that recurse directly or indirectly, such as Error::try,
the inclusive time is only measured for the outer-most call.</p>
<p>The inclusive times of recursive calls are still measured and are accumulated
separately. Also the 'maximum recursion depth' per calling location is recorded.</p>
<p>
</p>
<h3><a name="goto__subroutine">Goto &amp;Subroutine</a></h3>
<p>Perl implements a <code>goto &amp;destination</code> as a <a href="../../lib/pods/perlfunc.html#return"><code>return</code></a> followed by a call to
<code>&amp;destination</code>, so that's how it will appear in the report.</p>
<p>The <a href="../../lib/pods/perlfunc.html#goto"><code>goto</code></a> will be shown with a very short time because it's effectively just
a <a href="../../lib/pods/perlfunc.html#return"><code>return</code></a>. The <code>&amp;destination</code> sub will show a call <em>not</em> from the location
of the <a href="../../lib/pods/perlfunc.html#goto"><code>goto</code></a> but from the location of the call to the sub that performed the <a href="../../lib/pods/perlfunc.html#goto"><code>goto</code></a>.</p>
<p>
</p>
<h3><a name="accept__"><a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a></a></h3>
<p>The perl built-in <a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a> function waits listening for a connection on a
socket, and so is a key part of pure-perl network service applications.</p>
<p>The time spent waiting for a remotely initiated connection can be relatively
high but is not relevant to the performance of the application. So the <a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a>
function is treated as a special case. The subroutine profiler discounts the
time spent in the <a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a> function. It does this in a way that also discounts
that time from all the callers up the call stack. The effect on the reports is
that all <a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a> calls appear to be instant.</p>
<p>The <em>statement</em> profiler still shows the time actually spent in the statement
that executed the <a href="../../lib/pods/perlfunc.html#accept"><code>accept()</code></a> call.</p>
<p>
</p>
<h2><a name="application_profiling">Application Profiling</a></h2>
<p>NYTProf records extra information in the data file to capture details that may
be useful when analyzing the performance. It also records the filename and line
ranges of all the subroutines.</p>
<p>NYTProf can profile applications that fork, and does so with no loss of
performance.
NYTProf detects the fork and starts writing a new profile file with the pid
appended to the filename.</p>
<p>
</p>
<h2><a name="fast_profiling">Fast Profiling</a></h2>
<p>The NYTProf profiler is written almost entirely in C and great care has been
taken to ensure it's very efficient.</p>
<p>
</p>
<h2><a name="apache_profiling">Apache Profiling</a></h2>
<p>Just add one line near the start of your httpd.conf file:</p>
<pre>
  PerlModule Devel::NYTProf::Apache</pre>
<p>By default you'll get a <em class="file">/tmp/nytprof.$$.out</em> file for the parent process and
a <em class="file">/tmp/nytprof.$parent.out.$$</em> file for each worker process.</p>
<p>NYTProf takes care to detect when control is returning back from perl to
mod_perl so time spent in mod_perl (such as waiting for the next request)
does not get allocated to the last statement executed.</p>
<p>Works with mod_perl 1 and 2. See <a href="../../lib/Devel/NYTProf/Apache.html">the Devel::NYTProf::Apache manpage</a> for more information.</p>
<p>
</p>
<hr />
<h1><a name="profiling">PROFILING</a></h1>
<p>Usually you'd load Devel::NYTProf on the command line using the perl -d option:</p>
<pre>
  perl -d:NYTProf some_perl.pl</pre>
<p>To save typing the ':NYTProf' you could set the PERL5DB env var</p>
<pre>
  PERL5DB='use Devel::NYTProf'</pre>
<p>and then just perl -d would work:</p>
<pre>
  perl -d some_perl.pl</pre>
<p>Or you can avoid the need to add the -d option at all by using the <a href="../../lib/pods/perlrun.html#perl5opt"><code>PERL5OPT</code></a> env var:</p>
<pre>
  PERL5OPT=-d:NYTProf</pre>
<p>That's also very handy when you can't alter the perl command line being used to
run the script you want to profile. Usually you'll want to enable the
<a href="#addpid_1">addpid=1</a> option to ensure any nested invocations of perl don't overwrite the profile.</p>
<p>
</p>
<hr />
<h1><a name="nytprof_environment_variable">NYTPROF ENVIRONMENT VARIABLE</a></h1>
<p>The behavior of Devel::NYTProf may be modified by setting the 
environment variable <code>NYTPROF</code>.  It is possible to use this environment
variable to effect multiple setting by separating the values with a <code>:</code>.  For
example:</p>
<pre>
  export NYTPROF=trace=2:start=init:file=/tmp/nytprof.out</pre>
<p>Any colon or equal characters in a value can be escaped by preceding them with
a backslash.</p>
<p>
</p>
<h2><a name="addpid_1">addpid=1</a></h2>
<p>Append the current process id to the end of the filename.</p>
<p>This avoids concurrent, or consecutive, processes from overwriting the same file.</p>
<p>
</p>
<h2><a name="trace_n">trace=N</a></h2>
<p>Set trace level to N. 0 is off (the default). Higher values cause more detailed
trace output. Trace output is written to STDERR or wherever the <a href="#log_f">log=F</a>
option has specified.</p>
<p>
</p>
<h2><a name="log_f">log=F</a></h2>
<p>Specify the name of the file that <a href="#trace_n">trace=N</a> output should be written to.</p>
<p>
</p>
<h2><a name="start____">start=...</a></h2>
<p>Specify at which phase of program execution the profiler should be enabled:</p>
<pre>
  start=begin - start immediately (the default)
  start=init  - start at beginning of INIT phase (after compilation)
  start=end   - start at beginning of END phase
  start=no    - don't automatically start</pre>
<p>The start=no option is handy if you want to explicitly control profiling
by calling DB::enable_profile() and DB::disable_profile() yourself.</p>
<p>
</p>
<h2><a name="optimize_0">optimize=0</a></h2>
<p>Disable the perl optimizer.</p>
<p>By default NYTProf leaves perl's optimizer enabled.  That gives you more
accurate profile timing overall, but can lead to <em>odd</em> statement counts for
individual sets of lines. That's because the perl's peephole optimizer has
effectively rewritten the statements but you can't see what the rewritten
version looks like.</p>
<p>For example:</p>
<pre>
  <span class="number">1</span>     <span class="keyword">if</span> <span class="operator">(...)</span> <span class="operator">{</span>
  <span class="number">2</span>         <span class="keyword">return</span><span class="operator">;</span>
  <span class="number">3</span>     <span class="operator">}</span>
</pre>
<p>may be rewritten as</p>
<pre>
  1    return if (...)</pre>
<p>so the profile won't show a statement count for line 2 in your source code
because the <a href="../../lib/pods/perlfunc.html#return"><code>return</code></a> was merged into the <code>if</code> statement on the preceding line.</p>
<p>Also 'empty' statements like <code>1;</code> are removed entirely.  Such statements are
empty because the optimizer has already removed the pointless constant in void
context. It then goes on to remove the now empty statement (in perl &gt;= 5.13.7).</p>
<p>Using the <code>optimize=0</code> option disables the optimizer so you'll get lower
overall performance but more accurately assigned statement counts.</p>
<p>If you find any other examples of the effect of optimizer on NYTProf output
(other than performance, obviously) please let us know.</p>
<p>
</p>
<h2><a name="subs_0">subs=0</a></h2>
<p>Set to 0 to disable the collection of subroutine caller and timing details.</p>
<p>
</p>
<h2><a name="blocks_0">blocks=0</a></h2>
<p>Set to 0 to disable the determination of block and subroutine location per statement.
This makes the profiler about 50% faster (as of July 2008) and produces smaller
output files, but you lose some valuable information. The extra cost is likely
to be reduced in later versions anyway, as little optimization has been done on
that part of the code.</p>
<p>
</p>
<h2><a name="stmts_0">stmts=0</a></h2>
<p>Set to 0 to disable the statement profiler. (Implies <code>blocks=0</code>.)
The reports won't contain any statement timing detail.</p>
<p>This significantly reduces the overhead of the profiler and can also be useful
for profiling large applications that would normally generate a very large
profile data file.</p>
<p>
</p>
<h2><a name="leave_0">leave=0</a></h2>
<p>Set to 0 to disable the extra work done by the statement profiler
to allocate times accurately when
returning into the middle of statement. For example leaving a subroutine
and returning into the middle of statement, or re-evaluating a loop condition.</p>
<p>This feature also ensures that in embedded environments, such as mod_perl,
the last statement executed doesn't accumulate the time spent 'outside perl'.</p>
<p>
</p>
<h2><a name="findcaller_1">findcaller=1</a></h2>
<p>Force NYTProf to recalculate the name of the caller of the each sub instead of
'inheriting' the name calculated when the caller was entered. (Rarely needed,
but might be useful in some odd cases.)</p>
<p>
</p>
<h2><a name="use_db_sub_1">use_db_sub=1</a></h2>
<p>Set to 1 to enable use of the traditional DB::DB() subroutine to perform
profiling, instead of the faster 'opcode redirection' technique that's used by
default. Also effectively sets <code>leave=0</code> (see above).</p>
<p>The default 'opcode redirection' technique can't profile subroutines that were
compiled before NYTProf was loaded. So using use_db_sub=1 can be useful in
cases where you can't load the profiler early in the life of the application.</p>
<p>Another side effect of <code>use_db_sub=1</code> is that it enables recording of the
source code of the <code>perl -e '...'</code> and <code>perl -</code> input for old
versions of perl. See also <a href="#savesrc_0">savesrc=0</a>.</p>
<p>
</p>
<h2><a name="savesrc_0">savesrc=0</a></h2>
<p>Disable the saving of source code.</p>
<p>By default NYTProf saves a copy of all source code into the profile data file.
This makes the file self-contained, so the reporting tools no longer depend on
having the unmodified source code files available.</p>
<p>With <code>savesrc=0</code> some source code is still saved: the arguments to the
<code>perl -e</code> option, the script fed to perl via STDIN when using <code>perl -</code>,
and the source code of string evals.</p>
<p>Saving the source code of string evals requires perl version 5.8.9+, 5.10.1+,
or 5.12 or later.</p>
<p>Saving the source code of the <code>perl -e '...'</code> or <code>perl -</code> input
requires either a recent perl version, as above, or setting the <a href="#use_db_sub_1">use_db_sub=1</a> option.</p>
<p>
</p>
<h2><a name="slowops_n">slowops=N</a></h2>
<p>Profile perl opcodes that can be slow. These include opcodes that make system
calls, such as <a href="../../lib/pods/perlfunc.html#print"><code>print</code></a>, <a href="../../lib/pods/perlfunc.html#read"><code>read</code></a>, <a href="../../lib/pods/perlfunc.html#sysread"><code>sysread</code></a>, <a href="../../lib/pods/perlfunc.html#socket"><code>socket</code></a> etc., plus regular
expression opcodes like <code>subst</code> and <code>match</code>.</p>
<p>If <code>N</code> is 0 then slowops profiling is disabled.</p>
<p>If <code>N</code> is 1 then all the builtins are treated as being defined in the <code>CORE</code>
package. So times for <a href="../../lib/pods/perlfunc.html#print"><code>print</code></a> calls from anywhere in your code are merged and
accounted for as calls to an xsub called <code>CORE::print</code>.</p>
<p>If <code>N</code> is 2 (the default) then builtins are treated as being defined in the
package that calls them. So calls to <a href="../../lib/pods/perlfunc.html#print"><code>print</code></a> from package <code>Foo</code> are treated
as calls to an xsub called <code>Foo::CORE:print</code>. Note the single colon after CORE.</p>
<p>The opcodes are currently profiled using their internal names, so <a href="../../lib/pods/perlfunc.html#printf"><code>printf</code></a> is <code>prtf</code>
and the <a href="../../lib/pods/perlrun.html#x"><code>-x</code></a> file test is <code>fteexec</code>. This may change in future.</p>
<p>Opcodes that call subroutines, perhaps by triggering a FETCH from a tied
variable, currently appear in the call tree as the caller of the sub. This is
likely to change in future.</p>
<p>
</p>
<h2><a name="usecputime_1">usecputime=1</a></h2>
<p>Measure user CPU + system CPU time instead of the real elapsed 'wall clock'
time (which is the default). But there are better ways to do this, read on.</p>
<p>Measuring CPU time has the advantage of making the measurements independent of
time spent blocked waiting for the cpu or network i/o etc. But the method used
by Cusecputime=1&gt; also has the severe disadvantage of having typically <em>far</em>
less accurate timings.</p>
<p>Most systems have a 0.01 second granularity in the results from the <a href="../../lib/pods/perlfunc.html#times"><code>times()</code></a>
sytem call.  With modern processors having multi- gigahertz clocks, 0.01
seconds is like a lifetime. The 'ticks' of this CPU time clock
happen so rarely relative to the activity of a most applications that you'd
have to run the code for many hours to have any hope of reasonably useful results.</p>
<p>A much better alternative is to use the <a href="#clock_n">clock=N</a> option to select a
high-resolution CPU time clock, if available on your system, because that'll
give you higher resolution and work for the subroutine profiler as well.</p>
<p>
</p>
<h2><a name="file____">file=...</a></h2>
<p>Specify the output file to write profile data to (default: './nytprof.out').</p>
<p>
</p>
<h2><a name="compress____">compress=...</a></h2>
<p>Specify the compression level to use, if NYTProf is compiled with compression
support. Valid values are 0 to 9, with 0 disabling compression. The default is
6 as higher values yield little extra compression but the cpu cost starts to
rise significantly. Using level 1 still gives you a significant reduction in file size.</p>
<p>If NYTProf was not compiled with compression support, this option is silently ignored.</p>
<p>
</p>
<h2><a name="clock_n">clock=N</a></h2>
<p>Systems which support the <code>clock_gettime()</code> system call typically
support several clocks. By default NYTProf uses CLOCK_MONOTONIC.</p>
<p>This option enables you to select a different clock by specifying the
integer id of the clock (which may vary between operating system types).
If the clock you select isn't available then CLOCK_REALTIME is used.</p>
<p>See <a href="#clocks">CLOCKS</a> for more information.</p>
<p>
</p>
<h2><a name="sigexit_1">sigexit=1</a></h2>
<p>When perl exits normally it runs any code defined in <a href="../../lib/pods/perlvar.html#end"><code>END</code></a> blocks.
NYTProf defines an END block that finishes profiling and writes out the final
profile data.</p>
<p>If the process ends due to a signal then END blocks are not executed.
The <code>sigexit</code> option tells NYTProf to catch some signals (e.g. INT, HUP, PIPE,
SEGV, BUS) and ensure a usable by executing:</p>
<pre>
    <span class="variable">DB::finish_profile</span><span class="operator">();</span>
    <span class="keyword">exit</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<p>You can also specify which signals to catch in this way by listing them,
separated by commas, as the value of the option (case is not significant):</p>
<pre>
    sigexit=int,hup</pre>
<p>
</p>
<h2><a name="posix_exit_1">posix_exit=1</a></h2>
<p>The NYTProf subroutine profiler normally detects calls to <code>POSIX::_exit()</code>
(which exits the process without running END blocks) and automatically calls
<code>DB::finish_profile()</code> for you, so NYTProf 'just works'.</p>
<p>When using the <code>subs=0</code> option to disable the subroutine profiler the
<code>posix_exit</code> option can be used to tell NYTProf to take other steps to arrange
for <code>DB::finish_profile()</code> to be called before <code>POSIX::_exit()</code>.</p>
<p>
</p>
<h2><a name="forkdepth_n">forkdepth=N</a></h2>
<p>When a perl process that is being profiled executes a <a href="../../lib/pods/perlfunc.html#fork"><code>fork()</code></a> the child process
is also profiled. The forkdepth option can be used to control this. If
forkdepth is zero then profiling will be disabled in the child process.</p>
<p>If forkdepth is greater than zero then profiling will be enabled in the child
process and the forkdepth value in that process is decremented by one.</p>
<p>If forkdepth is -1 (the default) then there's no limit on the number of
generations of children that are profiled.</p>
<p>
</p>
<h2><a name="nameevals_0">nameevals=0</a></h2>
<p>The 'file name' of a string eval is normally a string like &quot;<code>(eval N)</code>&quot;, where
<code>N</code> is a sequence number. By default NYTProf asks perl to give evals more
informative names like &quot;<code>(eval N)[file:line]</code>&quot;, where <code>file</code> and <code>line</code> are
the file and line number where the string <a href="../../lib/pods/perlfunc.html#eval"><code>eval</code></a> was executed.</p>
<p>The <code>nameevals=0</code> option can be used to disable the more informative names and
return to the default behaviour. This may be need in rare cases where the
application code is sensitive to the name given to a <a href="../../lib/pods/perlfunc.html#eval"><code>eval</code></a>. (The most common
case in when running test suites undef NYTProf.)</p>
<p>The downside is that the NYTProf reporting tools are less useful and may get
confused if this option is used.</p>
<p>
</p>
<h2><a name="nameanonsubs_0">nameanonsubs=0</a></h2>
<p>The name of a anonymous subroutine is normally &quot;<code>__ANON__</code>&quot;.  By default
NYTProf asks perl to give anonymous subroutines more informative names like
&quot;<code>__ANON__[file:line]</code>&quot;, where <code>file</code> and <code>line</code> are the file and line
number where the anonymous subroutine was defined.</p>
<p>The <code>nameanonsubs=0</code> option can be used to disable the more informative names
and return to the default behaviour. This may be need in rare cases where the
application code is sensitive to the name given to a anonymous subroutines.
(The most common case in when running test suites undef NYTProf.)</p>
<p>The downside is that the NYTProf reporting tools are less useful and may get
confused if this option is used.</p>
<p>
</p>
<hr />
<h1><a name="run_time_control_of_profiling">RUN-TIME CONTROL OF PROFILING</a></h1>
<p>You can profile only parts of an application by calling DB::disable_profile()
to stop collecting profile data, and calling DB::enable_profile() to start
collecting profile data.</p>
<p>Using the <code>start=no</code> option lets you leave the profiler disabled initially
until you call DB::enable_profile() at the right moment.</p>
<p>The profile output file can't be used until it's been properly completed and
closed.  Calling DB::disable_profile() doesn't do that.  To make a profile file
usable before the profiled application has completed you can call
DB::finish_profile(). Alternatively you could call DB::enable_profile($newfile).</p>
<p>
</p>
<h2><a name="disable_profile">disable_profile</a></h2>
<pre>
  DB::disable_profile()</pre>
<p>Stops collection of profile data.</p>
<p>Subroutine calls which were made while profiling was enabled and are still on
the call stack (have not yet exited) will still have their profile data
collected when they exit.</p>
<p>
</p>
<h2><a name="enable_profile">enable_profile</a></h2>
<pre>
  DB::enable_profile($newfile)</pre>
<p>Enables collection of profile data. If $newfile is true the profile data will be
written to $newfile (after completing and closing the previous file, if any).
If $newfile already exists it will be deleted first.</p>
<p>
</p>
<h2><a name="finish_profile">finish_profile</a></h2>
<pre>
  DB::finish_profile()</pre>
<p>Calls DB::disable_profile(), then completes the profile data file by writing
subroutine profile data, and then closes the file. The in memory subroutine
profile data is then discarded.</p>
<p>Normally NYTProf arranges to call <code>finish_profile()</code> for you via an END block.</p>
<p>
</p>
<hr />
<h1><a name="data_collection_and_interpretation">DATA COLLECTION AND INTERPRETATION</a></h1>
<p>NYTProf tries very hard to gather accurate information.  The nature of the
internals of perl mean that, in some cases, the information that's gathered is
accurate but surprising. In some cases it can appear to be misleading.
(Of course, in some cases it may actually be plain wrong. Caveat lector.)</p>
<p>
</p>
<h2><a name="if_statement_and_subroutine_timings_don_t_match">If Statement and Subroutine Timings Don't Match</a></h2>
<p>NYTProf has two profilers: a statement profiler that's invoked when perl moves
from one perl statement to another, and a subroutine profiler that's invoked
when perl calls or returns from a subroutine.</p>
<p>The individual statement timings for a subroutine usually add up to slightly
less than the exclusive time for the subroutine. That's because the handling of
the subroutine call and return overheads is included in the exclusive time for
the subroutine. The difference may only be a new microseconds but that may
become noticeable for subroutines that are called hundreds of thousands of times.</p>
<p>The statement profiler keeps track how much time was spent on overheads, like
writing statement profile data to disk. The subroutine profiler subtracts the
overheads that have accumulated between entering and leaving the subroutine in
order to give a more accurate profile.  The statement profiler is generally
very fast because most writes get buffered for zip compression so the profiler
overhead per statement tends to be very small, often a single 'tick'.
The result is that the accumulated overhead is quite noisy. This becomes more
significant for subroutines that are called frequently and are also fast.
This may be another, smaller, contribution to the discrepancy between statement
time and exclusive times.</p>
<p>
</p>
<h2><a name="if_headline_subroutine_timings_don_t_match_the_called_subs">If Headline Subroutine Timings Don't Match the Called Subs</a></h2>
<p>Overall subroutine times are reported with a headline like <code>spent 10s (2+8) within ...</code>.
In this example, 10 seconds were spent inside the subroutine (the &quot;inclusive
time&quot;) and, of that, 8 seconds were spent in subroutines called by this one.
That leaves 2 seconds as the time spent in the subroutine code itself (the
&quot;exclusive time&quot;, sometimes also called the &quot;self time&quot;).</p>
<p>The report shows the source code of the subroutine. Lines that make calls to
other subroutines are annotated with details of the time spent in those calls.</p>
<p>Sometimes the sum of the times for calls made by the lines of code in the
subroutine is less than the inclusive-exclusive time reported in the headline
(10-2 = 8 seconds in the example above).</p>
<p>What's happening here is that calls to other subroutines are being made but
NYTProf isn't able to determine the calling location correctly so the calls
don't appear in the report in the correct place.</p>
<p>Using an old version of perl is one cause (see below). Another is calling
subroutines that exit via <code>goto &amp;sub;</code> - most frequently encountered in
AUTOLOAD subs and code using the <a href="../../lib/Memoize.html">the Memoize manpage</a> module.</p>
<p>In general the overall subroutine timing is accurate and should be trusted more
than the sum of statement or nested sub call timings.</p>
<p>
</p>
<h2><a name="perl_5_10_1___or_else_5_8_9___is_recommended">Perl 5.10.1+ (or else 5.8.9+) is Recommended</a></h2>
<p>These versions of perl yield much more detailed information about calls to
BEGIN, CHECK, INIT, and END blocks, the code handling tied or overloaded
variables, and callbacks from XS code.</p>
<p>Perl 5.12 will hopefully also fix an inaccuracy in the timing of the last
statement and the condition clause of some kinds of loops:
<a href="http://rt.perl.org/rt3/Ticket/Display.html?id=60954">http://rt.perl.org/rt3/Ticket/Display.html</a></p>
<p>
</p>
<h2><a name="eval__string">eval $string</a></h2>
<p>Perl treats each execution of a string eval (<code>eval $string;</code> not <a href="../../lib/pods/perlfunc.html#eval"><code>eval { ...  }</code></a>)
as a distinct file, so NYTProf does as well. The 'files' are given names with
this structure:</p>
<pre>
        (eval $sequence)[$filename:$line]</pre>
<p>for example &quot;<code>(eval 93)[/foo/bar.pm:42]</code>&quot; would be the name given to the
93rd execution of a string eval by that process and, in this case, the 93rd
eval happened to be one at line 42 of &quot;/foo/bar.pm&quot;.</p>
<p>Nested string evals can give rise to file names like</p>
<pre>
        (eval 1047)[(eval 93)[/foo/bar.pm:42]:17]</pre>
<p>
</p>
<h3><a name="merging_evals">Merging Evals</a></h3>
<p>Some applications execute a great many string eval statements. If NYTProf generated
a report page for each one it would not only slow report generation but also
make the overall report less useful by scattering performance data too widely.
On the other hand, being able to see the actual source code executed by an
eval, along with the timing details, is often <em>very</em> useful.</p>
<p>To try to balance these conflicting needs, NYTProf currently <em>merges
uninteresting string eval siblings</em>.</p>
<p>What does that mean? Well, for each source code line that executed any string
evals, NYTProf first gathers the corresponding eval 'files' for that line
(known as the 'siblings') into groups keyed by distinct source code.</p>
<p>Then, for each of those groups of siblings, NYTProf will 'merge' a group
that shares the same source code and doesn't execute any string evals itself.
Merging means to pick one sibling as the survivor and merge and delete all
the data from the others into it.</p>
<p>If there are a large number of sibling groups then the data for all of them are
merged into one regardless.</p>
<p>The report annotations will indicate when evals have been merged together.</p>
<p>
</p>
<h3><a name="merging_anonymous_subroutines">Merging Anonymous Subroutines</a></h3>
<p>Anonymous subroutines defined within string evals have names like this:</p>
<pre>
        main::__ANON__[(eval 75)[/foo/bar.pm:42]:12]</pre>
<p>That anonymous subroutine was defined on line 12 of the source code executed by
the string eval on line 42 of <em class="file">/foo/bar.pm</em>. That was the 75th string eval
executed by the program.</p>
<p>Anonymous subroutines <em>defined on the same line of sibling evals that get
merged</em> are also merged. That is, the profile information is merged into
one and the others are discarded.</p>
<p>
</p>
<h3><a name="timing">Timing</a></h3>
<p>Care should be taken when interpreting the report annotations associated with a
string eval statement.  Normally the report annotations embedded into the
source code related to timings from the <em>subroutine</em> profiler. This isn't
(currently) true of annotations for string eval statements.</p>
<p>This makes a significant different if the eval defines any subroutines that get
called <em>after</em> the eval has returned. Because the time shown for a string eval
is based on the <em>statement</em> times it will include time spent executing
statements within the subs defined by the eval.</p>
<p>In future NYTProf may involve the subroutine profiler in timings evals and so
be able to avoid this issue.</p>
<p>
</p>
<h2><a name="calls_from_xsubs_and_opcodes">Calls from XSUBs and Opcodes</a></h2>
<p>Calls record the current filename and line number of the perl code at the time
the call was made. That's fine and accurate for calls from perl code. For calls
that originate from C code however, such as an XSUB or an opcode, the filename and
line number recorded are still those of the last <em>perl</em> statement executed.</p>
<p>For example, a line that calls an xsub will appear in reports to also have also
called any subroutines that that xsub called. This can be construed as a feature.</p>
<p>As an extreme example, the first time a regular expression that uses character
classes is executed on a unicode string you'll find profile data like this:</p>
<pre>
      <span class="comment"># spent 1ms within main::BEGIN@4 which was called</span>
      <span class="comment">#    once (1ms+0s) by main::CORE:subst at line 0</span>
        <span class="number">4</span>   <span class="regex">s/ (?: [A-Z] | [\d] )+ (?= [\s] ) //x</span><span class="operator">;</span>
      <span class="comment"># spent  38.8ms making 1 call to main::CORE:subst</span>
      <span class="comment"># spent  25.4ms making 2 calls to utf8::SWASHNEW, avg 12.7ms/call</span>
      <span class="comment"># spent  12.4ms making 1 call to utf8::AUTOLOAD</span>
</pre>
<p>
</p>
<hr />
<h1><a name="making_nytprof_faster">MAKING NYTPROF FASTER</a></h1>
<p>You can reduce the cost of profiling by adjusting some options. The trade-off
is reduced detail and/or accuracy in reports.</p>
<p>If you don't need statement-level profiling then you can disable it via <a href="#stmts_0">stmts=0</a>.
If you do want it but don't mind loosing block-level timings then set <a href="#blocks_0">blocks=0</a>.
To further boost statement-level profiling performance try <a href="#leave_0">leave=0</a> but note that
<em>will</em> apportion timings for some kinds of statements less accurate).</p>
<p>If you don't need subroutine profiling then you can disable it via <a href="#subs_0">subs=0</a>.
If you do need it but don't need timings for perl opcodes then set <a href="#slowops_0">slowops=0</a>.</p>
<p>Generally speaking, setting blocks=0 and slowops=0 will give you a useful boost
with the least loss of detail.</p>
<p>Another approach is to only enable NYTProf in the sections of code that
interest you. See <a href="#run_time_control_of_profiling">RUN-TIME CONTROL OF PROFILING</a> for more details.</p>
<p>To speed up <a href="../../bin/nytprofhtml.html">the nytprofhtml manpage</a> try using the --minimal (-m) option.</p>
<p>
</p>
<hr />
<h1><a name="reports">REPORTS</a></h1>
<p>The <a href="../../lib/Devel/NYTProf/Data.html">the Devel::NYTProf::Data manpage</a> module provides a low-level interface for loading
the profile data.</p>
<p>The <a href="../../lib/Devel/NYTProf/Reader.html">the Devel::NYTProf::Reader manpage</a> module provides an interface for generating
arbitrary reports.  This means that you can implement your own output format in
perl. (Though the module is in a state of flux and may be deprecated soon.)</p>
<p>Included in the bin directory of this distribution are some scripts which
turn the raw profile data into more useful formats:</p>
<p>
</p>
<h2><a name="nytprofhtml">nytprofhtml</a></h2>
<p>Creates attractive, richly annotated, and fully cross-linked html
reports (including statistics, source code and color highlighting).
This is the main report generation tool for NYTProf.</p>
<p>
</p>
<h2><a name="nytprofcsv">nytprofcsv</a></h2>
<p>Creates comma delimited profile reports. Old and limited.</p>
<p>
</p>
<h2><a name="nytprofcg">nytprofcg</a></h2>
<p>Translates a profile into a format that can be loaded into KCachegrind
<a href="http://kcachegrind.sourceforge.net">http://kcachegrind.sourceforge.net</a></p>
<p>
</p>
<h2><a name="nytprofmerge">nytprofmerge</a></h2>
<p>Reads multiple profile data files and writes out a new file containing the merged profile data.</p>
<p>
</p>
<hr />
<h1><a name="limitations">LIMITATIONS</a></h1>
<p>
</p>
<h2><a name="threads_and_multiplicity">Threads and Multiplicity</a></h2>
<p><code>Devel::NYTProf</code> is not currently thread safe or multiplicity safe.
If you'd be interested in helping to fix that then please get in
touch with us. Meanwhile, profiling is disabled when a thread is created, and
NYTProf tries to ignore any activity from perl interpreters other than the
first one that loaded it.</p>
<p>
</p>
<h2><a name="coro">Coro</a></h2>
<p>The <code>Devel::NYTProf</code> subroutine profiler gets confused by the stack gymnastics
performed by the <em>Coro</em> module and aborts. When profiling applications that
use Coro you should disable the subroutine profiler using the <a href="#subs_0">subs=0</a> option.</p>
<p>
</p>
<h2><a name="for_perl___5_8_8_it_may_change_what_caller___returns">For perl &lt; 5.8.8 it may change what <a href="../../lib/pods/perlfunc.html#caller"><code>caller()</code></a> returns</a></h2>
<p>For example, the <a href="../../lib/Readonly.html">the Readonly manpage</a> module croaks with &quot;Invalid tie&quot; when profiled with
perl versions before 5.8.8. That's because <a href="../../lib/Readonly.html">the Readonly manpage</a> explicitly checking for
certain values from <a href="../../lib/pods/perlfunc.html#caller"><code>caller()</code></a>. The <a href="../../lib/NEXT.html">the NEXT manpage</a> module is also affected.</p>
<p>
</p>
<h2><a name="for_perl___5_10_1_it_can_t_see_some_implicit_calls_and_callbacks">For perl &lt; 5.10.1 it can't see some implicit calls and callbacks</a></h2>
<p>For perl versions prior to 5.8.9 and 5.10.1, some implicit subroutine calls
can't be seen by the <em>subroutine</em> profiler. Technically this affects calls
made via the various perl <code>call_*()</code> internal APIs.</p>
<p>For example, BEGIN/CHECK/INIT/END blocks, the <code>TIE</code><em>whatever</em> subroutine
called by <a href="../../lib/pods/perlfunc.html#tie"><code>tie()</code></a>, all calls made via operator overloading, and callbacks from
XS code, are not seen.</p>
<p>The effect is that time in those subroutines is accumulated by the
subs that triggered the call to them. So time spent in calls invoked by
perl to handle overloading are accumulated by the subroutines that trigger
overloading (so it is measured, but the cost is dispersed across possibly many
calling locations).</p>
<p>Although the calls aren't seen by the subroutine profiler, the individual
<em>statements</em> executed by the code in the called subs are profiled by the
statement profiler.</p>
<p>
</p>
<h2><a name="_line_directives">#line directives</a></h2>
<p>The reporting code currently doesn't handle #line directives, but at least it
warns about them. Patches welcome.</p>
<p>
</p>
<h2><a name="freed_values_in____may_be_mutated">Freed values in @_ may be mutated</a></h2>
<p>Perl has a class of bugs related to the fact that values placed in the stack
are not reference counted. Consider this example:</p>
<pre>
  <span class="variable">@a</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">9</span><span class="operator">);</span>  <span class="keyword">sub</span><span class="variable"> s </span><span class="operator">{</span> <span class="keyword">undef</span> <span class="variable">@a</span><span class="operator">;</span> <span class="keyword">print</span> <span class="variable">$_</span> <span class="keyword">for</span> <span class="variable">@_</span> <span class="operator">}</span>  <span class="regex">s(</span><span class="variable">@a</span><span class="regex">);
  </span>
</pre>
<p>The <code>undef @a</code> frees the values that <a href="../../lib/pods/perlvar.html#__"><code>@_</code></a> refers to. Perl can sometimes
detect when a freed value is accessed and treats it as an undef. However, if
the freed value is assigned some new value then @_ is effectively corrupted.</p>
<p>NYTProf allocates new values while it's profiling, in order to record program
activity, and so may appear to corrupt <a href="../../lib/pods/perlvar.html#__"><code>@_</code></a> in this (rare) situation.  If this
happens, NYTProf is simply exposing an existing problem in the code.</p>
<p>
</p>
<h2><a name="lvalue_subroutines_aren_t_profiled_when_using_use_db_sub_1">Lvalue subroutines aren't profiled when using use_db_sub=1</a></h2>
<p>Currently 'lvalue' subroutines (subs that can be assigned to, like <code>foo() =
42</code>) are not profiled when using use_db_sub=1.</p>
<p>
</p>
<hr />
<h1><a name="clocks">CLOCKS</a></h1>
<p>Here we discuss the way NYTProf gets high-resolution timing information from
your system and related issues.</p>
<p>
</p>
<h2><a name="posix_clocks">POSIX Clocks</a></h2>
<p>These are the clocks that your system may support if it supports the POSIX
<code>clock_gettime()</code> function. Other clock sources are listed in the
<a href="#other_clocks">Other Clocks</a> section below.</p>
<p>The <code>clock_gettime()</code> interface allows clocks to return times to nanosecond
precision. Of course few offer nanosecond <em>accuracy</em> but the extra precision
helps reduce the cumulative error that naturally occurs when adding together
many timings. When using these clocks NYTProf outputs timings as a count of 100
nanosecond ticks.</p>
<p>
</p>
<h3><a name="clock_monotonic">CLOCK_MONOTONIC</a></h3>
<p>CLOCK_MONOTONIC represents the amount of time since an unspecified point in
the past (typically system start-up time).  It increments uniformly
independent of adjustments to 'wallclock time'. NYTProf will use this clock by
default, if available.</p>
<p>
</p>
<h3><a name="clock_realtime">CLOCK_REALTIME</a></h3>
<p>CLOCK_REALTIME is typically the system's main high resolution 'wall clock time'
source.  The same source as used for the <code>gettimeofday()</code> call used by most kinds
of perl benchmarking and profiling tools.</p>
<p>The problem with real time is that it's far from simple. It tends to drift and
then be reset to match 'reality', either sharply or by small adjustments (via the
<code>adjtime()</code> system call).</p>
<p>Surprisingly, it can also go backwards, for reasons explained in
<a href="http://preview.tinyurl.com/5wawnn">http://preview.tinyurl.com/5wawnn</a> so CLOCK_MONOTONIC is preferred.</p>
<p>
</p>
<h3><a name="clock_virtual">CLOCK_VIRTUAL</a></h3>
<p>CLOCK_VIRTUAL increments only when the CPU is running in user mode on behalf of the calling process.</p>
<p>
</p>
<h3><a name="clock_prof">CLOCK_PROF</a></h3>
<p>CLOCK_PROF increments when the CPU is running in user <em>or</em> kernel mode.</p>
<p>
</p>
<h3><a name="clock_process_cputime_id">CLOCK_PROCESS_CPUTIME_ID</a></h3>
<p>CLOCK_PROCESS_CPUTIME_ID represents the amount of execution time of the process associated with the clock.</p>
<p>
</p>
<h3><a name="clock_thread_cputime_id">CLOCK_THREAD_CPUTIME_ID</a></h3>
<p>CLOCK_THREAD_CPUTIME_ID represents the amount of execution time of the thread associated with the clock.</p>
<p>
</p>
<h3><a name="finding_available_posix_clocks">Finding Available POSIX Clocks</a></h3>
<p>On unix-like systems you can find the CLOCK_* clocks available on you system
using a command like:</p>
<pre>
  grep -r 'define *CLOCK_' /usr/include</pre>
<p>Look for a group that includes CLOCK_REALTIME. The integer values listed are
the clock ids that you can use with the <code>clock=N</code> option.</p>
<p>A future version of NYTProf should be able to list the supported clocks.</p>
<p>
</p>
<h2><a name="other_clocks">Other Clocks</a></h2>
<p>This section lists other clock sources that NYTProf may use.</p>
<p>If your system doesn't support <code>clock_gettime()</code> then NYTProf will use
<code>gettimeofday()</code>, or the nearest equivalent,</p>
<p>
</p>
<h3><a name="gettimeofday">gettimeofday</a></h3>
<p>This is the traditional high resolution time of day interface for most
unix-like systems.  With this clock NYTProf outputs timings as a count of 1
microsecond ticks.</p>
<p>
</p>
<h3><a name="mach_absolute_time">mach_absolute_time</a></h3>
<p>On Mac OS X the <code>mach_absolute_time()</code> function is used. With this clock NYTProf
outputs timings as a count of 100 nanosecond ticks.</p>
<p>
</p>
<h3><a name="time__hires">Time::HiRes</a></h3>
<p>On systems which don't support other clocks, NYTProf falls back to using the
<a href="../../lib/Time/HiRes.html">the Time::HiRes manpage</a> module.  With this clock NYTProf outputs timings as a count of 1
microsecond ticks.</p>
<p>
</p>
<h2><a name="clock_references">Clock References</a></h2>
<p>Relevant specifications and manual pages:</p>
<pre>
  <a href="http://www.opengroup.org/onlinepubs/000095399/functions/clock_getres.html">http://www.opengroup.org/onlinepubs/000095399/functions/clock_getres.html</a>
  <a href="http://linux.die.net/man/3/clock_gettime">http://linux.die.net/man/3/clock_gettime</a></pre>
<p>Why 'realtime' can appear to go backwards:</p>
<pre>
  <a href="http://preview.tinyurl.com/5wawnn">http://preview.tinyurl.com/5wawnn</a></pre>
<p>
</p>
<hr />
<h1><a name="caveats">CAVEATS</a></h1>
<p>
</p>
<h2><a name="smp_systems">SMP Systems</a></h2>
<p>On systems with multiple processors, which includes most modern machines,
(from Linux docs though applicable to most SMP systems):</p>
<pre>
  The CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID clocks are realized on
  many platforms using timers from the CPUs (TSC on i386, AR.ITC on Itanium).
  These registers may differ between CPUs and as a consequence these clocks may
  return bogus results if a process is migrated to another CPU.</pre>
<pre>
  If the CPUs in an SMP system have different clock sources then there is no way
  to maintain a correlation between the timer registers since each CPU will run
  at a slightly different frequency. If that is the case then
  clock_getcpuclockid(0) will return ENOENT to signify this condition. The two
  clocks will then only be useful if it can be ensured that a process stays on a
  certain CPU.</pre>
<pre>
  The processors in an SMP system do not start all at exactly the same time and
  therefore the timer registers are typically running at an offset. Some
  architectures include code that attempts to limit these offsets on bootup.
  However, the code cannot guarantee to accurately tune the offsets. Glibc
  contains no provisions to deal with these offsets (unlike the Linux Kernel).
  Typically these offsets are small and therefore the effects may be negligible
  in most cases.</pre>
<p>In summary, SMP systems are likely to give 'noisy' profiles.
Setting a <a href="#processor_affinity">Processor Affinity</a> may help.</p>
<p>
</p>
<h3><a name="processor_affinity">Processor Affinity</a></h3>
<p>Processor affinity is an aspect of task scheduling on SMP systems.
&quot;Processor affinity takes advantage of the fact that some remnants of a process
may remain in one processor's state (in particular, in its cache) from the last
time the process ran, and so scheduling it to run on the same processor the
next time could result in the process running more efficiently than if it were
to run on another processor.&quot; (From <a href="http://en.wikipedia.org/wiki/Processor_affinity)">http://en.wikipedia.org/wiki/Processor_affinity)</a></p>
<p>Setting an explicit processor affinity can avoid the problems described in
<a href="#smp_systems">SMP Systems</a>.</p>
<p>Processor affinity can be set using the <code>taskset</code> command on Linux.</p>
<p>Note that processor affinity is inherited by child processes, so if the process
you're profiling spawns cpu intensive sub processes then your process will be
impacted by those more than it otherwise would.</p>
<p>
</p>
<h3><a name="windows">Windows</a></h3>
<p>On Windows NYTProf uses Time::HiRes which uses the windows
<code>QueryPerformanceCounter()</code> API with some extra logic to adjust for the current
clock speed and try to resync the raw counter to wallclock time every so often
(every 30 seconds or if the timer drifts by more than 0.5 of a seconds).
This extra logic may lead to occasional spurious results.</p>
<p>(It would be great if someone could contribute a patch to NYTProf to use
<code>QueryPerformanceCounter()</code> directly and avoid the overheads and resyncing
behaviour of Time::HiRes.)</p>
<p>
</p>
<h2><a name="virtual_machines">Virtual Machines</a></h2>
<p>I recommend you don't do performance profiling while running in a
virtual machine.  If you do you're likely to find inexplicable spikes
of real-time appearing at unreasonable places in your code. You should pay
less attention to the statement timings and rely more on the subroutine
timings. They will still be noisy but less so than the statement times.</p>
<p>You could also try using the <code>clock=N</code> option to select a high-resolution
<em>cpu-time</em> clock instead of a real-time one. That should be much less
noisy, though you will lose visibility of wait-times due to network
and disk I/O, for example.</p>
<p>If your system doesn't support the <code>clock=N</code> option then you could try
using the <code>usecputime=1</code> option. That will give you cpu-time measurements
but only at a very low 1/100th of a second resolution.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Possibly. All complex software has bugs. Let me know if you find one.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>Screenshots of <a href="../../bin/nytprofhtml.html">the nytprofhtml manpage</a> v2.01 reports can be seen at
<a href="http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-index.png">http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-index.png</a> and
<a href="http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-all-perl-files.png">http://timbunce.files.wordpress.com/2008/07/nytprof-perlcritic-all-perl-files.png</a>.
A writeup of the new features of NYTProf v2 can be found at
<a href="http://blog.timbunce.org/2008/07/15/nytprof-v2-a-major-advance-in-perl-profilers/">http://blog.timbunce.org/2008/07/15/nytprof-v2-a-major-advance-in-perl-profilers/</a>
and the background story, explaining the &quot;why&quot;, can be found at
<a href="http://blog.timbunce.org/2008/07/16/nytprof-v2-the-background-story/">http://blog.timbunce.org/2008/07/16/nytprof-v2-the-background-story/</a>.</p>
<p>Mailing list and discussion at <a href="http://groups.google.com/group/develnytprof-dev">http://groups.google.com/group/develnytprof-dev</a></p>
<p>Blog posts <a href="http://blog.timbunce.org/tag/nytprof/">http://blog.timbunce.org/tag/nytprof/</a></p>
<p>Public SVN Repository and hacking instructions at <a href="http://code.google.com/p/perl-devel-nytprof/">http://code.google.com/p/perl-devel-nytprof/</a></p>
<p><a href="../../bin/nytprofhtml.html">the nytprofhtml manpage</a> is a script included that produces html reports.
<a href="../../bin/nytprofcsv.html">the nytprofcsv manpage</a> is another script included that produces plain text CSV reports.</p>
<p><a href="../../lib/Devel/NYTProf/Reader.html">the Devel::NYTProf::Reader manpage</a> is the module that powers the report scripts.  You
might want to check this out if you plan to implement a custom report (though
it's very likely to be deprecated in a future release).</p>
<p><a href="../../lib/Devel/NYTProf/ReadStream.html">the Devel::NYTProf::ReadStream manpage</a> is the module that lets you read a profile data
file as a stream of chunks of data.</p>
<p>
</p>
<hr />
<h1><a name="troubleshooting">TROUBLESHOOTING</a></h1>
<p>
</p>
<h2><a name="profile_data_incomplete_____">&quot;Profile data incomplete, ...&quot;</a></h2>
<p>This error message means the file doesn't contain all the expected data.
That may be because it was truncated (perhaps the filesystem was full) or,
more commonly, because the all the expected data hasn't been written.</p>
<p>NYTProf writes some important data to the data file when <em>finishing</em> profiling.
If you read the file before the profiling has finished you'll get this error.</p>
<p>If the process being profiled is still running you'll need to wait until it
exits cleanly (runs <a href="../../lib/pods/perlvar.html#end"><code>END</code></a> blocks or <a href="#finish_profile">finish_profile</a> is called explicitly).</p>
<p>If the process being profiled has exited then it's likely that it met with a
sudden and unnatural death that didn't give NYTProf a chance to finish the profile.
If the sudden death was due to a signal then <a href="#sigexit_1">sigexit=1</a> may help.
If the sudden death was due to calling <code>POSIX::_exit($status)</code> then you'll
need to call <a href="#finish_profile">finish_profile</a> before calling <code>POSIX::_exit</code>.</p>
<p>
</p>
<h2><a name="some_files_don_t_have_profile_information">Some files don't have profile information</a></h2>
<p>This is usually due to NYTProf being loaded after the other files, for example</p>
<p>If you can't alter the command line to add &quot;<code>-d:NYTProf</code>&quot; you could try using
the <a href="../../lib/pods/perlrun.html#perl5opt"><code>PERL5OPT</code></a> environment variable. See <a href="#profiling">PROFILING</a>.</p>
<p>
</p>
<hr />
<h1><a name="authors_and_contributors">AUTHORS AND CONTRIBUTORS</a></h1>
<p><strong>Tim Bunce</strong> (<a href="http://www.tim.bunce.name">http://www.tim.bunce.name</a> and <a href="http://blog.timbunce.org">http://blog.timbunce.org</a>)
leads the project and has done most of the development work thus far.</p>
<p><strong>Nicholas Clark</strong> contributed zip compression and <code>nytprofmerge</code>.
<strong>Chia-liang Kao</strong> contributed <code>nytprofcg</code>.
<strong>Peter (Stig) Edwards</strong> contributed the VMS port.
<strong>Jan Dubois</strong> contributed the Windows port.
<strong>Gisle Aas</strong> contributed the Devel::NYTProf::ReadStream module.
<strong>Steve Peters</strong> contributed greater perl version portability and use of POSIX
high-resolution clocks.
Other contributors are noted in the Changes file.</p>
<p>Many thanks to <strong>Adam Kaplan</strong> who created <code>NYTProf</code> initially by forking
<code>Devel::FastProf</code> adding reporting from <code>Devel::Cover</code> and a test suite.
For more details see <a href="#history">HISTORY</a> below.</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<pre>
  Copyright (C) 2008 by Adam Kaplan and The New York Times Company.
  Copyright (C) 2008-2010 by Tim Bunce, Ireland.</pre>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.</p>
<p>
</p>
<hr />
<h1><a name="history">HISTORY</a></h1>
<p>A bit of history (and a shameless plug from Adam)...</p>
<p>NYTProf stands for 'New York Times Profiler'. Indeed, this module was initially
developed from Devel::FastProf by The New York Times Co. to help our developers
quickly identify bottlenecks in large Perl applications.  The NY Times loves
Perl and we hope the community will benefit from our work as much as we have
from theirs.</p>
<p>Please visit <a href="http://open.nytimes.com">http://open.nytimes.com</a>, our open source blog to see what we
are up to, <a href="http://code.nytimes.com">http://code.nytimes.com</a> to see some of our open projects and then
check out <a href="http://nytimes.com">http://nytimes.com</a> for the latest news!</p>
<p>
</p>
<h2><a name="background">Background</a></h2>
<p>Subroutine-level profilers:</p>
<pre>
  Devel::DProf        | 1995-10-31 | ILYAZ
  Devel::AutoProfiler | 2002-04-07 | GSLONDON
  Devel::Profiler     | 2002-05-20 | SAMTREGAR
  Devel::Profile      | 2003-04-13 | JAW
  Devel::DProfLB      | 2006-05-11 | JAW
  Devel::WxProf       | 2008-04-14 | MKUTTER</pre>
<p>Statement-level profilers:</p>
<pre>
  Devel::SmallProf    | 1997-07-30 | ASHTED
  Devel::FastProf     | 2005-09-20 | SALVA
  Devel::NYTProf      | 2008-03-04 | AKAPLAN
  Devel::Profit       | 2008-05-19 | LBROCARD</pre>
<p>Devel::NYTProf is a (now distant) fork of Devel::FastProf, which was itself an
evolution of Devel::SmallProf.</p>
<p>Adam Kaplan took Devel::FastProf and added html report generation (based on
Devel::Cover) and a test suite - a tricky thing to do for a profiler.
Meanwhile Tim Bunce had been extending Devel::FastProf to add novel
per-sub and per-block timing, plus subroutine caller tracking.</p>
<p>When Devel::NYTProf was released Tim switched to working on Devel::NYTProf
because the html report would be a good way to show the extra profile data, and
the test suite made development much easier and safer.</p>
<p>Then he went a little crazy and added a slew of new features, in addition to
per-sub and per-block timing and subroutine caller tracking. These included the
'opcode interception' method of profiling, ultra-fast and robust inclusive
subroutine timing, doubling performance, plus major changes to html reporting
to display all the extra profile call and timing data in richly annotated and
cross-linked reports.</p>
<p>Steve Peters came on board along the way with patches for portability and to
keep NYTProf working with the latest development perl versions. Nicholas Clark
added zip compression, many optimizations, and <code>nytprofmerge</code>.
Jan Dubois contributed Windows support.</p>
<p>Adam's work is sponsored by The New York Times Co. <a href="http://open.nytimes.com">http://open.nytimes.com</a>.
Tim's work was partly sponsored by Shopzilla <a href="http://www.shopzilla.com">http://www.shopzilla.com</a> during 2008.</p>

</body>

</html>
